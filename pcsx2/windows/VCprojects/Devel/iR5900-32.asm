; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

	TITLE	D:\Downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\iR5900-32.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	?g_EEFreezeRegs@@3_NA				; g_EEFreezeRegs
PUBLIC	?g_cpuConstRegs@@3PATGPR_reg64@@A		; g_cpuConstRegs
PUBLIC	?g_cpuHasConstReg@@3IA				; g_cpuHasConstReg
PUBLIC	?pc@@3IA					; pc
PUBLIC	?g_cpuFlushedConstReg@@3IA			; g_cpuFlushedConstReg
PUBLIC	?branch@@3HA					; branch
PUBLIC	??_C@_0BO@BJGNDGDH@Processor?5doesn?8t?5support?5MMX?$AA@ ; `string'
PUBLIC	??_C@_0BO@EAHPPEPN@Processor?5doesn?8t?5support?5SSE?$AA@ ; `string'
PUBLIC	??_C@_0BP@CODMKFCE@Processor?5doesn?8t?5support?5SSE2?$AA@ ; `string'
PUBLIC	??_C@_0BA@GOFBLDMA@recAlloc?$CIR5900?$CJ?$AA@	; `string'
PUBLIC	??_C@_0DB@KMMEHCKA@R5900?932?5?$DO?5failed?5to?5allocate?5re@ ; `string'
PUBLIC	??_C@_0EA@NGEJMDFP@R5900?932?5Init?5?$DO?5Failed?5to?5alloca@ ; `string'
PUBLIC	??_C@_0DK@KMFNGPCI@R5900?932?5Init?5?$DO?5failed?5to?5alloca@ ; `string'
PUBLIC	??_C@_05OAHDOEDM@EERec?$AA@			; `string'
PUBLIC	??_C@_0DF@HHKJLMIF@Pcsx2?5Foopah?$CB?5?5Frozen?5regs?5have?5@ ; `string'
PUBLIC	??_C@_0O@HOCNDIGO@delay?5slot?5?$CFx?$AA@	; `string'
PUBLIC	??_C@_0BJ@BNOPKFMB@branch?5?$CFx?5in?5delay?5slot?$CB?$AA@ ; `string'
PUBLIC	??_C@_08HNLAIHMJ@Bad?5esp?$CB?$AA@		; `string'
PUBLIC	??_C@_0CD@COAJMALJ@dyna_block_discard?5?$CF08X?5?0?5count?5@ ; `string'
PUBLIC	??_C@_0BJ@KGMIHJML@EE?5Recompiler?5data?5reset?$AA@ ; `string'
PUBLIC	??_C@_0BK@FEKONKNL@EE?5recompiler?5stack?5reset?$AA@ ; `string'
PUBLIC	?recCpu@@3UR5900cpu@@A				; recCpu
PUBLIC	__CTA3?AVHardwareDeficiency@Exception@@
PUBLIC	__CT??_R0?AVHardwareDeficiency@Exception@@@8??0HardwareDeficiency@Exception@@QAE@ABV01@@Z28
PUBLIC	??_R0?AVHardwareDeficiency@Exception@@@8	; Exception::HardwareDeficiency `RTTI Type Descriptor'
PUBLIC	__TI3?AVHardwareDeficiency@Exception@@
PUBLIC	?s_pDispatchBlock@@3PBUBASEBLOCK@@B		; s_pDispatchBlock
PUBLIC	?s_ConstGPRreg@@3TGPR_reg64@@A			; s_ConstGPRreg
PUBLIC	?s_saveConstGPRreg@@3IA				; s_saveConstGPRreg
PUBLIC	?s_nBlockCycles@@3IA				; s_nBlockCycles
PUBLIC	?recLUT@@3PAIA					; recLUT
PUBLIC	?maxrecmem@@3IA					; maxrecmem
PUBLIC	??_7HardwareDeficiency@Exception@@6B@		; Exception::HardwareDeficiency::`vftable'
EXTRN	__imp___aligned_free:PROC
EXTRN	__imp___aligned_malloc:PROC
?g_EEFreezeRegs@@3_NA DB 01H DUP (?)			; g_EEFreezeRegs
	ALIGN	4

?g_cpuConstRegs@@3PATGPR_reg64@@A DB 0200H DUP (?)	; g_cpuConstRegs
?g_cpuHasConstReg@@3IA DD 01H DUP (?)			; g_cpuHasConstReg
?pc@@3IA DD	01H DUP (?)				; pc
?g_cpuFlushedConstReg@@3IA DD 01H DUP (?)		; g_cpuFlushedConstReg
?branch@@3HA DD	01H DUP (?)				; branch
_m_recBlockAlloc DD 01H DUP (?)
_s_savenBlockCycles DD 01H DUP (?)
_s_psaveInstInfo DD 01H DUP (?)
_s_saveRegHasSignExt DD 01H DUP (?)
_s_saveRegHasLive1 DD 01H DUP (?)
_s_saveFlushedConstReg DD 01H DUP (?)
_s_saveHasConstReg DD 01H DUP (?)
_s_nNextBlock DD 01H DUP (?)
_s_nHasDelay DD	01H DUP (?)
_s_nEndBlock DD	01H DUP (?)
?s_pDispatchBlock@@3PBUBASEBLOCK@@B DD 01H DUP (?)	; s_pDispatchBlock
_s_pCurBlockEx DD 01H DUP (?)
_s_pCurBlock DD	01H DUP (?)
_s_nInstCacheSize DD 01H DUP (?)
_s_pInstCache DD 01H DUP (?)
_recStackPtr DD	01H DUP (?)
_recPtr	DD	01H DUP (?)
_recBlocks DD	01H DUP (?)
_recROM1 DD	01H DUP (?)
_recROM	DD	01H DUP (?)
_recRAM	DD	01H DUP (?)
_recStack DD	01H DUP (?)
_recMem	DD	01H DUP (?)
?s_ConstGPRreg@@3TGPR_reg64@@A DB 010H DUP (?)		; s_ConstGPRreg
?s_saveConstGPRreg@@3IA DD 01H DUP (?)			; s_saveConstGPRreg
?s_nBlockCycles@@3IA DD 01H DUP (?)			; s_nBlockCycles
?recLUT@@3PAIA DD 01H DUP (?)				; recLUT
?maxrecmem@@3IA DD 01H DUP (?)				; maxrecmem
_BSS	ENDS
;	COMDAT ??_7HardwareDeficiency@Exception@@6B@
CONST	SEGMENT
??_7HardwareDeficiency@Exception@@6B@ DD FLAT:??_EHardwareDeficiency@Exception@@UAEPAXI@Z ; Exception::HardwareDeficiency::`vftable'
CONST	ENDS
;	COMDAT __TI3?AVHardwareDeficiency@Exception@@
xdata$x	SEGMENT
__TI3?AVHardwareDeficiency@Exception@@ DD 00H
	DD	FLAT:??1HardwareDeficiency@Exception@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVHardwareDeficiency@Exception@@
xdata$x	ENDS
;	COMDAT ??_R0?AVHardwareDeficiency@Exception@@@8
data$r	SEGMENT
??_R0?AVHardwareDeficiency@Exception@@@8 DD FLAT:??_7type_info@@6B@ ; Exception::HardwareDeficiency `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVHardwareDeficiency@Exception@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVHardwareDeficiency@Exception@@@8??0HardwareDeficiency@Exception@@QAE@ABV01@@Z28
xdata$x	SEGMENT
__CT??_R0?AVHardwareDeficiency@Exception@@@8??0HardwareDeficiency@Exception@@QAE@ABV01@@Z28 DD 00H
	DD	FLAT:??_R0?AVHardwareDeficiency@Exception@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	01cH
	DD	FLAT:??0HardwareDeficiency@Exception@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVHardwareDeficiency@Exception@@
xdata$x	SEGMENT
__CTA3?AVHardwareDeficiency@Exception@@ DD 03H
	DD	FLAT:__CT??_R0?AVHardwareDeficiency@Exception@@@8??0HardwareDeficiency@Exception@@QAE@ABV01@@Z28
	DD	FLAT:__CT??_R0?AVRuntimeError@Exception@@@8??0RuntimeError@Exception@@QAE@ABV01@@Z28
	DD	FLAT:__CT??_R0?AVBaseException@Exception@@@8??0BaseException@Exception@@QAE@ABV01@@Z28
xdata$x	ENDS
;	COMDAT ?s_bFlushReg@?1??recompileNextInstruction@@YAXH@Z@4EA
_DATA	SEGMENT
?s_bFlushReg@?1??recompileNextInstruction@@YAXH@Z@4EA DB 01H ; `recompileNextInstruction'::`2'::s_bFlushReg
_DATA	ENDS
;	COMDAT ??_C@_0BK@FEKONKNL@EE?5recompiler?5stack?5reset?$AA@
CONST	SEGMENT
??_C@_0BK@FEKONKNL@EE?5recompiler?5stack?5reset?$AA@ DB 'EE recompiler st'
	DB	'ack reset', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@KGMIHJML@EE?5Recompiler?5data?5reset?$AA@
CONST	SEGMENT
??_C@_0BJ@KGMIHJML@EE?5Recompiler?5data?5reset?$AA@ DB 'EE Recompiler dat'
	DB	'a reset', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@COAJMALJ@dyna_block_discard?5?$CF08X?5?0?5count?5@
CONST	SEGMENT
??_C@_0CD@COAJMALJ@dyna_block_discard?5?$CF08X?5?0?5count?5@ DB 'dyna_blo'
	DB	'ck_discard %08X , count %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08HNLAIHMJ@Bad?5esp?$CB?$AA@
CONST	SEGMENT
??_C@_08HNLAIHMJ@Bad?5esp?$CB?$AA@ DB 'Bad esp!', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BNOPKFMB@branch?5?$CFx?5in?5delay?5slot?$CB?$AA@
CONST	SEGMENT
??_C@_0BJ@BNOPKFMB@branch?5?$CFx?5in?5delay?5slot?$CB?$AA@ DB 'branch %x '
	DB	'in delay slot!', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HOCNDIGO@delay?5slot?5?$CFx?$AA@
CONST	SEGMENT
??_C@_0O@HOCNDIGO@delay?5slot?5?$CFx?$AA@ DB 'delay slot %x', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@HHKJLMIF@Pcsx2?5Foopah?$CB?5?5Frozen?5regs?5have?5@
CONST	SEGMENT
??_C@_0DF@HHKJLMIF@Pcsx2?5Foopah?$CB?5?5Frozen?5regs?5have?5@ DB 'Pcsx2 F'
	DB	'oopah!  Frozen regs have not been restored!!!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05OAHDOEDM@EERec?$AA@
CONST	SEGMENT
??_C@_05OAHDOEDM@EERec?$AA@ DB 'EERec', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@KMFNGPCI@R5900?932?5Init?5?$DO?5failed?5to?5alloca@
CONST	SEGMENT
??_C@_0DK@KMFNGPCI@R5900?932?5Init?5?$DO?5failed?5to?5alloca@ DB 'R5900-3'
	DB	'2 Init > failed to allocate memory for pInstCache.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@NGEJMDFP@R5900?932?5Init?5?$DO?5Failed?5to?5alloca@
CONST	SEGMENT
??_C@_0EA@NGEJMDFP@R5900?932?5Init?5?$DO?5Failed?5to?5alloca@ DB 'R5900-3'
	DB	'2 Init > Failed to allocate memory for BASEBLOCK tables.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@KMMEHCKA@R5900?932?5?$DO?5failed?5to?5allocate?5re@
CONST	SEGMENT
??_C@_0DB@KMMEHCKA@R5900?932?5?$DO?5failed?5to?5allocate?5re@ DB 'R5900-3'
	DB	'2 > failed to allocate recompiler memory.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GOFBLDMA@recAlloc?$CIR5900?$CJ?$AA@
CONST	SEGMENT
??_C@_0BA@GOFBLDMA@recAlloc?$CIR5900?$CJ?$AA@ DB 'recAlloc(R5900)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@CODMKFCE@Processor?5doesn?8t?5support?5SSE2?$AA@
CONST	SEGMENT
??_C@_0BP@CODMKFCE@Processor?5doesn?8t?5support?5SSE2?$AA@ DB 'Processor '
	DB	'doesn''t support SSE2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@EAHPPEPN@Processor?5doesn?8t?5support?5SSE?$AA@
CONST	SEGMENT
??_C@_0BO@EAHPPEPN@Processor?5doesn?8t?5support?5SSE?$AA@ DB 'Processor d'
	DB	'oesn''t support SSE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@BJGNDGDH@Processor?5doesn?8t?5support?5MMX?$AA@
CONST	SEGMENT
??_C@_0BO@BJGNDGDH@Processor?5doesn?8t?5support?5MMX?$AA@ DB 'Processor d'
	DB	'oesn''t support MMX', 00H			; `string'
	ORG $+3036
?recCpu@@3UR5900cpu@@A DD FLAT:?recAlloc@@YAXXZ		; recCpu
	DD	FLAT:?recResetEE@@YAXXZ
	DD	FLAT:?recStep@@YAXXZ
	DD	FLAT:?recExecute@@YAXXZ
	DD	FLAT:?recExecuteBlock@@YAXXZ
	DD	FLAT:?recClear@@YAXII@Z
	DD	FLAT:?recShutdown@@YAXXZ
_DATA	ENDS
PUBLIC	??$max@I@std@@YAABIABI0@Z			; std::max<unsigned int>
PUBLIC	?recRecompile@@YAXI@Z				; recRecompile
PUBLIC	?eeScaleBlockCycles@@YAIXZ			; eeScaleBlockCycles
PUBLIC	?SetBranchReg@@YAXI@Z				; SetBranchReg
PUBLIC	?CheckForBIOSEnd@@YAXXZ				; CheckForBIOSEnd
PUBLIC	?REC_CLEARM@@YAXI@Z				; REC_CLEARM
PUBLIC	?recClearMem@@YAXPAUBASEBLOCK@@@Z		; recClearMem
PUBLIC	?recClear@@YAXII@Z				; recClear
PUBLIC	?recStep@@YAXXZ					; recStep
PUBLIC	?recResetEE@@YAXXZ				; recResetEE
PUBLIC	??0HardwareDeficiency@Exception@@QAE@ABV01@@Z	; Exception::HardwareDeficiency::HardwareDeficiency
PUBLIC	?recAllocStackMem@@YAPAIHH@Z			; recAllocStackMem
PUBLIC	?_flushMMXunused@@YAHXZ				; _flushMMXunused
PUBLIC	?_flushXMMunused@@YAHXZ				; _flushXMMunused
PUBLIC	?_eeGetConstReg@@YAPAIH@Z			; _eeGetConstReg
PUBLIC	?PC_GETBLOCKEX@@YAPAUBASEBLOCKEX@@PAUBASEBLOCK@@@Z ; PC_GETBLOCKEX
PUBLIC	?SetFnptr@BASEBLOCK@@QAEXI@Z			; BASEBLOCK::SetFnptr
PUBLIC	?GetFnptr@BASEBLOCK@@QBE?BIXZ			; BASEBLOCK::GetFnptr
PUBLIC	??1HardwareDeficiency@Exception@@UAE@XZ		; Exception::HardwareDeficiency::~HardwareDeficiency
PUBLIC	??_GHardwareDeficiency@Exception@@UAEPAXI@Z	; Exception::HardwareDeficiency::`scalar deleting destructor'
PUBLIC	??0HardwareDeficiency@Exception@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Exception::HardwareDeficiency::HardwareDeficiency
PUBLIC	?_eeMoveGPRtoRm@@YAXHH@Z			; _eeMoveGPRtoRm
PUBLIC	?SaveBranchState@@YAXXZ				; SaveBranchState
PUBLIC	?recompileNextInstruction@@YAXH@Z		; recompileNextInstruction
PUBLIC	?SetBranchImm@@YAXI@Z				; SetBranchImm
PUBLIC	?LoadBranchState@@YAXXZ				; LoadBranchState
PUBLIC	?_eeMoveGPRtoR@@YAXHH@Z				; _eeMoveGPRtoR
PUBLIC	?_eeFlushAllUnused@@YAXXZ			; _eeFlushAllUnused
PUBLIC	?iFlushCall@@YAXH@Z				; iFlushCall
PUBLIC	?_eeMoveGPRtoM@@YAXIH@Z				; _eeMoveGPRtoM
PUBLIC	?recSYSCALL@OpcodeImpl@Dynarec@R5900@@YAXXZ	; R5900::Dynarec::OpcodeImpl::recSYSCALL
PUBLIC	?recBREAK@OpcodeImpl@Dynarec@R5900@@YAXXZ	; R5900::Dynarec::OpcodeImpl::recBREAK
PUBLIC	?recExecute@@YAXXZ				; recExecute
EXTRN	??_EHardwareDeficiency@Exception@@UAEPAXI@Z:PROC ; Exception::HardwareDeficiency::`vector deleting destructor'
_s_savex86FpuState DW 01H DUP (?)
	ALIGN	4

_s_saveiCWstate DW 01H DUP (?)
	ALIGN	4

_s_pCode DD	01H DUP (?)
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0HardwareDeficiency@Exception@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0HardwareDeficiency@Exception@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??0HardwareDeficiency@Exception@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0HardwareDeficiency@Exception@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0HardwareDeficiency@Exception@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0HardwareDeficiency@Exception@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_GHardwareDeficiency@Exception@@UAEPAXI@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??_GHardwareDeficiency@Exception@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??_GHardwareDeficiency@Exception@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_GHardwareDeficiency@Exception@@UAEPAXI@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??_GHardwareDeficiency@Exception@@UAEPAXI@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??_GHardwareDeficiency@Exception@@UAEPAXI@Z$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1HardwareDeficiency@Exception@@UAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??1HardwareDeficiency@Exception@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??1HardwareDeficiency@Exception@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1HardwareDeficiency@Exception@@UAE@XZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1HardwareDeficiency@Exception@@UAE@XZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1HardwareDeficiency@Exception@@UAE@XZ$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0HardwareDeficiency@Exception@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0HardwareDeficiency@Exception@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??0HardwareDeficiency@Exception@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0HardwareDeficiency@Exception@@QAE@ABV01@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0HardwareDeficiency@Exception@@QAE@ABV01@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0HardwareDeficiency@Exception@@QAE@ABV01@@Z$0
	ORG $+6056
__ehfuncinfo$?recAlloc@@YAXXZ DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$?recAlloc@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
	ORG $+36
__unwindtable$?recAlloc@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?recAlloc@@YAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?recAlloc@@YAXXZ$8
	DD	00H
	DD	FLAT:__unwindfunclet$?recAlloc@@YAXXZ$7
	DD	00H
	DD	FLAT:__unwindfunclet$?recAlloc@@YAXXZ$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?recAlloc@@YAXXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?recAlloc@@YAXXZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?recAlloc@@YAXXZ$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?recAlloc@@YAXXZ$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?recAlloc@@YAXXZ$5
; Function compile flags: /Ogtp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\windows\winconsole.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\iopcounters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\windows\winthreads.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vumicromem.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vumicromem.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\iopcounters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\misc.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\misc.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\misc.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\gs.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\gs.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\windows\winthreads.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\misc.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\iopcounters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vifdma.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vifdma.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vifdma.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vifdma.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vifdma.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vifdma.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vifdma.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\gif.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\gif.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\gif.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\sif.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\sif.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\sif.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\ipu\ipu.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\ipu\ipu.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\ipu\ipu.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\spr.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
;	COMDAT ?recExecute@@YAXXZ
_TEXT	SEGMENT
_count$1 = -96						; size = 8
_count$2 = -88						; size = 8
_result$3 = -76						; size = 4
_tmp$4 = -72						; size = 4
_tmp$5 = -68						; size = 4
_sDeltaTime$6 = -64					; size = 8
_uExpectedEnd$1$ = -60					; size = 4
tv3181 = -60						; size = 4
_sDeltaTime$1$ = -52					; size = 4
?cpuRegs@@3UcpuRegisters@@A$7 = -48			; size = 4
tv3167 = -48						; size = 4
_i$1$ = -48						; size = 4
_sDeltaTime$2$ = -32					; size = 4
?cpuRegs@@3UcpuRegisters@@A$1 = -32			; size = 4
_vsyncEvent$1$ = -1					; size = 1
?recExecute@@YAXXZ PROC					; recExecute, COMDAT

; 774  : {

	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -16				; fffffff0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	ebx
	push	esi
	push	edi
	npad	4
$LL3@recExecute:

; 775  : 	// Optimization note : Compared pushad against manually pushing the regs one-by-one.
; 776  : 	// Manually pushing is faster, especially on Core2's and such. :)
; 777  : 	do {
; 778  : 		g_EEFreezeRegs = true;

	mov	BYTE PTR ?g_EEFreezeRegs@@3_NA, 1	; g_EEFreezeRegs

; 779  : 		__asm
; 780  : 		{
; 781  : 			push ebx

	push	ebx

; 782  : 			push esi

	push	esi

; 783  : 			push edi

	push	edi

; 784  : 			push ebp

	push	ebp

; 785  : 
; 786  : 			call DispatcherReg

	call	?DispatcherReg@@YAXXZ			; DispatcherReg

; 787  : 			
; 788  : 			pop ebp

	pop	ebp

; 789  : 			pop edi

	pop	edi

; 790  : 			pop esi

	pop	esi

; 791  : 			pop ebx

	pop	ebx

; 642  :     if( g_globalXMMSaved || g_globalMMXSaved)

	cmp	BYTE PTR ?g_globalXMMSaved@@3EA, 0	; g_globalXMMSaved

; 792  : 		}
; 793  : 		g_EEFreezeRegs = false;

	mov	BYTE PTR ?g_EEFreezeRegs@@3_NA, 0	; g_EEFreezeRegs

; 642  :     if( g_globalXMMSaved || g_globalMMXSaved)

	jne	SHORT $LN6@recExecute
	cmp	BYTE PTR ?g_globalMMXSaved@@3EA, 0	; g_globalMMXSaved
	je	$LN24@recExecute
$LN6@recExecute:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\windows\winconsole.cpp

; 77   : 		SetConsoleTextAttribute( hConsole, tbl_color_codes[color] );

	mov	esi, DWORD PTR __imp__SetConsoleTextAttribute@8
	push	12					; 0000000cH
	push	DWORD PTR _hConsole
	call	esi

; 100  : 		}
; 101  : 
; 102  : 		return false;
; 103  : 	}
; 104  : 
; 105  : 	// Writes an unformatted string of text to the console (fast!)
; 106  : 	// No newline is appended.
; 107  : 	__forceinline bool __fastcall Write( const char* fmt )
; 108  : 	{
; 109  : 		if (hConsole != NULL)

	mov	eax, DWORD PTR _hConsole
	test	eax, eax
	je	SHORT $LN19@recExecute

; 110  : 		{
; 111  : 			DWORD tmp;
; 112  : 			WriteConsole(hConsole, fmt, (DWORD)strlen(fmt), &tmp, 0);

	push	0
	lea	ecx, DWORD PTR _tmp$5[ebp]
	push	ecx
	push	52					; 00000034H
	push	OFFSET ??_C@_0DF@HHKJLMIF@Pcsx2?5Foopah?$CB?5?5Frozen?5regs?5have?5@
	push	eax
	call	DWORD PTR __imp__WriteConsoleA@20
	mov	eax, DWORD PTR _hConsole
$LN19@recExecute:

; 113  : 		}
; 114  : 
; 115  : 		// No flushing here -- only flush after newlines.
; 116  : 		if (emuLog != NULL)

	mov	ecx, DWORD PTR ?emuLog@@3PAU_iobuf@@A	; emuLog

; 117  : 			fputs(fmt, emuLog);

	mov	edi, DWORD PTR __imp__fputs
	test	ecx, ecx
	je	SHORT $LN18@recExecute
	push	ecx
	push	OFFSET ??_C@_0DF@HHKJLMIF@Pcsx2?5Foopah?$CB?5?5Frozen?5regs?5have?5@
	call	edi
	mov	eax, DWORD PTR _hConsole
	add	esp, 8
$LN18@recExecute:

; 78   : 	}
; 79   : 
; 80   : 	__forceinline void ClearColor()
; 81   : 	{
; 82   : 		SetConsoleTextAttribute( hConsole,
; 83   : 			FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE );

	push	7
	push	eax
	call	esi

; 84   : 	}
; 85   : 
; 86   : 
; 87   : 	// Writes a newline to the console.
; 88   : 	__forceinline bool __fastcall Newline()
; 89   : 	{
; 90   : 		if (hConsole != NULL)

	mov	eax, DWORD PTR _hConsole
	test	eax, eax
	je	SHORT $LN25@recExecute

; 91   : 		{
; 92   : 			DWORD tmp;
; 93   : 			WriteConsole(hConsole, "\r\n", 2, &tmp, 0);

	push	0
	lea	ecx, DWORD PTR _tmp$4[ebp]
	push	ecx
	push	2
	push	OFFSET ??_C@_02PCIJFNDE@?$AN?6?$AA@
	push	eax
	call	DWORD PTR __imp__WriteConsoleA@20
$LN25@recExecute:

; 94   : 		}
; 95   : 
; 96   : 		if (emuLog != NULL)

	mov	eax, DWORD PTR ?emuLog@@3PAU_iobuf@@A	; emuLog
	test	eax, eax
	je	SHORT $LN24@recExecute

; 97   : 		{
; 98   : 			fputs("\n", emuLog);

	push	eax
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	edi

; 99   : 			fflush( emuLog );

	push	DWORD PTR ?emuLog@@3PAU_iobuf@@A	; emuLog
	call	DWORD PTR __imp__fflush
	add	esp, 12					; 0000000cH
$LN24@recExecute:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 443  : 	g_nextBranchCycle = cpuRegs.cycle + eeWaitCycles;

	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960

; 447  : 
; 448  : 	if( EEsCycle > 0 )

	mov	edi, 1
	mov	eax, DWORD PTR _eeWaitCycles
	mov	ecx, DWORD PTR ?EEsCycle@@3HA		; EEsCycle
	add	eax, edx
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
	mov	eax, edx
	sub	eax, DWORD PTR ?EEoCycle@@3IA		; EEoCycle
	add	ecx, eax
	mov	BYTE PTR ?eeEventTestIsActive@@3_NA, 1	; eeEventTestIsActive
	movzx	eax, BYTE PTR ?iopBranchAction@@3_NA	; iopBranchAction
	test	ecx, ecx
	mov	DWORD PTR ?EEsCycle@@3HA, ecx		; EEsCycle

; 332  : 	return (int)(cpuRegs.cycle - startCycle) >= delta;

	mov	ecx, DWORD PTR ?counters@@3PAUCounter@@A+188

; 447  : 
; 448  : 	if( EEsCycle > 0 )

	cmovg	eax, edi
	mov	BYTE PTR ?iopBranchAction@@3_NA, al	; iopBranchAction

; 332  : 	return (int)(cpuRegs.cycle - startCycle) >= delta;

	mov	eax, edx
	sub	eax, ecx

; 443  : 	g_nextBranchCycle = cpuRegs.cycle + eeWaitCycles;

	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A$1[ebp], edx

; 444  : 
; 445  : 	EEsCycle += cpuRegs.cycle - EEoCycle;
; 446  : 	EEoCycle = cpuRegs.cycle;

	mov	DWORD PTR ?EEoCycle@@3IA, edx		; EEoCycle

; 449  : 		iopBranchAction = true;
; 450  : 
; 451  : 	// ---- Counters -------------
; 452  : 	bool vsyncEvent = false;

	mov	BYTE PTR _vsyncEvent$1$[ebp], 0

; 332  : 	return (int)(cpuRegs.cycle - startCycle) >= delta;

	cmp	eax, DWORD PTR ?counters@@3PAUCounter@@A+192
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp

; 471  : 	if( !cpuTestCycle( counters[4].sCycle, counters[4].CycleT ) ) return;

	jl	$LN480@recExecute

; 472  : 
; 473  : 	//iopBranchAction = 1;
; 474  : 	if (counters[4].modeval & MODE_HBLANK) { //HBLANK Start

	test	BYTE PTR ?counters@@3PAUCounter@@A+164, 1
	je	SHORT $LN43@recExecute

; 475  : 		rcntStartGate(false, counters[4].sCycle);

	mov	edx, ecx
	xor	cl, cl
	call	?rcntStartGate@@YIX_NI@Z		; rcntStartGate

; 476  : 		psxCheckStartGate16(0);

	xor	ecx, ecx
	call	?psxCheckStartGate16@@YAXH@Z		; psxCheckStartGate16

; 477  : 		
; 478  : 		// Setup the hRender's start and end cycle information:
; 479  : 		counters[4].sCycle += vSyncInfo.hBlank;		// start  (absolute cycle value)

	mov	eax, DWORD PTR _vSyncInfo+20
	add	DWORD PTR ?counters@@3PAUCounter@@A+188, eax

; 480  : 		counters[4].CycleT = vSyncInfo.hRender;		// endpoint (delta from start value)
; 481  : 		counters[4].modeval = MODE_HRENDER;
; 482  : 	}
; 483  : 	else { //HBLANK END / HRENDER Begin

	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	eax, DWORD PTR _vSyncInfo+16
	mov	DWORD PTR ?counters@@3PAUCounter@@A+164, 0
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A$1[ebp], edx
	jmp	$LN506@recExecute
$LN43@recExecute:

; 484  : 		if (CSRw & 0x4) GSCSRr |= 4; // signal

	test	BYTE PTR ?CSRw@@3IA, 4
	je	SHORT $LN41@recExecute
	mov	eax, DWORD PTR ?g_RealGSMem@@3PAEA+4100
	or	DWORD PTR ?g_RealGSMem@@3PAEA+4096, 4
	mov	DWORD PTR ?g_RealGSMem@@3PAEA+4100, eax
$LN41@recExecute:

; 485  : 		if (!(GSIMR&0x400)) gsIrq();

	test	DWORD PTR ?g_RealGSMem@@3PAEA+4112, 1024 ; 00000400H
	jne	SHORT $LN51@recExecute
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp

; 109  : 	psHu32(INTC_STAT)|= 1<<n;

	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
	or	DWORD PTR [eax+61440], edi

; 110  : 	cpuTestINTCInts();

	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	ecx, DWORD PTR ?counters@@3PAUCounter@@A+188
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A$1[ebp], edx
$LN51@recExecute:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp

; 486  : 		if (gates) rcntEndGate(false, counters[4].sCycle);

	cmp	DWORD PTR ?gates@@3HA, 0		; gates
	je	SHORT $LN39@recExecute
	mov	edx, ecx
	xor	cl, cl
	call	?rcntEndGate@@YIX_NI@Z			; rcntEndGate
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	ecx, DWORD PTR ?counters@@3PAUCounter@@A+188
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A$1[ebp], edx
$LN39@recExecute:

; 487  : 		if (psxhblankgate) psxCheckEndGate16(0);

	cmp	BYTE PTR ?psxhblankgate@@3EA, 0		; psxhblankgate
	je	SHORT $LN53@recExecute
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\iopcounters.cpp

; 330  : 	_psxCheckEndGate( i );

	xor	ecx, ecx
	call	?_psxCheckEndGate@@YAXH@Z		; _psxCheckEndGate
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	ecx, DWORD PTR ?counters@@3PAUCounter@@A+188
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A$1[ebp], edx
$LN53@recExecute:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp

; 490  : 		counters[4].sCycle += vSyncInfo.hRender;	// start (absolute cycle value)

	add	ecx, DWORD PTR _vSyncInfo+16

; 491  : 		counters[4].CycleT = vSyncInfo.hBlank;		// endpoint (delta from start value)

	mov	eax, DWORD PTR _vSyncInfo+20
	mov	DWORD PTR ?counters@@3PAUCounter@@A+188, ecx

; 492  : 		counters[4].modeval = MODE_HBLANK;

	mov	DWORD PTR ?counters@@3PAUCounter@@A+164, edi
$LN506@recExecute:

; 491  : 		counters[4].CycleT = vSyncInfo.hBlank;		// endpoint (delta from start value)

	mov	DWORD PTR ?counters@@3PAUCounter@@A+192, eax
$LN480@recExecute:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 332  : 	return (int)(cpuRegs.cycle - startCycle) >= delta;

	mov	eax, edx
	sub	eax, DWORD PTR ?nextsCounter@@3IA	; nextsCounter
	cmp	eax, DWORD PTR ?nextCounter@@3HA	; nextCounter

; 453  : 	rcntUpdate_hScanline();
; 454  : 
; 455  : 	if( cpuTestCycle( nextsCounter, nextCounter ) )

	jl	$LN482@recExecute
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp

; 502  : 	s32 diff = (cpuRegs.cycle - counters[5].sCycle);

	mov	esi, DWORD PTR ?counters@@3PAUCounter@@A+228
	mov	eax, edx
	sub	eax, esi

; 503  : 	if( diff < counters[5].CycleT ) return false;

	cmp	eax, DWORD PTR ?counters@@3PAUCounter@@A+232
	jl	$LN507@recExecute

; 504  : 
; 505  : 	//iopBranchAction = 1;
; 506  : 	if (counters[5].modeval == MODE_VSYNC)

	cmp	DWORD PTR ?counters@@3PAUCounter@@A+204, 3
	jne	$LN67@recExecute

; 414  : 
; 415  : 	// INTC - VB Blank Start Hack --
; 416  : 	// Hack fix!  This corrects a freezeup in Granda 2 where it decides to spin
; 417  : 	// on the INTC_STAT register after the exception handler has already cleared
; 418  : 	// it.  But be warned!  Set the value to larger than 4 and it breaks Dark
; 419  : 	// Cloud and other games. -_-
; 420  : 
; 421  : 	// How it works: Normally the INTC raises exceptions immediately at the end of the
; 422  : 	// current branch test.  But in the case of Grandia 2, the game's code is spinning
; 423  : 	// on the INTC status, and the exception handler (for some reason?) clears the INTC
; 424  : 	// before returning *and* returns to a location other than EPC.  So the game never
; 425  : 	// gets to the point where it sees the INTC Irq set true.
; 426  : 
; 427  : 	// (I haven't investigated why Dark Cloud freezes on larger values)
; 428  : 	// (all testing done using the recompiler -- dunno how the ints respond yet)
; 429  : 
; 430  : 	//cpuRegs.eCycle[30] = 2;
; 431  : 
; 432  : 	// Should no longer be required (Refraction)
; 433  : }
; 434  : 
; 435  : static __forceinline void VSyncEnd(u32 sCycle)
; 436  : {
; 437  : 	EECNT_LOG( "/////////  EE COUNTER VSYNC END  \\\\\\\\\\\\\\\\\\\\  (frame: %d)\n", iFrame );

	test	DWORD PTR ?varLog@@3IA, 1073741824	; varLog, 40000000H
	je	SHORT $LN76@recExecute
	push	DWORD PTR _iFrame
	push	OFFSET ??_C@_0DK@GPMLIACH@?1?1?1?1?1?1?1?1?1?5?5EE?5COUNTER?5VSYNC?5END?5@
	call	?SrcLog_EECNT@@YA_NPBDZZ		; SrcLog_EECNT
	add	esp, 8
$LN76@recExecute:

; 438  : 
; 439  : 	iFrame++;

	inc	DWORD PTR _iFrame

; 440  : 
; 441  : 	if( g_vu1SkipCount > 0 )

	cmp	DWORD PTR ?g_vu1SkipCount@@3IA, 0	; g_vu1SkipCount
	jbe	SHORT $LN73@recExecute

; 442  : 	{
; 443  : 		gsPostVsyncEnd( false );

	xor	cl, cl
	call	?gsPostVsyncEnd@@YAX_N@Z		; gsPostVsyncEnd
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\windows\winthreads.cpp

; 119  : 				mov          ecx,dword ptr [target]

	mov	ecx, OFFSET ?g_vu1SkipCount@@3IA	; g_vu1SkipCount

; 120  : 				mov          eax,dword ptr [srcval]

	mov	eax, -1

; 121  : 				lock xadd    dword ptr [ecx],eax

	lock	 xadd	 DWORD PTR [ecx], eax

; 122  : 				mov          dword ptr [result], eax

	mov	DWORD PTR _result$3[ebp], eax
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vumicromem.cpp

; 43   : 	CpuVU1.ExecuteBlock = DummyExecuteVU1Block;

	mov	DWORD PTR ?CpuVU1@@3UVUmicroCpu@@A+8, OFFSET ?DummyExecuteVU1Block@@YAXXZ ; DummyExecuteVU1Block
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp

; 447  : 	else

	jmp	SHORT $LN88@recExecute
$LN73@recExecute:

; 448  : 	{
; 449  : 		gsPostVsyncEnd( true );

	mov	cl, 1
	call	?gsPostVsyncEnd@@YAX_N@Z		; gsPostVsyncEnd
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vumicromem.cpp

; 48   : 	CpuVU1.ExecuteBlock = CHECK_VU1REC ? recVU1.ExecuteBlock : intVU1.ExecuteBlock;

	test	BYTE PTR ?g_Session@@3USessionOverrideFlags@@A, 4 ; g_Session
	jne	SHORT $LN87@recExecute
	test	BYTE PTR ?Config@@3UPcsxConfig@@A+3576, 64 ; 00000040H
	mov	eax, DWORD PTR ?recVU1@@3UVUmicroCpu@@B+8
	jne	SHORT $LN508@recExecute
$LN87@recExecute:
	mov	eax, DWORD PTR ?intVU1@@3UVUmicroCpu@@B+8
$LN508@recExecute:
	mov	DWORD PTR ?CpuVU1@@3UVUmicroCpu@@A+8, eax
$LN88@recExecute:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp

; 109  : 	psHu32(INTC_STAT)|= 1<<n;

	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
	or	DWORD PTR [eax+61440], 8

; 110  : 	cpuTestINTCInts();

	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\iopcounters.cpp

; 357  : 	psxHu32(0x1070) |= 0x800;

	mov	eax, DWORD PTR ?psxH@@3PAEA		; psxH
	or	DWORD PTR [eax+4208], 2048		; 00000800H

; 358  : 	if(psxvblankgate & (1 << 1)) psxCheckEndGate16(1);

	mov	al, BYTE PTR ?psxvblankgate@@3EA	; psxvblankgate
	test	al, 2
	je	SHORT $LN95@recExecute

; 330  : 	_psxCheckEndGate( i );

	mov	ecx, edi
	call	?_psxCheckEndGate@@YAXH@Z		; _psxCheckEndGate
	mov	al, BYTE PTR ?psxvblankgate@@3EA	; psxvblankgate
$LN95@recExecute:

; 359  : 	if(psxvblankgate & (1 << 3)) psxCheckEndGate32(3);

	test	al, 8
	je	SHORT $LN97@recExecute

; 338  : }
; 339  : 
; 340  : static void psxCheckEndGate32(int i)
; 341  : {
; 342  : 	assert(i == 3);
; 343  : 	_psxCheckEndGate( i );

	mov	ecx, 3
	call	?_psxCheckEndGate@@YAXH@Z		; _psxCheckEndGate
$LN97@recExecute:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp

; 455  : 	if (gates) rcntEndGate(true, sCycle); // Counters End Gate Code

	cmp	DWORD PTR ?gates@@3HA, 0		; gates
	je	SHORT $LN71@recExecute
	mov	edx, esi
	mov	cl, 1
	call	?rcntEndGate@@YIX_NI@Z			; rcntEndGate
$LN71@recExecute:

; 111  : }
; 112  : 
; 113  : void rcntInit() {
; 114  : 	int i;
; 115  : 
; 116  : 	memzero_obj(counters);
; 117  : 
; 118  : 	for (i=0; i<4; i++) {
; 119  : 		counters[i].rate = 2;
; 120  : 		counters[i].target = 0xffff;
; 121  : 	}
; 122  : 	counters[0].interrupt =  9;
; 123  : 	counters[1].interrupt = 10;
; 124  : 	counters[2].interrupt = 11;
; 125  : 	counters[3].interrupt = 12;
; 126  : 
; 127  : 	counters[4].modeval = MODE_HRENDER;
; 128  : 	counters[4].sCycle = cpuRegs.cycle;
; 129  : 	counters[5].modeval = MODE_VRENDER; 
; 130  : 	counters[5].sCycle = cpuRegs.cycle;
; 131  : 
; 132  : 	UpdateVSyncRate();
; 133  : 
; 134  : 	for (i=0; i<4; i++) rcntReset(i);
; 135  : 	cpuRcntSet();
; 136  : }
; 137  : 
; 138  : // debug code, used for stats
; 139  : int g_nCounters[4];
; 140  : static int iFrame = 0;	
; 141  : 
; 142  : #ifndef _WIN32
; 143  : #include <sys/time.h>
; 144  : #endif
; 145  : 
; 146  : static s64 m_iTicks=0;
; 147  : static u64 m_iStart=0;
; 148  : 
; 149  : struct vSyncTimingInfo
; 150  : {
; 151  : 	u32 Framerate;			// frames per second * 100 (so 2500 for PAL and 2997 for NTSC)
; 152  : 	u32 Render;				// time from vblank end to vblank start (cycles)
; 153  : 	u32 Blank;				// time from vblank start to vblank end (cycles)
; 154  : 
; 155  : 	u32 hSyncError;			// rounding error after the duration of a rendered frame (cycles)
; 156  : 	u32 hRender;			// time from hblank end to hblank start (cycles)
; 157  : 	u32 hBlank;				// time from hblank start to hblank end (cycles)
; 158  : 	u32 hScanlinesPerFrame;	// number of scanlines per frame (525/625 for NTSC/PAL)
; 159  : };
; 160  : 
; 161  : 
; 162  : static vSyncTimingInfo vSyncInfo;
; 163  : 
; 164  : 
; 165  : static __forceinline void vSyncInfoCalc( vSyncTimingInfo* info, u32 framesPerSecond, u32 scansPerFrame )
; 166  : {
; 167  : 	// Important: Cannot use floats or doubles here.  The emulator changes rounding modes
; 168  : 	// depending on user-set speedhack options, and it can break float/double code
; 169  : 	// (as in returning infinities and junk)
; 170  : 
; 171  : 	// NOTE: mgs3 likes a /4 vsync, but many games prefer /2.  This seems to indicate a
; 172  : 	// problem in the counters vsync gates somewhere.
; 173  : 
; 174  : 	u64 Frame = ((u64)PS2CLK * 1000000ULL) / framesPerSecond;
; 175  : 	u64 HalfFrame = Frame / 2;
; 176  : 	u64 Blank = HalfFrame / 2;		// two blanks and renders per frame
; 177  : 	u64 Render = HalfFrame - Blank;	// so use the half-frame value for these...
; 178  : 
; 179  : 	// Important!  The hRender/hBlank timers should be 50/50 for best results.
; 180  : 	// In theory a 70%/30% ratio would be more correct but in practice it runs
; 181  : 	// like crap and totally screws audio synchronization and other things.
; 182  : 	
; 183  : 	u64 Scanline = Frame / scansPerFrame;
; 184  : 	u64 hBlank = Scanline / 2;
; 185  : 	u64 hRender = Scanline - hBlank;
; 186  : 	
; 187  : 	info->Framerate = framesPerSecond;
; 188  : 	info->Render = (u32)(Render/10000);
; 189  : 	info->Blank  = (u32)(Blank/10000);
; 190  : 
; 191  : 	info->hRender = (u32)(hRender/10000);
; 192  : 	info->hBlank  = (u32)(hBlank/10000);
; 193  : 	info->hScanlinesPerFrame = scansPerFrame;
; 194  : 	
; 195  : 	// Apply rounding:
; 196  : 	if( ( Render - info->Render ) >= 5000 ) info->Render++;
; 197  : 	else if( ( Blank - info->Blank ) >= 5000 ) info->Blank++;
; 198  : 
; 199  : 	if( ( hRender - info->hRender ) >= 5000 ) info->hRender++;
; 200  : 	else if( ( hBlank - info->hBlank ) >= 5000 ) info->hBlank++;
; 201  : 	
; 202  : 	// Calculate accumulative hSync rounding error per half-frame:
; 203  : 	{
; 204  : 	u32 hSyncCycles = ((info->hRender + info->hBlank) * scansPerFrame) / 2;
; 205  : 	u32 vSyncCycles = (info->Render + info->Blank);
; 206  : 	info->hSyncError = vSyncCycles - hSyncCycles;
; 207  : 	}
; 208  : 
; 209  : 	// Note: In NTSC modes there is some small rounding error in the vsync too,
; 210  : 	// however it would take thousands of frames for it to amount to anything and
; 211  : 	// is thus not worth the effort at this time.
; 212  : }
; 213  : 
; 214  : 
; 215  : u32 UpdateVSyncRate()
; 216  : {
; 217  : 	const char *limiterMsg = "Framelimiter rate updated (UpdateVSyncRate): %d.%d fps";
; 218  : 
; 219  : 	// fixme - According to some docs, progressive-scan modes actually refresh slower than
; 220  : 	// interlaced modes.  But I can't fathom how, since the refresh rate is a function of
; 221  : 	// the television and all the docs I found on TVs made no indication that they ever
; 222  : 	// run anything except their native refresh rate.
; 223  : 
; 224  : 	//#define VBLANK_NTSC			((Config.PsxType & 2) ? 59.94 : 59.82) //59.94 is more precise
; 225  : 	//#define VBLANK_PAL			((Config.PsxType & 2) ? 50.00 : 49.76)
; 226  : 
; 227  : 	if(Config.PsxType & 1)
; 228  : 	{
; 229  : 		if( vSyncInfo.Framerate != FRAMERATE_PAL )
; 230  : 			vSyncInfoCalc( &vSyncInfo, FRAMERATE_PAL, SCANLINES_TOTAL_PAL );
; 231  : 	}
; 232  : 	else
; 233  : 	{
; 234  : 		if( vSyncInfo.Framerate != FRAMERATE_NTSC )
; 235  : 			vSyncInfoCalc( &vSyncInfo, FRAMERATE_NTSC, SCANLINES_TOTAL_NTSC );
; 236  : 	}
; 237  : 
; 238  : 	counters[4].CycleT = vSyncInfo.hRender; // Amount of cycles before the counter will be updated
; 239  : 	counters[5].CycleT = vSyncInfo.Render; // Amount of cycles before the counter will be updated
; 240  : 
; 241  : 	if (Config.CustomFps > 0)
; 242  : 	{
; 243  : 		s64 ticks = GetTickFrequency() / Config.CustomFps;
; 244  : 		if( m_iTicks != ticks )
; 245  : 		{
; 246  : 			m_iTicks = ticks;
; 247  : 			gsOnModeChanged( vSyncInfo.Framerate, m_iTicks );
; 248  : 			Console::Status( limiterMsg, params Config.CustomFps, 0 );
; 249  : 		}
; 250  : 	}
; 251  : 	else
; 252  : 	{
; 253  : 		s64 ticks = (GetTickFrequency() * 50) / vSyncInfo.Framerate;
; 254  : 		if( m_iTicks != ticks )
; 255  : 		{
; 256  : 			m_iTicks = ticks;
; 257  : 			gsOnModeChanged( vSyncInfo.Framerate, m_iTicks );
; 258  : 			Console::Status( limiterMsg, params vSyncInfo.Framerate/50, (vSyncInfo.Framerate*2)%100 );
; 259  : 		}
; 260  : 	}
; 261  : 
; 262  : 	m_iStart = GetCPUTicks();
; 263  : 	cpuRcntSet();
; 264  : 
; 265  : 	// Initialize VU Skip Stuff...
; 266  : 	g_vu1SkipCount = 0;
; 267  : 
; 268  : 	return (u32)m_iTicks;
; 269  : }
; 270  : 
; 271  : extern u32 vu0time;
; 272  : 
; 273  : 
; 274  : void vSyncDebugStuff() {
; 275  : 
; 276  : #ifdef PCSX2_DEVBUILD
; 277  : 		if( g_TestRun.enabled && g_TestRun.frame > 0 ) {
; 278  : 			if( iFrame > g_TestRun.frame ) {
; 279  : 				// take a snapshot
; 280  : 				if( g_TestRun.pimagename != NULL && GSmakeSnapshot2 != NULL ) {
; 281  : 					if( g_TestRun.snapdone ) {
; 282  : 						g_TestRun.curimage++;
; 283  : 						g_TestRun.snapdone = 0;
; 284  : 						g_TestRun.frame += 20;
; 285  : 						if( g_TestRun.curimage >= g_TestRun.numimages ) {
; 286  : 							// exit
; 287  : 							SysClose();
; 288  : 							exit(0);
; 289  : 						}
; 290  : 					}
; 291  : 					else {
; 292  : 						// query for the image
; 293  : 						GSmakeSnapshot2(g_TestRun.pimagename, &g_TestRun.snapdone, g_TestRun.jpgcapture);
; 294  : 					}
; 295  : 				}
; 296  : 				else {
; 297  : 					// exit
; 298  : 					SysClose();
; 299  : 					exit(0);
; 300  : 				}
; 301  : 			}
; 302  : 		}
; 303  : 
; 304  : 		GSVSYNC();
; 305  : 
; 306  : 		if( g_SaveGSStream == 1 ) {
; 307  : 			freezeData fP;
; 308  : 
; 309  : 			g_SaveGSStream = 2;
; 310  : 			g_fGSSave->gsFreeze();
; 311  : 			
; 312  : 			if (GSfreeze(FREEZE_SIZE, &fP) == -1) {
; 313  : 				safe_delete( g_fGSSave );
; 314  : 				g_SaveGSStream = 0;
; 315  : 			}
; 316  : 			else {
; 317  : 				fP.data = (s8*)malloc(fP.size);
; 318  : 				if (fP.data == NULL) {
; 319  : 					safe_delete( g_fGSSave );
; 320  : 					g_SaveGSStream = 0;
; 321  : 				}
; 322  : 				else {
; 323  : 					if (GSfreeze(FREEZE_SAVE, &fP) == -1) {
; 324  : 						safe_delete( g_fGSSave );
; 325  : 						g_SaveGSStream = 0;
; 326  : 					}
; 327  : 					else {
; 328  : 						g_fGSSave->Freeze( fP.size );
; 329  : 						if (fP.size) {
; 330  : 							g_fGSSave->FreezeMem( fP.data, fP.size );
; 331  : 							free(fP.data);
; 332  : 						}
; 333  : 					}
; 334  : 				}
; 335  : 			}
; 336  : 		}
; 337  : 		else if( g_SaveGSStream == 2 ) {
; 338  : 			
; 339  : 			if( --g_nLeftGSFrames <= 0 ) {
; 340  : 				safe_delete( g_fGSSave );
; 341  : 				g_SaveGSStream = 0;
; 342  : 				Console::WriteLn("Done saving GS stream");
; 343  : 			}
; 344  : 		}
; 345  : #endif
; 346  : }
; 347  : 
; 348  : void frameLimitReset()
; 349  : {
; 350  : 	m_iStart = GetCPUTicks();
; 351  : }
; 352  : 
; 353  : // Framelimiter - Measures the delta time between calls and stalls until a
; 354  : // certain amount of time passes if such time hasn't passed yet.
; 355  : // See the GS FrameSkip function for details on why this is here and not in the GS.
; 356  : static __forceinline void frameLimit()
; 357  : {
; 358  : 	s64 sDeltaTime;
; 359  : 	u64 uExpectedEnd;
; 360  : 	u64 iEnd;
; 361  : 
; 362  : 	if( CHECK_FRAMELIMIT == PCSX2_FRAMELIMIT_NORMAL ) return;

	test	DWORD PTR ?Config@@3UPcsxConfig@@A+3576, 3072 ; 00000c00H
	je	$LN481@recExecute

; 363  : 	if( Config.CustomFps >= 999 ) return;	// means the user would rather just have framelimiting turned off...

	cmp	DWORD PTR ?Config@@3UPcsxConfig@@A+3604, 999 ; 000003e7H
	jge	$LN481@recExecute

; 365  : 	uExpectedEnd = m_iStart + m_iTicks;

	mov	esi, DWORD PTR _m_iTicks
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\misc.cpp

; 825  :     QueryPerformanceCounter(&count);

	lea	eax, DWORD PTR _count$2[ebp]
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp

; 365  : 	uExpectedEnd = m_iStart + m_iTicks;

	add	esi, DWORD PTR _m_iStart
	mov	edi, DWORD PTR _m_iTicks+4
	adc	edi, DWORD PTR _m_iStart+4
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\misc.cpp

; 825  :     QueryPerformanceCounter(&count);

	push	eax
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp

; 365  : 	uExpectedEnd = m_iStart + m_iTicks;

	mov	DWORD PTR _uExpectedEnd$1$[ebp], esi
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\misc.cpp

; 825  :     QueryPerformanceCounter(&count);

	call	DWORD PTR __imp__QueryPerformanceCounter@4
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp

; 368  : 	sDeltaTime = iEnd - uExpectedEnd;

	mov	edx, DWORD PTR _count$2[ebp]
	mov	eax, edx
	mov	ecx, DWORD PTR _count$2[ebp+4]
	sub	eax, esi

; 369  : 
; 370  : 	// If the framerate drops too low, reset the expected value.  This avoids
; 371  : 	// excessive amounts of "fast forward" syndrome which would occur if we
; 372  : 	// tried to catch up too much.
; 373  : 	
; 374  : 	if( sDeltaTime > m_iTicks*8 )

	mov	esi, DWORD PTR _m_iTicks
	mov	DWORD PTR _sDeltaTime$2$[ebp], eax
	mov	eax, ecx
	sbb	eax, edi
	mov	DWORD PTR _sDeltaTime$1$[ebp], eax
	mov	eax, DWORD PTR _m_iTicks+4
	shld	eax, esi, 3
	shl	esi, 3
	mov	DWORD PTR tv3167[ebp], esi
	mov	esi, DWORD PTR _uExpectedEnd$1$[ebp]
	cmp	DWORD PTR _sDeltaTime$1$[ebp], eax
	jl	SHORT $LN504@recExecute
	jg	SHORT $LN474@recExecute
	mov	eax, DWORD PTR _sDeltaTime$2$[ebp]
	cmp	eax, DWORD PTR tv3167[ebp]
	jbe	SHORT $LN101@recExecute
$LN474@recExecute:

; 376  : 		m_iStart = iEnd - m_iTicks;

	sub	edx, DWORD PTR _m_iTicks
	mov	DWORD PTR _m_iStart, edx
	sbb	ecx, DWORD PTR _m_iTicks+4

; 377  : 
; 378  : 		// Let the GS Skipper know we lost time.
; 379  : 		// Keeps the GS skipper from trying to catch up to a framerate
; 380  : 		// that the limiter already gave up on.
; 381  : 
; 382  : 		gsSyncLimiterLostTime( (s32)(m_iStart - uExpectedEnd) );

	sub	edx, esi
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\gs.cpp

; 594  : 	if( !m_StrictSkipping ) return;

	cmp	BYTE PTR _m_StrictSkipping, 0
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp

; 376  : 		m_iStart = iEnd - m_iTicks;

	mov	DWORD PTR _m_iStart+4, ecx
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\gs.cpp

; 594  : 	if( !m_StrictSkipping ) return;

	je	SHORT $LN481@recExecute

; 595  : 
; 596  : 	//SysPrintf("LostTime on the EE!\n");
; 597  : 
; 598  : 	if( mtgsThread != NULL )

	mov	ecx, DWORD PTR ?mtgsThread@@3PAVmtgsThreadObject@@A ; mtgsThread
	test	ecx, ecx
	je	SHORT $LN109@recExecute

; 599  : 	{
; 600  : 		mtgsThread->SendSimplePacket(
; 601  : 			GS_RINGTYPE_STARTTIME,
; 602  : 			deltaTime,
; 603  : 			0,
; 604  : 			0
; 605  : 		);

	push	0
	push	0
	push	edx
	push	16					; 00000010H
	call	?SendSimplePacket@mtgsThreadObject@@QAEXW4GS_RINGTYPE@@HHH@Z ; mtgsThreadObject::SendSimplePacket

; 606  : 	}
; 607  : 	else

	jmp	SHORT $LN481@recExecute
$LN109@recExecute:

; 608  : 	{
; 609  : 		m_iSlowStart += deltaTime;

	mov	eax, edx
	cdq
	add	DWORD PTR ?m_iSlowStart@@3_KA, eax
	adc	DWORD PTR ?m_iSlowStart@@3_KA+4, edx
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp

; 383  : 		return;

	jmp	SHORT $LN481@recExecute
$LN504@recExecute:
	mov	eax, DWORD PTR _sDeltaTime$2$[ebp]
$LN101@recExecute:

; 384  : 	}
; 385  : 
; 386  : 	// use the expected frame completion time as our starting point.
; 387  : 	// improves smoothness by making the framelimiter more adaptive to the
; 388  : 	// imperfect TIMESLICE() wait, and allows it to speed up a wee bit after
; 389  : 	// slow frames to "catch up."
; 390  : 
; 391  : 	m_iStart = uExpectedEnd;
; 392  : 
; 393  : 	while( sDeltaTime < 0 )

	cmp	DWORD PTR _sDeltaTime$1$[ebp], 0
	mov	DWORD PTR _m_iStart, esi
	mov	DWORD PTR _m_iStart+4, edi
	jg	SHORT $LN481@recExecute
	jl	SHORT $LL100@recExecute
	test	eax, eax
	jae	SHORT $LN481@recExecute
	npad	4
$LL100@recExecute:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\windows\winthreads.cpp

; 61   : 		Sleep(0);

	push	0
	call	DWORD PTR __imp__Sleep@4
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\misc.cpp

; 825  :     QueryPerformanceCounter(&count);

	lea	eax, DWORD PTR _count$1[ebp]
	push	eax
	call	DWORD PTR __imp__QueryPerformanceCounter@4
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp

; 397  : 		sDeltaTime = iEnd - uExpectedEnd;

	mov	ecx, DWORD PTR _count$1[ebp]
	mov	eax, DWORD PTR _count$1[ebp+4]
	sub	ecx, esi
	sbb	eax, edi
	mov	DWORD PTR _sDeltaTime$6[ebp+4], eax
	js	SHORT $LL100@recExecute

; 384  : 	}
; 385  : 
; 386  : 	// use the expected frame completion time as our starting point.
; 387  : 	// improves smoothness by making the framelimiter more adaptive to the
; 388  : 	// imperfect TIMESLICE() wait, and allows it to speed up a wee bit after
; 389  : 	// slow frames to "catch up."
; 390  : 
; 391  : 	m_iStart = uExpectedEnd;
; 392  : 
; 393  : 	while( sDeltaTime < 0 )

	jg	SHORT $LN481@recExecute
	test	ecx, ecx
	jb	SHORT $LL100@recExecute
$LN481@recExecute:

; 507  : 	{
; 508  : 		VSyncEnd(counters[5].sCycle);
; 509  : 
; 510  : 		counters[5].sCycle += vSyncInfo.Blank;

	mov	eax, DWORD PTR _vSyncInfo+8
	add	DWORD PTR ?counters@@3PAUCounter@@A+228, eax

; 511  : 		counters[5].CycleT = vSyncInfo.Render;

	mov	eax, DWORD PTR _vSyncInfo+4

; 512  : 		counters[5].modeval = MODE_VRENDER;
; 513  : 
; 514  : 		return true;

	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	DWORD PTR ?counters@@3PAUCounter@@A+232, eax
	mov	DWORD PTR ?counters@@3PAUCounter@@A+204, 0
	mov	BYTE PTR _vsyncEvent$1$[ebp], 1
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A$1[ebp], edx
	jmp	$LN69@recExecute
$LN67@recExecute:

; 398  : 	}
; 399  : }
; 400  : 
; 401  : static __forceinline void VSyncStart(u32 sCycle)
; 402  : {
; 403  : 	EECNT_LOG( "/////////  EE COUNTER VSYNC START  \\\\\\\\\\\\\\\\\\\\  (frame: %d)\n", iFrame );

	test	DWORD PTR ?varLog@@3IA, 1073741824	; varLog, 40000000H
	je	SHORT $LN123@recExecute
	push	DWORD PTR _iFrame
	push	OFFSET ??_C@_0DM@NMBMHAFB@?1?1?1?1?1?1?1?1?1?5?5EE?5COUNTER?5VSYNC?5STAR@
	call	?SrcLog_EECNT@@YA_NPBDZZ		; SrcLog_EECNT
	add	esp, 8
$LN123@recExecute:

; 404  : 	vSyncDebugStuff(); // EE Profiling and Debug code

	call	?vSyncDebugStuff@@YAXXZ			; vSyncDebugStuff

; 405  : 
; 406  : 	if ((CSRw & 0x8)) GSCSRr|= 0x8;

	test	BYTE PTR ?CSRw@@3IA, 8
	je	SHORT $LN120@recExecute
	mov	eax, DWORD PTR ?g_RealGSMem@@3PAEA+4100
	or	DWORD PTR ?g_RealGSMem@@3PAEA+4096, 8
	mov	DWORD PTR ?g_RealGSMem@@3PAEA+4100, eax
$LN120@recExecute:

; 407  : 	if (!(GSIMR&0x800)) gsIrq();

	test	DWORD PTR ?g_RealGSMem@@3PAEA+4112, 2048 ; 00000800H
	jne	SHORT $LN126@recExecute
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp

; 109  : 	psHu32(INTC_STAT)|= 1<<n;

	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
	or	DWORD PTR [eax+61440], edi

; 110  : 	cpuTestINTCInts();

	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
$LN126@recExecute:

; 109  : 	psHu32(INTC_STAT)|= 1<<n;

	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
	or	DWORD PTR [eax+61440], 4

; 110  : 	cpuTestINTCInts();

	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\iopcounters.cpp

; 349  : 	cdvdVsync();

	call	?cdvdVsync@@YAXXZ			; cdvdVsync

; 350  : 	psxHu32(0x1070) |= 1;

	mov	eax, DWORD PTR ?psxH@@3PAEA		; psxH
	or	DWORD PTR [eax+4208], edi

; 351  : 	if(psxvblankgate & (1 << 1)) psxCheckStartGate16(1);

	mov	al, BYTE PTR ?psxvblankgate@@3EA	; psxvblankgate
	test	al, 2
	je	SHORT $LN131@recExecute
	mov	ecx, edi
	call	?psxCheckStartGate16@@YAXH@Z		; psxCheckStartGate16
	mov	al, BYTE PTR ?psxvblankgate@@3EA	; psxvblankgate
$LN131@recExecute:

; 352  : 	if(psxvblankgate & (1 << 3)) psxCheckStartGate32(3);

	test	al, 8
	je	SHORT $LN153@recExecute

; 331  : }
; 332  : 
; 333  : static void psxCheckStartGate32(int i)
; 334  : {
; 335  : 	// 32 bit gate is called for gate 3 only.  Ever.
; 336  : 	assert(i == 3);
; 337  : 	_psxCheckStartGate( i );

	mov	ecx, 3
	call	?_psxCheckStartGate@@YAXH@Z		; _psxCheckStartGate
$LN153@recExecute:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp

; 412  : 	if (gates) rcntStartGate(true, sCycle); // Counters Start Gate code

	cmp	DWORD PTR ?gates@@3HA, 0		; gates
	je	SHORT $LN118@recExecute
	mov	edx, esi
	mov	cl, 1
	call	?rcntStartGate@@YIX_NI@Z		; rcntStartGate
$LN118@recExecute:

; 413  : 	if (Config.Patch) applypatch(1); // Apply patches (ToDo: clean up patch code)

	cmp	DWORD PTR ?Config@@3UPcsxConfig@@A+3596, 0
	je	SHORT $LN117@recExecute
	mov	ecx, edi
	call	?applypatch@@YAXH@Z			; applypatch
$LN117@recExecute:

; 515  : //		SysUpdate();  // check for and handle keyevents
; 516  : 	}
; 517  : 	else	// VSYNC end / VRENDER begin
; 518  : 	{
; 519  : 		VSyncStart(counters[5].sCycle);
; 520  : 
; 521  : 		counters[5].sCycle += vSyncInfo.Render;

	mov	eax, DWORD PTR _vSyncInfo+4
	add	DWORD PTR ?counters@@3PAUCounter@@A+228, eax

; 522  : 		counters[5].CycleT = vSyncInfo.Blank;

	mov	eax, DWORD PTR _vSyncInfo+8

; 523  : 		counters[5].modeval = MODE_VSYNC;
; 524  : 
; 525  : 		// Accumulate hsync rounding errors:
; 526  : 		counters[4].sCycle += vSyncInfo.hSyncError;
; 527  : 
; 528  : #		ifdef VSYNC_DEBUG
; 529  : 		vblankinc++;
; 530  : 		if( vblankinc > 1 )
; 531  : 		{
; 532  : 			if( hsc != vSyncInfo.hScanlinesPerFrame )
; 533  : 				SysPrintf( " ** vSync > Abnormal Scanline Count: %d\n", hsc );
; 534  : 			hsc = 0;
; 535  : 			vblankinc = 0;
; 536  : 		}
; 537  : #		endif
; 538  : 	}
; 539  : 	return false;

	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	DWORD PTR ?counters@@3PAUCounter@@A+232, eax
	mov	eax, DWORD PTR _vSyncInfo+12
	add	DWORD PTR ?counters@@3PAUCounter@@A+188, eax
	mov	DWORD PTR ?counters@@3PAUCounter@@A+204, 3
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A$1[ebp], edx
$LN507@recExecute:
	mov	BYTE PTR _vsyncEvent$1$[ebp], 0
$LN69@recExecute:

; 574  : }
; 575  : 
; 576  : 
; 577  : // forceinline note: this method is called from two locations, but one
; 578  : // of them is the interpreter, which doesn't count. ;)  So might as
; 579  : // well forceinline it!
; 580  : __forceinline bool rcntUpdate()
; 581  : {
; 582  : 	bool retval = rcntUpdate_vSync();
; 583  : 
; 584  : 	// Update counters so that we can perform overflow and target tests.
; 585  : 	
; 586  : 	for (int i=0; i<=3; i++) {

	mov	DWORD PTR _i$1$[ebp], 0
	mov	esi, OFFSET ?counters@@3PAUCounter@@A+4
	npad	5
$LL63@recExecute:

; 587  : 		
; 588  : 		// We want to count gated counters (except the hblank which exclude below, and are
; 589  : 		// counted by the hblank timer instead)
; 590  : 
; 591  : 		//if ( gates & (1<<i) ) continue;
; 592  : 		
; 593  : 		if (!counters[i].mode.IsCounting ) continue;

	mov	eax, DWORD PTR [esi]
	test	al, al
	jns	$LN62@recExecute

; 594  : 
; 595  : 		if(counters[i].mode.ClockSource != 0x3)	// don't count hblank sources

	and	eax, 3
	cmp	al, 3
	je	$LN59@recExecute

; 596  : 		{
; 597  : 			s32 change = cpuRegs.cycle - counters[i].sCycleT;

	mov	edi, edx

; 540  : }
; 541  : 
; 542  : static __forceinline void __fastcall _cpuTestTarget( int i )
; 543  : {
; 544  : 	if (counters[i].count < counters[i].target) return;

	mov	ecx, DWORD PTR [esi+4]

; 596  : 		{
; 597  : 			s32 change = cpuRegs.cycle - counters[i].sCycleT;

	sub	edi, DWORD PTR [esi+32]

; 598  : 			if( change < 0 ) change = 0;	// sanity check!

	mov	eax, 0
	cmovs	edi, eax

; 599  : 
; 600  : 			counters[i].count += change / counters[i].rate;

	xor	edx, edx
	mov	eax, edi
	div	DWORD PTR [esi+12]
	add	DWORD PTR [esi-4], eax

; 601  : 			change -= (change / counters[i].rate) * counters[i].rate;

	imul	eax, DWORD PTR [esi+12]

; 540  : }
; 541  : 
; 542  : static __forceinline void __fastcall _cpuTestTarget( int i )
; 543  : {
; 544  : 	if (counters[i].count < counters[i].target) return;

	mov	edx, DWORD PTR [esi-4]

; 601  : 			change -= (change / counters[i].rate) * counters[i].rate;

	sub	edi, eax

; 602  : 			counters[i].sCycleT = cpuRegs.cycle - change;

	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A$1[ebp]
	sub	eax, edi
	mov	DWORD PTR [esi+32], eax

; 545  : 
; 546  : 	if(counters[i].mode.TargetInterrupt) {

	mov	eax, DWORD PTR [esi]
	cmp	edx, ecx
	jb	SHORT $LN500@recExecute
	test	eax, 256				; 00000100H
	je	SHORT $LN158@recExecute

; 547  : 
; 548  : 		EECNT_LOG("EE Counter[%d] TARGET reached - mode=%x, count=%x, target=%x\n", i, counters[i].mode, counters[i].count, counters[i].target);

	test	DWORD PTR ?varLog@@3IA, 1073741824	; varLog, 40000000H
	mov	edi, DWORD PTR _i$1$[ebp]
	je	SHORT $LN162@recExecute
	push	ecx
	push	edx
	push	eax
	push	edi
	push	OFFSET ??_C@_0DO@EGNLMAGK@EE?5Counter?$FL?$CFd?$FN?5TARGET?5reached?5?9?5@
	call	?SrcLog_EECNT@@YA_NPBDZZ		; SrcLog_EECNT
	add	esp, 20					; 00000014H
$LN162@recExecute:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp

; 109  : 	psHu32(INTC_STAT)|= 1<<n;

	mov	edx, DWORD PTR ?psH@@3PAEA		; psH
	mov	eax, 1
	mov	ecx, DWORD PTR [esi+16]
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp

; 549  : 		counters[i].mode.TargetReached = 1;

	or	DWORD PTR [esi], 1024			; 00000400H
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp

; 109  : 	psHu32(INTC_STAT)|= 1<<n;

	shl	eax, cl
	or	DWORD PTR [edx+61440], eax

; 110  : 	cpuTestINTCInts();

	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp

; 553  : 		if (counters[i].mode.ZeroReturn)

	mov	eax, DWORD PTR [esi]

; 555  : 		else

	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A$1[ebp], edx
	test	al, 64					; 00000040H
	je	SHORT $LN157@recExecute

; 554  : 			counters[i].count -= counters[i].target; // Reset on target

	mov	eax, DWORD PTR [esi+4]
	sub	DWORD PTR [esi-4], eax

; 555  : 		else

	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN155@recExecute
$LN157@recExecute:

; 556  : 			counters[i].target |= EECNT_FUTURE_TARGET;

	or	DWORD PTR [esi+4], 268435456		; 10000000H

; 557  : 	} 
; 558  : 	else counters[i].target |= EECNT_FUTURE_TARGET;

	jmp	SHORT $LN155@recExecute
$LN158@recExecute:
	or	ecx, 268435456				; 10000000H
	mov	DWORD PTR [esi+4], ecx
$LN500@recExecute:
	mov	edi, DWORD PTR _i$1$[ebp]
$LN155@recExecute:

; 559  : }
; 560  : 
; 561  : static __forceinline void _cpuTestOverflow( int i )
; 562  : {
; 563  : 	if (counters[i].count <= 0xffff) return;

	mov	ecx, DWORD PTR [esi-4]
	cmp	ecx, 65535				; 0000ffffH
	jbe	SHORT $LN62@recExecute

; 564  : 	
; 565  : 	if (counters[i].mode.OverflowInterrupt) {

	test	eax, 512				; 00000200H
	je	SHORT $LN170@recExecute

; 566  : 		EECNT_LOG("EE Counter[%d] OVERFLOW - mode=%x, count=%x\n", i, counters[i].mode, counters[i].count);

	test	DWORD PTR ?varLog@@3IA, 1073741824	; varLog, 40000000H
	je	SHORT $LN169@recExecute
	push	ecx
	push	DWORD PTR [esi]
	push	edi
	push	OFFSET ??_C@_0CN@DJCFHOEE@EE?5Counter?$FL?$CFd?$FN?5OVERFLOW?5?9?5mode?$DN?$CF@
	call	?SrcLog_EECNT@@YA_NPBDZZ		; SrcLog_EECNT
	add	esp, 16					; 00000010H
$LN169@recExecute:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp

; 109  : 	psHu32(INTC_STAT)|= 1<<n;

	mov	edx, DWORD PTR ?psH@@3PAEA		; psH
	mov	eax, 1
	mov	ecx, DWORD PTR [esi+16]
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp

; 567  : 		counters[i].mode.OverflowReached = 1;

	or	DWORD PTR [esi], 2048			; 00000800H
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp

; 109  : 	psHu32(INTC_STAT)|= 1<<n;

	shl	eax, cl
	or	DWORD PTR [edx+61440], eax

; 110  : 	cpuTestINTCInts();

	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A$1[ebp], edx
$LN170@recExecute:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp

; 572  : 	counters[i].count -= 0x10000;

	add	DWORD PTR [esi-4], -65536		; ffff0000H

; 573  : 	counters[i].target &= 0xffff;

	xor	eax, eax
	mov	WORD PTR [esi+6], ax

; 603  : 
; 604  : 			// Check Counter Targets and Overflows:
; 605  : 			_cpuTestTarget( i );
; 606  : 			_cpuTestOverflow( i );
; 607  : 		} 
; 608  : 		else counters[i].sCycleT = cpuRegs.cycle;

	jmp	SHORT $LN62@recExecute
$LN59@recExecute:
	mov	DWORD PTR [esi+32], edx
$LN62@recExecute:

; 574  : }
; 575  : 
; 576  : 
; 577  : // forceinline note: this method is called from two locations, but one
; 578  : // of them is the interpreter, which doesn't count. ;)  So might as
; 579  : // well forceinline it!
; 580  : __forceinline bool rcntUpdate()
; 581  : {
; 582  : 	bool retval = rcntUpdate_vSync();
; 583  : 
; 584  : 	// Update counters so that we can perform overflow and target tests.
; 585  : 	
; 586  : 	for (int i=0; i<=3; i++) {

	inc	DWORD PTR _i$1$[ebp]
	add	esi, 40					; 00000028H
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A$1[ebp]
	cmp	esi, OFFSET ?counters@@3PAUCounter@@A+124
	jle	$LL63@recExecute

; 96   : }
; 97   : 
; 98   : 
; 99   : static __forceinline void cpuRcntSet()
; 100  : {
; 101  : 	int i;
; 102  : 
; 103  : 	nextsCounter = cpuRegs.cycle;
; 104  : 	nextCounter = (counters[5].sCycle + counters[5].CycleT) - cpuRegs.cycle;

	mov	esi, DWORD PTR ?counters@@3PAUCounter@@A+232
	mov	edi, OFFSET ?counters@@3PAUCounter@@A+8
	sub	esi, edx
	mov	DWORD PTR ?nextsCounter@@3IA, edx	; nextsCounter
	add	esi, DWORD PTR ?counters@@3PAUCounter@@A+228
$LL175@recExecute:

; 69   : 	if (!counter.mode.IsCounting || (counter.mode.ClockSource == 0x3) ) return;

	mov	eax, DWORD PTR [edi-4]
	test	al, al
	jns	SHORT $LN174@recExecute
	and	eax, 3
	cmp	al, 3
	je	SHORT $LN174@recExecute

; 70   : 	
; 71   : 	// check for special cases where the overflow or target has just passed
; 72   : 	// (we probably missed it because we're doing/checking other things)
; 73   : 	if( counter.count > 0x10000 || counter.count > counter.target )

	mov	eax, DWORD PTR [edi-8]
	cmp	eax, 65536				; 00010000H
	ja	SHORT $LN181@recExecute
	mov	ecx, DWORD PTR [edi]
	cmp	eax, ecx
	ja	SHORT $LN181@recExecute

; 76   : 		return;
; 77   : 	}
; 78   : 
; 79   : 	// nextCounter is relative to the cpuRegs.cycle when rcntUpdate() was last called.
; 80   : 	// However, the current _rcntSet could be called at any cycle count, so we need to take
; 81   : 	// that into account.  Adding the difference from that cycle count to the current one
; 82   : 	// will do the trick!
; 83   : 
; 84   : 	c = ((0x10000 - counter.count) * counter.rate) - (cpuRegs.cycle - counter.sCycleT);

	mov	eax, 65536				; 00010000H
	sub	eax, DWORD PTR [edi-8]
	imul	eax, DWORD PTR [edi+8]

; 85   : 	c += cpuRegs.cycle - nextsCounter;		// adjust for time passed since last rcntUpdate();

	sub	eax, edx
	add	eax, DWORD PTR [edi+28]

; 86   : 	if (c < nextCounter) nextCounter = c;

	cmp	eax, esi
	cmovl	esi, eax

; 87   : 
; 88   : 	// Ignore target diff if target is currently disabled.
; 89   : 	// (the overflow is all we care about since it goes first, and then the 
; 90   : 	// target will be turned on afterward).
; 91   : 
; 92   : 	if( counter.target & EECNT_FUTURE_TARGET ) return;

	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN174@recExecute

; 93   : 	c = ((counter.target - counter.count) * counter.rate) - (cpuRegs.cycle - counter.sCycleT);

	sub	ecx, DWORD PTR [edi-8]
	imul	ecx, DWORD PTR [edi+8]

; 94   : 	c += cpuRegs.cycle - nextsCounter;		// adjust for time passed since last rcntUpdate();

	sub	ecx, edx
	add	ecx, DWORD PTR [edi+28]

; 95   : 	if (c < nextCounter) nextCounter = c;

	cmp	ecx, esi
	jge	SHORT $LN174@recExecute
	mov	esi, ecx
	jmp	SHORT $LN174@recExecute
$LN181@recExecute:

; 74   : 	{
; 75   : 		nextCounter = 4;

	mov	esi, 4
$LN174@recExecute:

; 105  : 
; 106  : 	for (i = 0; i < 4; i++)

	add	edi, 40					; 00000028H
	cmp	edi, OFFSET ?counters@@3PAUCounter@@A+168
	jl	SHORT $LL175@recExecute
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 414  : 	if((cpuRegs.PERF.n.pccr & 0x800003E0) == 0x80000020) {

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+688
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp

; 110  : 	if( nextCounter < 0 ) nextCounter = 0;

	xor	eax, eax
	test	esi, esi
	cmovs	esi, eax
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 414  : 	if((cpuRegs.PERF.n.pccr & 0x800003E0) == 0x80000020) {

	mov	eax, ecx
	and	eax, -2147482656			; 800003e0H
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp

; 110  : 	if( nextCounter < 0 ) nextCounter = 0;

	mov	DWORD PTR ?nextCounter@@3HA, esi	; nextCounter
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 414  : 	if((cpuRegs.PERF.n.pccr & 0x800003E0) == 0x80000020) {

	cmp	eax, -2147483616			; 80000020H
	jne	SHORT $LN188@recExecute

; 415  : 		cpuRegs.PERF.n.pcr0 += cpuRegs.cycle-s_iLastPERFCycle[0];

	mov	eax, edx
	sub	eax, DWORD PTR ?s_iLastPERFCycle@@3PAIA
	add	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+692, eax

; 416  : 		s_iLastPERFCycle[0] = cpuRegs.cycle;

	mov	DWORD PTR ?s_iLastPERFCycle@@3PAIA, edx
$LN188@recExecute:

; 417  : 	}
; 418  : 	if((cpuRegs.PERF.n.pccr & 0x800F8000) == 0x80008000) {

	and	ecx, -2146467840			; 800f8000H
	cmp	ecx, -2147450880			; 80008000H
	jne	SHORT $LN482@recExecute

; 419  : 		cpuRegs.PERF.n.pcr1 += cpuRegs.cycle-s_iLastPERFCycle[1];

	mov	eax, edx
	sub	eax, DWORD PTR ?s_iLastPERFCycle@@3PAIA+4
	add	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+696, eax

; 420  : 		s_iLastPERFCycle[1] = cpuRegs.cycle;

	mov	DWORD PTR ?s_iLastPERFCycle@@3PAIA+4, edx
$LN482@recExecute:

; 375  : 	{
; 376  : 		TESTINT(0, vif0Interrupt);
; 377  : #ifndef IPU_INLINE_IRQS
; 378  : 		TESTINT(3, ipu0Interrupt);
; 379  : 		TESTINT(4, ipu1Interrupt);
; 380  : #endif
; 381  : 		TESTINT(8, SPRFROMinterrupt);
; 382  : 		TESTINT(9, SPRTOinterrupt);
; 383  : 
; 384  : 		TESTINT(10, vifMFIFOInterrupt);
; 385  : 		TESTINT(11, gifMFIFOInterrupt);
; 386  : 	}
; 387  : }
; 388  : 
; 389  : static __forceinline void _cpuTestTIMR()
; 390  : {
; 391  : 	cpuRegs.CP0.n.Count += cpuRegs.cycle-s_iLastCOP0Cycle;

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+580
	mov	eax, edx
	sub	eax, DWORD PTR ?s_iLastCOP0Cycle@@3IA	; s_iLastCOP0Cycle
	add	ecx, eax

; 392  : 	s_iLastCOP0Cycle = cpuRegs.cycle;

	mov	DWORD PTR ?s_iLastCOP0Cycle@@3IA, edx	; s_iLastCOP0Cycle

; 393  : 
; 394  : 	// fixme: this looks like a hack to make up for the fact that the TIMR
; 395  : 	// doesn't yet have a proper mechanism for setting itself up on a nextBranchCycle.
; 396  : 	// A proper fix would schedule the TIMR to trigger at a specific cycle anytime
; 397  : 	// the Count or Compare registers are modified.
; 398  : 
; 399  : 	if ( (cpuRegs.CP0.n.Status.val & 0x8000) &&
; 400  : 		cpuRegs.CP0.n.Count >= cpuRegs.CP0.n.Compare && cpuRegs.CP0.n.Count < cpuRegs.CP0.n.Compare+1000 )

	test	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+592, 32768 ; 00008000H
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+580, ecx
	je	SHORT $LN191@recExecute
	mov	esi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+588
	cmp	ecx, esi
	jb	SHORT $LN191@recExecute
	lea	eax, DWORD PTR [esi+1000]
	cmp	ecx, eax
	jae	SHORT $LN191@recExecute

; 401  : 	{
; 402  : 		Console::Status("timr intr: %x, %x", params cpuRegs.CP0.n.Count, cpuRegs.CP0.n.Compare);

	push	esi
	push	ecx
	push	0
	push	OFFSET ??_C@_0BC@KKHOMMCD@timr?5intr?3?5?$CFx?0?5?$CFx?$AA@
	call	?Status@Console@@YA_NPBDPBU_VARG_PARAM@@ZZ ; Console::Status

; 403  : 		cpuException(0x808000, cpuRegs.branch);

	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+968
	add	esp, 16					; 00000010H
	mov	ecx, 8421376				; 00808000H
	call	?cpuException@@YAXII@Z			; cpuException
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A$1[ebp], edx
$LN191@recExecute:

; 456  : 	{
; 457  : 		vsyncEvent = rcntUpdate();
; 458  : 		_cpuTestPERF();
; 459  : 	}
; 460  : 
; 461  : 	_cpuTestTIMR();
; 462  : 
; 463  : 	// ---- Interrupts -------------
; 464  : 	// Handles all interrupts except 30 and 31, which are handled later.
; 465  : 
; 466  : 	if( cpuRegs.interrupt & ~(3<<30) )

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
	test	ecx, 1073741823				; 3fffffffH
	je	$LN391@recExecute

; 349  : 	if( !(cpuRegs.interrupt & (1 << n)) ) return;

	test	cl, 2
	je	$LN498@recExecute

; 332  : 	return (int)(cpuRegs.cycle - startCycle) >= delta;

	mov	edi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+836
	mov	eax, edx
	mov	esi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+708
	sub	eax, edi
	cmp	eax, esi

; 350  : 
; 351  : 	if( cpuTestCycle( cpuRegs.sCycle[n], cpuRegs.eCycle[n] ) )

	jl	$LN198@recExecute

; 344  : 	cpuRegs.interrupt &= ~(1 << i);

	and	ecx, -3					; fffffffdH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vifdma.cpp

; 1974 : 	VIF_LOG("vif1Interrupt: %8.8x\n", cpuRegs.cycle);

	test	DWORD PTR ?varLog@@3IA, 1024		; varLog, 00000400H
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 344  : 	cpuRegs.interrupt &= ~(1 << i);

	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, ecx
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vifdma.cpp

; 1974 : 	VIF_LOG("vif1Interrupt: %8.8x\n", cpuRegs.cycle);

	je	SHORT $LN221@recExecute
	push	edx
	push	OFFSET ??_C@_0BG@OEMEHKAM@vif1Interrupt?3?5?$CF8?48x?6?$AA@
	call	?SrcLog_VIF@@YA_NPBDZZ			; SrcLog_VIF
	add	esp, 8
$LN221@recExecute:

; 1975 : 
; 1976 : 	g_vifCycles = 0;
; 1977 :     
; 1978 : 	
; 1979 : 		if(vif1.irq && vif1.tag.size == 0) {

	cmp	DWORD PTR ?vif1@@3UvifStruct@@A+20, 0
	mov	DWORD PTR ?g_vifCycles@@3HA, 0		; g_vifCycles
	je	$LN216@recExecute
	cmp	DWORD PTR ?vif1@@3UvifStruct@@A+4, 0
	jne	$LN216@recExecute

; 1980 : 			vif1Regs->stat|= VIF1_STAT_INT;

	mov	esi, DWORD PTR ?psH@@3PAEA		; psH
	or	DWORD PTR [esi+15360], 2048		; 00000800H
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp

; 109  : 	psHu32(INTC_STAT)|= 1<<n;

	or	DWORD PTR [esi+61440], 32		; 00000020H

; 110  : 	cpuTestINTCInts();

	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vifdma.cpp

; 1982 : 			--vif1.irq;

	dec	DWORD PTR ?vif1@@3UvifStruct@@A+20

; 1983 : 			if(vif1Regs->stat & (VIF1_STAT_VSS|VIF1_STAT_VIS|VIF1_STAT_VFS))

	mov	eax, DWORD PTR [esi+15360]
	test	eax, 1792				; 00000700H
	je	SHORT $LN217@recExecute

; 1984 : 				{
; 1985 : 					vif1Regs->stat&= ~0x1F000000; // FQC=0

	and	eax, -520093697				; e0ffffffH

; 1986 : 					// One game doesnt like vif stalling at end, cant remember what. Spiderman isnt keen on it tho
; 1987 : 					vif1ch->chcr &= ~0x100;

	and	DWORD PTR [esi+36864], -257		; fffffeffH
	mov	DWORD PTR [esi+15360], eax

; 1988 : 					return;

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	jmp	$LN240@recExecute
$LN217@recExecute:

; 1989 : 				} 
; 1990 : 			
; 1991 : 			if(vif1ch->qwc > 0 || vif1.irqoffset > 0){

	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
	cmp	WORD PTR [eax+36896], 0
	ja	SHORT $LN215@recExecute
	cmp	BYTE PTR ?vif1@@3UvifStruct@@A+36, 0
	jbe	SHORT $LN216@recExecute
$LN215@recExecute:

; 1992 : 				if(vif1.stallontag == 1) {

	cmp	BYTE PTR ?vif1@@3UvifStruct@@A+35, 1
	jne	SHORT $LN214@recExecute
$LN210@recExecute:

; 1993 : 					_chainVIF1();

	call	?_chainVIF1@@YAHXZ			; _chainVIF1
	jmp	SHORT $LN213@recExecute
$LN214@recExecute:

; 1994 : 					}
; 1995 : 				else _VIF1chain();//CPU_INT(13, vif1ch->qwc * BIAS);

	call	?_VIF1chain@@YAHXZ			; _VIF1chain
$LN213@recExecute:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 677  : 	cpuRegs.interrupt|= 1 << n;

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vifdma.cpp

; 1996 : 				CPU_INT(1, g_vifCycles);

	mov	esi, DWORD PTR ?g_vifCycles@@3HA	; g_vifCycles
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 677  : 	cpuRegs.interrupt|= 1 << n;

	or	ecx, 2

; 678  : 	cpuRegs.sCycle[n] = cpuRegs.cycle;

	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960

; 679  : 	cpuRegs.eCycle[n] = ecycle;

	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+708, esi
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+836, edx
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, ecx

; 680  : 
; 681  : 	// Interrupt is happening soon: make sure both EE and IOP are aware.
; 682  : 
; 683  : 	if( ecycle <= 28 && psxCycleEE > 0 )

	cmp	esi, 28					; 0000001cH
	jg	SHORT $LN224@recExecute
	mov	eax, DWORD PTR ?psxCycleEE@@3HA		; psxCycleEE
	test	eax, eax
	jle	SHORT $LN224@recExecute

; 684  : 	{
; 685  : 		// If running in the IOP, force it to break immediately into the EE.
; 686  : 		// the EE's branch test is due to run.
; 687  : 
; 688  : 		psxBreak += psxCycleEE;		// record the number of cycles the IOP didn't run.

	add	DWORD PTR ?psxBreak@@3HA, eax		; psxBreak

; 689  : 		psxCycleEE = 0;

	mov	DWORD PTR ?psxCycleEE@@3HA, 0		; psxCycleEE
$LN224@recExecute:

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	eax, edx
	cmp	eax, esi
	jle	$LN240@recExecute

; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	eax, DWORD PTR [edx+esi]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vifdma.cpp

; 1997 : 				return;

	jmp	$LN240@recExecute
$LN216@recExecute:

; 1998 : 			}
; 1999 : 		}
; 2000 : 		
; 2001 : 		
; 2002 : 	//}
; 2003 : 	if((vif1ch->chcr & 0x100) == 0) SysPrintf("Vif1 running when CHCR == %x\n", vif1ch->chcr);

	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
	mov	eax, DWORD PTR [eax+36864]
	test	eax, 256				; 00000100H
	jne	SHORT $LN212@recExecute
	push	eax
	push	OFFSET ??_C@_0BO@KFAMBPHK@Vif1?5running?5when?5CHCR?5?$DN?$DN?5?$CFx?6?$AA@
	call	?SysPrintf@@YAXPBDZZ			; SysPrintf
	add	esp, 8
$LN212@recExecute:

; 2004 : 
; 2005 : 	
; 2006 : 	if ((vif1ch->chcr & 0x104) == 0x104 && vif1.done == 0) {

	mov	esi, DWORD PTR ?psH@@3PAEA		; psH
	mov	eax, DWORD PTR [esi+36864]
	and	eax, 260				; 00000104H
	cmp	eax, 260				; 00000104H
	jne	SHORT $LN211@recExecute
	cmp	BYTE PTR ?vif1@@3UvifStruct@@A+33, 0
	jne	SHORT $LN211@recExecute

; 2007 : 
; 2008 : 		if( !(psHu32(DMAC_CTRL) & 0x1) ) {

	test	BYTE PTR [esi+57344], 1
	jne	$LN210@recExecute

; 2009 : 			SysPrintf("vif1 dma masked\n");

	push	OFFSET ??_C@_0BB@EELLKNKM@vif1?5dma?5masked?6?$AA@
	call	?SysPrintf@@YAXPBDZZ			; SysPrintf

; 2010 : 			return;

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
	add	esp, 4
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	jmp	$LN240@recExecute
$LN211@recExecute:

; 2011 : 		}
; 2012 : 
; 2013 : 		_chainVIF1();
; 2014 : 		CPU_INT(1, g_vifCycles);
; 2015 : 		
; 2016 : 		return;
; 2017 : 	}
; 2018 : #ifdef PCSX2_DEVBUILD
; 2019 : 	if(vif1ch->qwc > 0) SysPrintf("VIF1 Ending with %x QWC left\n");

	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
	cmp	WORD PTR [eax+36896], 0
	jbe	SHORT $LN209@recExecute
	push	OFFSET ??_C@_0BO@OINNBNMI@VIF1?5Ending?5with?5?$CFx?5QWC?5left?6?$AA@
	call	?SysPrintf@@YAXPBDZZ			; SysPrintf
	add	esp, 4
$LN209@recExecute:

; 2020 : 	if(vif1.cmd != 0) SysPrintf("vif1.cmd still set %x\n", vif1.cmd);

	mov	eax, DWORD PTR ?vif1@@3UvifStruct@@A+16
	test	eax, eax
	je	SHORT $LN208@recExecute
	push	eax
	push	OFFSET ??_C@_0BH@OMPPLFGP@vif1?4cmd?5still?5set?5?$CFx?6?$AA@
	call	?SysPrintf@@YAXPBDZZ			; SysPrintf
	add	esp, 8
$LN208@recExecute:

; 2021 : #endif
; 2022 : 
; 2023 : 	prevviftag = NULL;
; 2024 : 	prevvifcycles = 0;
; 2025 : 	vif1ch->chcr &= ~0x100;

	mov	eax, DWORD PTR ?psH@@3PAEA		; psH

; 2026 : 	hwDmacIrq(DMAC_VIF1);

	mov	ecx, 1
	mov	DWORD PTR _prevviftag, 0
	mov	DWORD PTR _prevvifcycles, 0
	and	DWORD PTR [eax+36864], -257		; fffffeffH
	call	?hwDmacIrq@@YAXH@Z			; hwDmacIrq

; 2027 : 	if(vif1Regs->mskpath3 == 0 || (vif1ch->chcr & 0x1) == 0x1)vif1Regs->stat&= ~0x1F000000; // FQC=0

	mov	esi, DWORD PTR ?psH@@3PAEA		; psH
	cmp	DWORD PTR [esi+15600], 0
	je	SHORT $LN206@recExecute
	test	BYTE PTR [esi+36864], 1
	jne	SHORT $LN206@recExecute
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 313  : 		g_nextBranchCycle = startCycle + delta;

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	jmp	SHORT $LN240@recExecute
$LN206@recExecute:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vifdma.cpp

; 2027 : 	if(vif1Regs->mskpath3 == 0 || (vif1ch->chcr & 0x1) == 0x1)vif1Regs->stat&= ~0x1F000000; // FQC=0

	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
	and	DWORD PTR [eax+15360], -520093697	; e0ffffffH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 356  : 	else

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	jmp	SHORT $LN240@recExecute
$LN198@recExecute:

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A$1[ebp]
	sub	eax, edi
	cmp	eax, esi
	jle	SHORT $LN240@recExecute

; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	eax, DWORD PTR [edi+esi]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vifdma.cpp

; 1997 : 				return;

	jmp	SHORT $LN240@recExecute
$LN498@recExecute:
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A$1[ebp]
$LN240@recExecute:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 349  : 	if( !(cpuRegs.interrupt & (1 << n)) ) return;

	test	cl, 4
	je	$LN485@recExecute

; 332  : 	return (int)(cpuRegs.cycle - startCycle) >= delta;

	mov	edi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+840
	mov	eax, edx
	mov	esi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+712
	sub	eax, edi
	cmp	eax, esi

; 350  : 
; 351  : 	if( cpuTestCycle( cpuRegs.sCycle[n], cpuRegs.eCycle[n] ) )

	jl	$LN244@recExecute

; 344  : 	cpuRegs.interrupt &= ~(1 << i);

	and	ecx, -5					; fffffffbH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\gif.cpp

; 39   : 	GIF_LOG("gsInterrupt: %8.8x\n", cpuRegs.cycle);

	test	DWORD PTR ?varLog@@3IA, 4096		; varLog, 00001000H
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 344  : 	cpuRegs.interrupt &= ~(1 << i);

	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, ecx
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\gif.cpp

; 39   : 	GIF_LOG("gsInterrupt: %8.8x\n", cpuRegs.cycle);

	je	SHORT $LN259@recExecute
	push	edx
	push	OFFSET ??_C@_0BE@FPDFMCPK@gsInterrupt?3?5?$CF8?48x?6?$AA@
	call	?SrcLog_GIF@@YA_NPBDZZ			; SrcLog_GIF
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
	add	esp, 8
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
$LN259@recExecute:

; 40   : 
; 41   : 	if((gif->chcr & 0x100) == 0){

	mov	esi, DWORD PTR ?psH@@3PAEA		; psH
	test	DWORD PTR [esi+40960], 256		; 00000100H
	je	$LN485@recExecute

; 42   : 		//SysPrintf("Eh? why are you still interrupting! chcr %x, qwc %x, done = %x\n", gif->chcr, gif->qwc, done);
; 43   : 		return;
; 44   : 	}
; 45   : 	if(gif->qwc > 0 || gspath3done == 0) {

	cmp	WORD PTR [esi+40992], 0
	ja	SHORT $LN254@recExecute
	cmp	DWORD PTR _gspath3done, 0
	jne	SHORT $LN252@recExecute
$LN254@recExecute:

; 46   : 		if( !(psHu32(DMAC_CTRL) & 0x1) ) {

	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
	test	BYTE PTR [eax+57344], 1
	jne	SHORT $LN253@recExecute

; 47   : 			Console::Notice("gs dma masked, re-scheduling...");

	mov	ecx, OFFSET ??_C@_0CA@OMBBMBNE@gs?5dma?5masked?0?5re?9scheduling?4?4?4?$AA@
	call	?Notice@Console@@YA_NPBD@Z		; Console::Notice
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 677  : 	cpuRegs.interrupt|= 1 << n;

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964

; 678  : 	cpuRegs.sCycle[n] = cpuRegs.cycle;

	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	or	ecx, 4

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	eax, edx

; 677  : 	cpuRegs.interrupt|= 1 << n;

	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, ecx

; 678  : 	cpuRegs.sCycle[n] = cpuRegs.cycle;

	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+840, edx

; 679  : 	cpuRegs.eCycle[n] = ecycle;

	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+712, 64 ; 00000040H

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	cmp	eax, 64					; 00000040H
	jle	$LN485@recExecute

; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	eax, DWORD PTR [edx+64]
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\gif.cpp

; 50   : 			return;

	jmp	$LN511@recExecute
$LN253@recExecute:

; 51   : 		}
; 52   : 
; 53   : 		GIFdma();

	call	?GIFdma@@YAXXZ				; GIFdma

; 54   : #ifdef GSPATH3FIX
; 55   : 		// re-reaise the IRQ as part of the mysterious Path3fix.
; 56   : 		// fixme - this hack *should* have the gs_irq raised from the VIF, I think.  It would be
; 57   : 		// more efficient and more correct.  (air)
; 58   : 		/*if (!(vif1Regs->mskpath3 && (vif1ch->chcr & 0x100)) || (psHu32(GIF_MODE) & 0x1))
; 59   : 			CPU_INT( 2, 64 );*/
; 60   : #endif
; 61   : 		if(gspath3done == 0) return;

	cmp	DWORD PTR _gspath3done, 0
	je	SHORT $LN486@recExecute
$LN252@recExecute:

; 62   : 	}
; 63   : 
; 64   : 	gspath3done = 0;
; 65   : 	gscycles = 0;
; 66   : 	Path3transfer = 0;
; 67   : 	gif->chcr &= ~0x100;

	mov	esi, DWORD PTR ?psH@@3PAEA		; psH
	mov	DWORD PTR _gspath3done, 0
	mov	DWORD PTR _gscycles, 0
	mov	DWORD PTR ?Path3transfer@@3HA, 0	; Path3transfer
	and	DWORD PTR [esi+40960], -257		; fffffeffH

; 68   : 	GSCSRr &= ~0xC000; //Clear FIFO stuff

	mov	ecx, DWORD PTR ?g_RealGSMem@@3PAEA+4096

; 69   : 	GSCSRr |= 0x4000;  //FIFO empty

	mov	eax, DWORD PTR ?g_RealGSMem@@3PAEA+4100
	and	ecx, -32769				; ffff7fffH
	or	ecx, 16384				; 00004000H
	mov	DWORD PTR ?g_RealGSMem@@3PAEA+4100, eax
	mov	DWORD PTR ?g_RealGSMem@@3PAEA+4096, ecx

; 70   : 	//psHu32(GIF_MODE)&= ~0x4;
; 71   : 	psHu32(GIF_STAT)&= ~0xE00; // OPH=0 | APATH=0
; 72   : 	psHu32(GIF_STAT)&= ~0x1F000000; // QFC=0
; 73   : 	hwDmacIrq(DMAC_GIF);

	mov	ecx, 2
	and	DWORD PTR [esi+12320], -520097281	; e0fff1ffH
	call	?hwDmacIrq@@YAXH@Z			; hwDmacIrq
$LN486@recExecute:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 356  : 	else

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	jmp	SHORT $LN485@recExecute
$LN244@recExecute:

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	eax, edi
	cmp	eax, esi
	jle	SHORT $LN485@recExecute

; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	eax, DWORD PTR [edi+esi]
$LN511@recExecute:
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
$LN485@recExecute:

; 349  : 	if( !(cpuRegs.interrupt & (1 << n)) ) return;

	test	cl, 32					; 00000020H
	je	SHORT $LN282@recExecute

; 332  : 	return (int)(cpuRegs.cycle - startCycle) >= delta;

	mov	edi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+852
	mov	eax, edx
	mov	esi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+724
	sub	eax, edi
	cmp	eax, esi

; 350  : 
; 351  : 	if( cpuTestCycle( cpuRegs.sCycle[n], cpuRegs.eCycle[n] ) )

	jl	SHORT $LN272@recExecute
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\sif.cpp

; 521  : 	sif0dma->chcr &= ~0x100;

	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 344  : 	cpuRegs.interrupt &= ~(1 << i);

	and	ecx, -33				; ffffffdfH
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, ecx
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\sif.cpp

; 522  : 	hwDmacIrq(DMAC_SIF0);

	mov	ecx, 5
	and	DWORD PTR [eax+49152], -257		; fffffeffH
	call	?hwDmacIrq@@YAXH@Z			; hwDmacIrq
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 356  : 	else

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	jmp	SHORT $LN282@recExecute
$LN272@recExecute:

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	eax, edi
	cmp	eax, esi
	jle	SHORT $LN282@recExecute

; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	eax, DWORD PTR [edi+esi]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
$LN282@recExecute:

; 349  : 	if( !(cpuRegs.interrupt & (1 << n)) ) return;

	test	cl, 64					; 00000040H
	je	SHORT $LN296@recExecute

; 332  : 	return (int)(cpuRegs.cycle - startCycle) >= delta;

	mov	edi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+856
	mov	eax, edx
	mov	esi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+728
	sub	eax, edi
	cmp	eax, esi

; 350  : 
; 351  : 	if( cpuTestCycle( cpuRegs.sCycle[n], cpuRegs.eCycle[n] ) )

	jl	SHORT $LN286@recExecute

; 344  : 	cpuRegs.interrupt &= ~(1 << i);

	and	ecx, -65				; ffffffbfH
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, ecx
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\sif.cpp

; 526  : 	hwDmacIrq(DMAC_SIF1);

	mov	ecx, 6
	call	?hwDmacIrq@@YAXH@Z			; hwDmacIrq

; 527  : 	sif1dma->chcr &= ~0x100;

	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
	and	DWORD PTR [eax+50176], -257		; fffffeffH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 356  : 	else

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	jmp	SHORT $LN296@recExecute
$LN286@recExecute:

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	eax, edi
	cmp	eax, esi
	jle	SHORT $LN296@recExecute

; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	eax, DWORD PTR [edi+esi]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
$LN296@recExecute:

; 357  : 		cpuSetNextBranch( cpuRegs.sCycle[n], cpuRegs.eCycle[n] );
; 358  : }
; 359  : 
; 360  : static __forceinline void _cpuTestInterrupts()
; 361  : {
; 362  : 	/* These are 'pcsx2 interrupts', they handle asynchronous stuff
; 363  : 	   that depends on the cycle timings */
; 364  : 
; 365  : 	TESTINT(1, vif1Interrupt);
; 366  : 	TESTINT(2, gsInterrupt);
; 367  : 	TESTINT(5, EEsif0Interrupt);
; 368  : 	TESTINT(6, EEsif1Interrupt);
; 369  : 
; 370  : 	// Profile-guided Optimization (sorta)
; 371  : 	// The following ints are rarely called.  Encasing them in a conditional
; 372  : 	// as follows helps speed up most games.
; 373  : 
; 374  : 	if( cpuRegs.interrupt & ( 1 | (3 << 3) | (3<<8) | (3<<10)) )

	test	ecx, 3865				; 00000f19H
	je	$LN391@recExecute

; 349  : 	if( !(cpuRegs.interrupt & (1 << n)) ) return;

	test	cl, 1
	je	SHORT $LN308@recExecute

; 332  : 	return (int)(cpuRegs.cycle - startCycle) >= delta;

	mov	edi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+832
	mov	eax, edx
	mov	esi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+704
	sub	eax, edi
	cmp	eax, esi

; 350  : 
; 351  : 	if( cpuTestCycle( cpuRegs.sCycle[n], cpuRegs.eCycle[n] ) )

	jl	SHORT $LN300@recExecute

; 344  : 	cpuRegs.interrupt &= ~(1 << i);

	and	ecx, -2					; fffffffeH
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, ecx

; 352  : 	{
; 353  : 		cpuClearInt( n );
; 354  : 		callback();

	call	?vif0Interrupt@@YAXXZ			; vif0Interrupt

; 356  : 	else

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	jmp	SHORT $LN308@recExecute
$LN300@recExecute:

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	eax, edi
	cmp	eax, esi
	jle	SHORT $LN308@recExecute

; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	eax, DWORD PTR [edi+esi]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
$LN308@recExecute:

; 349  : 	if( !(cpuRegs.interrupt & (1 << n)) ) return;

	test	cl, 8
	je	SHORT $LN320@recExecute

; 332  : 	return (int)(cpuRegs.cycle - startCycle) >= delta;

	mov	edi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+844
	mov	eax, edx
	mov	esi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+716
	sub	eax, edi
	cmp	eax, esi

; 350  : 
; 351  : 	if( cpuTestCycle( cpuRegs.sCycle[n], cpuRegs.eCycle[n] ) )

	jl	SHORT $LN312@recExecute

; 344  : 	cpuRegs.interrupt &= ~(1 << i);

	and	ecx, -9					; fffffff7H
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, ecx

; 352  : 	{
; 353  : 		cpuClearInt( n );
; 354  : 		callback();

	call	?ipu0Interrupt@@YAXXZ			; ipu0Interrupt

; 356  : 	else

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	jmp	SHORT $LN320@recExecute
$LN312@recExecute:

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	eax, edi
	cmp	eax, esi
	jle	SHORT $LN320@recExecute

; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	eax, DWORD PTR [edi+esi]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
$LN320@recExecute:

; 349  : 	if( !(cpuRegs.interrupt & (1 << n)) ) return;

	test	cl, 16					; 00000010H
	je	$LN340@recExecute

; 332  : 	return (int)(cpuRegs.cycle - startCycle) >= delta;

	mov	edi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+848
	mov	eax, edx
	mov	esi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+720
	sub	eax, edi
	cmp	eax, esi

; 350  : 
; 351  : 	if( cpuTestCycle( cpuRegs.sCycle[n], cpuRegs.eCycle[n] ) )

	jl	$LN324@recExecute

; 344  : 	cpuRegs.interrupt &= ~(1 << i);

	and	ecx, -17				; ffffffefH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\ipu\ipu.cpp

; 1764 : 	IPU_LOG("ipu1Interrupt %x:\n", cpuRegs.cycle);

	test	DWORD PTR ?varLog@@3IA, 16384		; varLog, 00004000H
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 344  : 	cpuRegs.interrupt &= ~(1 << i);

	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, ecx
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\ipu\ipu.cpp

; 1764 : 	IPU_LOG("ipu1Interrupt %x:\n", cpuRegs.cycle);

	je	SHORT $LN337@recExecute
	push	edx
	push	OFFSET ??_C@_0BD@IOONBAFN@ipu1Interrupt?5?$CFx?3?6?$AA@
	call	?SrcLog_IPU@@YA_NPBDZZ			; SrcLog_IPU
	add	esp, 8
$LN337@recExecute:

; 1765 : 
; 1766 : 	if( g_nDMATransfer & IPU_DMA_FIREINT1 ) {

	mov	eax, DWORD PTR _g_nDMATransfer
	test	al, 64					; 00000040H
	je	SHORT $LN334@recExecute
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp

; 109  : 	psHu32(INTC_STAT)|= 1<<n;

	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
	or	DWORD PTR [eax+61440], 256		; 00000100H

; 110  : 	cpuTestINTCInts();

	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\ipu\ipu.cpp

; 1768 : 		g_nDMATransfer &= ~IPU_DMA_FIREINT1;

	mov	eax, DWORD PTR _g_nDMATransfer
	and	eax, -65				; ffffffbfH
	mov	DWORD PTR _g_nDMATransfer, eax
$LN334@recExecute:

; 1769 : 	}
; 1770 : 
; 1771 : 	if( g_nDMATransfer & IPU_DMA_TIE1 ) {

	test	al, 4
	je	SHORT $LN333@recExecute

; 1772 : 		g_nDMATransfer &= ~IPU_DMA_TIE1;

	and	eax, -5					; fffffffbH
	mov	DWORD PTR _g_nDMATransfer, eax

; 1773 : 	}else

	jmp	SHORT $LN332@recExecute
$LN333@recExecute:

; 1774 : 		ipu1dma->chcr &= ~0x100;

	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
	and	DWORD PTR [eax+46080], -257		; fffffeffH
$LN332@recExecute:

; 1775 : 	
; 1776 : 	hwDmacIrq(DMAC_TO_IPU);

	mov	ecx, 4
	call	?hwDmacIrq@@YAXH@Z			; hwDmacIrq
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 356  : 	else

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	jmp	SHORT $LN340@recExecute
$LN324@recExecute:

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	eax, edi
	cmp	eax, esi
	jle	SHORT $LN340@recExecute

; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	eax, DWORD PTR [edi+esi]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
$LN340@recExecute:

; 349  : 	if( !(cpuRegs.interrupt & (1 << n)) ) return;

	test	ecx, 256				; 00000100H
	je	SHORT $LN352@recExecute

; 332  : 	return (int)(cpuRegs.cycle - startCycle) >= delta;

	mov	edi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+864
	mov	eax, edx
	mov	esi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+736
	sub	eax, edi
	cmp	eax, esi

; 350  : 
; 351  : 	if( cpuTestCycle( cpuRegs.sCycle[n], cpuRegs.eCycle[n] ) )

	jl	SHORT $LN344@recExecute

; 344  : 	cpuRegs.interrupt &= ~(1 << i);

	and	ecx, -257				; fffffeffH
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, ecx

; 352  : 	{
; 353  : 		cpuClearInt( n );
; 354  : 		callback();

	call	?SPRFROMinterrupt@@YAXXZ		; SPRFROMinterrupt

; 356  : 	else

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	jmp	SHORT $LN352@recExecute
$LN344@recExecute:

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	eax, edi
	cmp	eax, esi
	jle	SHORT $LN352@recExecute

; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	eax, DWORD PTR [edi+esi]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
$LN352@recExecute:

; 349  : 	if( !(cpuRegs.interrupt & (1 << n)) ) return;

	test	ecx, 512				; 00000200H
	je	SHORT $LN367@recExecute

; 332  : 	return (int)(cpuRegs.cycle - startCycle) >= delta;

	mov	edi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+868
	mov	eax, edx
	mov	esi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+740
	sub	eax, edi
	cmp	eax, esi

; 350  : 
; 351  : 	if( cpuTestCycle( cpuRegs.sCycle[n], cpuRegs.eCycle[n] ) )

	jl	SHORT $LN356@recExecute

; 344  : 	cpuRegs.interrupt &= ~(1 << i);

	and	ecx, -513				; fffffdffH
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, ecx
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\spr.cpp

; 448  : 	_dmaSPR1();

	call	?_dmaSPR1@@YAXXZ			; _dmaSPR1

; 449  : 	if( spr1finished == 0 ) return;

	cmp	DWORD PTR ?spr1finished@@3HA, 0		; spr1finished
	je	SHORT $LN488@recExecute

; 450  : 	spr1->chcr &= ~0x100;

	mov	eax, DWORD PTR ?psH@@3PAEA		; psH

; 451  : 	hwDmacIrq(9);

	mov	ecx, 9
	and	DWORD PTR [eax+54272], -257		; fffffeffH
	call	?hwDmacIrq@@YAXH@Z			; hwDmacIrq
$LN488@recExecute:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 356  : 	else

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	jmp	SHORT $LN367@recExecute
$LN356@recExecute:

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	eax, edi
	cmp	eax, esi
	jle	SHORT $LN367@recExecute

; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	eax, DWORD PTR [edi+esi]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
$LN367@recExecute:

; 349  : 	if( !(cpuRegs.interrupt & (1 << n)) ) return;

	test	ecx, 1024				; 00000400H
	je	SHORT $LN379@recExecute

; 332  : 	return (int)(cpuRegs.cycle - startCycle) >= delta;

	mov	edi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+872
	mov	eax, edx
	mov	esi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+744
	sub	eax, edi
	cmp	eax, esi

; 350  : 
; 351  : 	if( cpuTestCycle( cpuRegs.sCycle[n], cpuRegs.eCycle[n] ) )

	jl	SHORT $LN371@recExecute

; 344  : 	cpuRegs.interrupt &= ~(1 << i);

	and	ecx, -1025				; fffffbffH
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, ecx

; 352  : 	{
; 353  : 		cpuClearInt( n );
; 354  : 		callback();

	call	?vifMFIFOInterrupt@@YAXXZ		; vifMFIFOInterrupt

; 356  : 	else

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	jmp	SHORT $LN379@recExecute
$LN371@recExecute:

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	eax, edi
	cmp	eax, esi
	jle	SHORT $LN379@recExecute

; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	eax, DWORD PTR [edi+esi]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
$LN379@recExecute:

; 349  : 	if( !(cpuRegs.interrupt & (1 << n)) ) return;

	test	ecx, 2048				; 00000800H
	je	SHORT $LN391@recExecute

; 332  : 	return (int)(cpuRegs.cycle - startCycle) >= delta;

	mov	edi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+876
	sub	edx, edi
	mov	esi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+748
	cmp	edx, esi

; 350  : 
; 351  : 	if( cpuTestCycle( cpuRegs.sCycle[n], cpuRegs.eCycle[n] ) )

	jl	SHORT $LN383@recExecute

; 344  : 	cpuRegs.interrupt &= ~(1 << i);

	and	ecx, -2049				; fffff7ffH
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, ecx

; 352  : 	{
; 353  : 		cpuClearInt( n );
; 354  : 		callback();

	call	?gifMFIFOInterrupt@@YAXXZ		; gifMFIFOInterrupt

; 356  : 	else

	jmp	SHORT $LN391@recExecute
$LN383@recExecute:

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	eax, edi
	cmp	eax, esi
	jle	SHORT $LN391@recExecute

; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	eax, DWORD PTR [edi+esi]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
$LN391@recExecute:

; 467  : 		_cpuTestInterrupts();
; 468  : 
; 469  : 	// ---- IOP -------------
; 470  : 	// * It's important to run a psxBranchTest before calling ExecuteBlock. This
; 471  : 	//   is because the IOP does not always perform branch tests before returning
; 472  : 	//   (during the prev branch) and also so it can act on the state the EE has
; 473  : 	//   given it before executing any code.
; 474  : 	//
; 475  : 	// * The IOP cannot always be run.  If we run IOP code every time through the
; 476  : 	//   cpuBranchTest, the IOP generally starts to run way ahead of the EE.
; 477  : 
; 478  : 	psxBranchTest();

	call	?psxBranchTest@@YAXXZ			; psxBranchTest

; 479  : 
; 480  : 	if( iopBranchAction )

	cmp	BYTE PTR ?iopBranchAction@@3_NA, 0	; iopBranchAction
	je	SHORT $LN489@recExecute

; 481  : 	{
; 482  : 		//if( EEsCycle < -450 )
; 483  : 		//	Console::WriteLn( " IOP ahead by: %d cycles", params -EEsCycle );
; 484  : 
; 485  : 		// Experimental and Probably Unnecessry Logic -->
; 486  : 		// Check if the EE already has an exception pending, and if so we shouldn't
; 487  : 		// waste too much time updating the IOP.  Theory being that the EE and IOP should
; 488  : 		// run closely in sync during raised exception events.  But in practice it didn't
; 489  : 		// seem to make much of a difference.
; 490  : 
; 491  : 		// Note: The IOP is very good about chaining blocks together so it tends to
; 492  : 		// run lots of cycles, even with only 32 (4 IOP) cycles specified here.  That's
; 493  : 		// probably why it doesn't improve sync much.
; 494  : 
; 495  : 		/*bool eeExceptPending = cpuIntsEnabled() &&
; 496  : 			//( cpuRegs.CP0.n.Status.b.EIE && cpuRegs.CP0.n.Status.b.IE && (cpuRegs.CP0.n.Status.b.ERL == 0) ) &&
; 497  : 			//( (cpuRegs.CP0.n.Status.val & 0x10007) == 0x10001 ) &&
; 498  : 			( (cpuRegs.interrupt & (3<<30)) != 0 );
; 499  : 
; 500  : 		if( eeExceptPending )
; 501  : 		{
; 502  : 			// ExecuteBlock returns a negative value, so subtract it from the cycle count
; 503  : 			// specified to get the total cycles processed! :D
; 504  : 			int cycleCount = std::min( EEsCycle, (s32)(eeWaitCycles>>4) );
; 505  : 			int cyclesRun = cycleCount - psxCpu->ExecuteBlock( cycleCount );
; 506  : 			EEsCycle -= cyclesRun;
; 507  : 			//Console::Notice( "IOP Exception-Pending Execution -- EEsCycle: %d", params EEsCycle );
; 508  : 		}
; 509  : 		else*/
; 510  : 		{
; 511  : 			EEsCycle = psxCpu->ExecuteBlock( EEsCycle );

	mov	eax, DWORD PTR ?psxCpu@@3PAUR3000Acpu@@A ; psxCpu
	push	DWORD PTR ?EEsCycle@@3HA		; EEsCycle
	mov	eax, DWORD PTR [eax+12]
	call	eax
	add	esp, 4
	mov	DWORD PTR ?EEsCycle@@3HA, eax		; EEsCycle

; 512  : 		}
; 513  : 
; 514  : 		iopBranchAction = false;

	mov	BYTE PTR ?iopBranchAction@@3_NA, 0	; iopBranchAction
$LN489@recExecute:

; 515  : 	}
; 516  : 
; 517  : 	// ---- VU0 -------------
; 518  : 
; 519  : 	if (VU0.VI[REG_VPU_STAT].UL & 0x1)

	test	BYTE PTR ?VU0@@3UVURegs@@A+976, 1
	je	SHORT $LN492@recExecute

; 520  : 	{
; 521  : 		// We're in a BranchTest.  All dynarec registers are flushed
; 522  : 		// so there is no need to freeze registers here.
; 523  : 		CpuVU0.ExecuteBlock();

	call	DWORD PTR ?CpuVU0@@3UVUmicroCpu@@A+8

; 524  : 
; 525  : 		// This might be needed to keep the EE and VU0 in sync.
; 526  : 		// A better fix will require hefty changes to the VU recs. -_-
; 527  : 		if(VU0.VI[REG_VPU_STAT].UL & 0x1)

	test	BYTE PTR ?VU0@@3UVURegs@@A+976, 1

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	ecx, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960

; 524  : 
; 525  : 		// This might be needed to keep the EE and VU0 in sync.
; 526  : 		// A better fix will require hefty changes to the VU recs. -_-
; 527  : 		if(VU0.VI[REG_VPU_STAT].UL & 0x1)

	je	SHORT $LN396@recExecute

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, ecx
	sub	eax, edx
	cmp	eax, 768				; 00000300H
	jle	SHORT $LN396@recExecute

; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	ecx, DWORD PTR [edx+768]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
	jmp	SHORT $LN396@recExecute
$LN492@recExecute:
	mov	ecx, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
$LN396@recExecute:

; 528  : 			cpuSetNextBranchDelta( 768 );
; 529  : 	}
; 530  : 
; 531  : 	// Note:  We don't update the VU1 here because it runs it's micro-programs in
; 532  : 	// one shot always.  That is, when a program is executed the VU1 doesn't even
; 533  : 	// bother to return until the program is completely finished.
; 534  : 
; 535  : 	// ---- Schedule Next Event Test --------------
; 536  : 
; 537  : 	if( EEsCycle > 192 )

	cmp	DWORD PTR ?EEsCycle@@3HA, 192		; EEsCycle, 000000c0H
	jle	SHORT $LN401@recExecute

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, ecx
	sub	eax, edx
	cmp	eax, 48					; 00000030H
	jle	SHORT $LN401@recExecute

; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	ecx, DWORD PTR [edx+48]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
$LN401@recExecute:

; 538  : 	{
; 539  : 		// EE's running way ahead of the IOP still, so we should branch quickly to give the
; 540  : 		// IOP extra timeslices in short order.
; 541  : 
; 542  : 		cpuSetNextBranchDelta( 48 );
; 543  : 		//Console::Notice( "EE ahead of the IOP -- Rapid Branch!  %d", params EEsCycle );
; 544  : 	}
; 545  : 
; 546  : 	// The IOP could be running ahead/behind of us, so adjust the iop's next branch by its
; 547  : 	// relative position to the EE (via EEsCycle)
; 548  : 	cpuSetNextBranchDelta( ((g_psxNextBranchCycle-psxRegs.cycle)*8) - EEsCycle );

	mov	esi, DWORD PTR ?g_psxNextBranchCycle@@3IA ; g_psxNextBranchCycle

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, ecx

; 538  : 	{
; 539  : 		// EE's running way ahead of the IOP still, so we should branch quickly to give the
; 540  : 		// IOP extra timeslices in short order.
; 541  : 
; 542  : 		cpuSetNextBranchDelta( 48 );
; 543  : 		//Console::Notice( "EE ahead of the IOP -- Rapid Branch!  %d", params EEsCycle );
; 544  : 	}
; 545  : 
; 546  : 	// The IOP could be running ahead/behind of us, so adjust the iop's next branch by its
; 547  : 	// relative position to the EE (via EEsCycle)
; 548  : 	cpuSetNextBranchDelta( ((g_psxNextBranchCycle-psxRegs.cycle)*8) - EEsCycle );

	sub	esi, DWORD PTR ?psxRegs@@3UpsxRegisters@@A+528

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	sub	eax, edx

; 538  : 	{
; 539  : 		// EE's running way ahead of the IOP still, so we should branch quickly to give the
; 540  : 		// IOP extra timeslices in short order.
; 541  : 
; 542  : 		cpuSetNextBranchDelta( 48 );
; 543  : 		//Console::Notice( "EE ahead of the IOP -- Rapid Branch!  %d", params EEsCycle );
; 544  : 	}
; 545  : 
; 546  : 	// The IOP could be running ahead/behind of us, so adjust the iop's next branch by its
; 547  : 	// relative position to the EE (via EEsCycle)
; 548  : 	cpuSetNextBranchDelta( ((g_psxNextBranchCycle-psxRegs.cycle)*8) - EEsCycle );

	shl	esi, 3
	sub	esi, DWORD PTR ?EEsCycle@@3HA		; EEsCycle

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	cmp	eax, esi
	jle	SHORT $LN406@recExecute

; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	ecx, DWORD PTR [edx+esi]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
$LN406@recExecute:

; 549  : 
; 550  : 	// Apply the hsync counter's nextCycle
; 551  : 	cpuSetNextBranch( counters[4].sCycle, counters[4].CycleT );

	mov	edi, DWORD PTR ?counters@@3PAUCounter@@A+188

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, ecx

; 549  : 
; 550  : 	// Apply the hsync counter's nextCycle
; 551  : 	cpuSetNextBranch( counters[4].sCycle, counters[4].CycleT );

	mov	esi, DWORD PTR ?counters@@3PAUCounter@@A+192

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	sub	eax, edi
	cmp	eax, esi
	jle	SHORT $LN409@recExecute

; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	ecx, DWORD PTR [edi+esi]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
$LN409@recExecute:

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	esi, DWORD PTR ?nextsCounter@@3IA	; nextsCounter
	mov	eax, ecx
	mov	edi, DWORD PTR ?nextCounter@@3HA	; nextCounter
	sub	eax, esi
	cmp	eax, edi
	jle	SHORT $LN412@recExecute

; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	ecx, DWORD PTR [esi+edi]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
$LN412@recExecute:

; 421  : 	}
; 422  : }
; 423  : 
; 424  : // Checks the COP0.Status for exception enablings.
; 425  : // Exception handling for certain modes is *not* currently supported, this function filters
; 426  : // them out.  Exceptions while the exception handler is active (EIE), or exceptions of any
; 427  : // level other than 0 are ignored here.
; 428  : 
; 429  : static bool cpuIntsEnabled()
; 430  : {
; 431  : 	return cpuRegs.CP0.n.Status.b.EIE && cpuRegs.CP0.n.Status.b.IE && 
; 432  : 		!cpuRegs.CP0.n.Status.b.EXL && (cpuRegs.CP0.n.Status.b.ERL == 0);

	test	BYTE PTR ?cpuRegs@@3UcpuRegisters@@A+594, 1

; 552  : 
; 553  : 	// Apply vsync and other counter nextCycles
; 554  : 	cpuSetNextBranch( nextsCounter, nextCounter );
; 555  : 
; 556  : 	eeEventTestIsActive = false;

	mov	BYTE PTR ?eeEventTestIsActive@@3_NA, 0	; eeEventTestIsActive

; 421  : 	}
; 422  : }
; 423  : 
; 424  : // Checks the COP0.Status for exception enablings.
; 425  : // Exception handling for certain modes is *not* currently supported, this function filters
; 426  : // them out.  Exceptions while the exception handler is active (EIE), or exceptions of any
; 427  : // level other than 0 are ignored here.
; 428  : 
; 429  : static bool cpuIntsEnabled()
; 430  : {
; 431  : 	return cpuRegs.CP0.n.Status.b.EIE && cpuRegs.CP0.n.Status.b.IE && 
; 432  : 		!cpuRegs.CP0.n.Status.b.EXL && (cpuRegs.CP0.n.Status.b.ERL == 0);

	je	$LN455@recExecute
	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+592
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A$7[ebp], eax
	test	al, 1
	je	$LN455@recExecute
	test	al, 6
	jne	$LN455@recExecute

; 349  : 	if( !(cpuRegs.interrupt & (1 << n)) ) return;

	mov	esi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
	test	esi, 1073741824				; 40000000H
	je	$LN502@recExecute

; 332  : 	return (int)(cpuRegs.cycle - startCycle) >= delta;

	mov	edi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+824
	mov	eax, edx
	sub	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+952
	cmp	eax, edi

; 350  : 
; 351  : 	if( cpuTestCycle( cpuRegs.sCycle[n], cpuRegs.eCycle[n] ) )

	jl	$LN420@recExecute
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp

; 76   : 	if ((cpuRegs.CP0.n.Status.val & 0x400) != 0x400) return;

	mov	edi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A$7[ebp]
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 344  : 	cpuRegs.interrupt &= ~(1 << i);

	and	esi, -1073741825			; bfffffffH
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, esi
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp

; 76   : 	if ((cpuRegs.CP0.n.Status.val & 0x400) != 0x400) return;

	test	edi, 1024				; 00000400H
	je	$LN493@recExecute

; 77   : 
; 78   : 	if ((psHu32(INTC_STAT)) == 0) {

	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
	cmp	DWORD PTR [eax+61440], 0
	jne	SHORT $LN430@recExecute

; 79   : 		DevCon::Notice("*PCSX2*: intcInterrupt already cleared");

	mov	ecx, OFFSET ??_C@_0CH@FCDDAIFJ@?$CKPCSX2?$CK?3?5intcInterrupt?5already?5c@
	call	?Notice@Console@@YA_NPBD@Z		; Console::Notice
$LN512@recExecute:

; 80   :         return;

	mov	ecx, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	mov	esi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	edi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+592
	jmp	$LN493@recExecute
$LN430@recExecute:

; 81   : 	}
; 82   : 	if ((psHu32(INTC_STAT) & psHu32(INTC_MASK)) == 0) return;

	mov	esi, DWORD PTR [eax+61456]
	and	esi, DWORD PTR [eax+61440]
	mov	DWORD PTR tv3181[ebp], esi
	mov	esi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
	je	SHORT $LN435@recExecute

; 83   : 
; 84   : 	HW_LOG("intcInterrupt %x\n", psHu32(INTC_STAT) & psHu32(INTC_MASK));

	test	BYTE PTR ?varLog@@3IA, 4
	je	SHORT $LN434@recExecute
	push	DWORD PTR tv3181[ebp]
	push	OFFSET ??_C@_0BC@LCGONOKJ@intcInterrupt?5?$CFx?6?$AA@
	call	?SrcLog_HW@@YA_NPBDZZ			; SrcLog_HW
	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
	add	esp, 8
$LN434@recExecute:

; 85   : 	if(psHu32(INTC_STAT) & 0x2){

	test	BYTE PTR [eax+61440], 2
	je	SHORT $LN428@recExecute

; 86   : 		counters[0].hold = rcntRcount(0);

	xor	ecx, ecx
	call	?rcntRcount@@YIIH@Z			; rcntRcount

; 87   : 		counters[1].hold = rcntRcount(1);

	mov	ecx, 1
	mov	DWORD PTR ?counters@@3PAUCounter@@A+12, eax
	call	?rcntRcount@@YIIH@Z			; rcntRcount
	mov	DWORD PTR ?counters@@3PAUCounter@@A+52, eax
$LN428@recExecute:

; 88   : 	}
; 89   : 
; 90   : 	cpuException(0x400, cpuRegs.branch);

	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+968
	mov	ecx, 1024				; 00000400H
	call	?cpuException@@YAXII@Z			; cpuException
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 356  : 	else

	jmp	$LN512@recExecute
$LN420@recExecute:

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, ecx
	sub	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+952
	cmp	eax, edi
	jle	SHORT $LN502@recExecute

; 313  : 		g_nextBranchCycle = startCycle + delta;

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+952
	add	ecx, edi
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
$LN502@recExecute:
	mov	edi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A$7[ebp]
$LN493@recExecute:
	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
$LN435@recExecute:

; 349  : 	if( !(cpuRegs.interrupt & (1 << n)) ) return;

	test	esi, esi
	jns	$LN455@recExecute

; 332  : 	return (int)(cpuRegs.cycle - startCycle) >= delta;

	sub	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+956
	cmp	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+828

; 350  : 
; 351  : 	if( cpuTestCycle( cpuRegs.sCycle[n], cpuRegs.eCycle[n] ) )

	jl	SHORT $LN439@recExecute

; 344  : 	cpuRegs.interrupt &= ~(1 << i);

	and	esi, 2147483647				; 7fffffffH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp

; 95   :     if ((cpuRegs.CP0.n.Status.val & 0x10807) != 0x10801) return;

	and	edi, 67591				; 00010807H
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 344  : 	cpuRegs.interrupt &= ~(1 << i);

	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, esi
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp

; 95   :     if ((cpuRegs.CP0.n.Status.val & 0x10807) != 0x10801) return;

	cmp	edi, 67585				; 00010801H
	jne	SHORT $LN455@recExecute

; 96   : 
; 97   : 	if( ((psHu16(0xe012) & psHu16(0xe010)) == 0 ) && 
; 98   : 		( psHu16(0xe010) & 0x8000) == 0 ) return;

	movzx	ecx, WORD PTR [eax+57360]
	mov	dx, WORD PTR [eax+57362]
	and	dx, cx
	jne	SHORT $LN448@recExecute
	test	ecx, 32768				; 00008000H
	je	SHORT $LN455@recExecute
$LN448@recExecute:

; 99   : 
; 100  : 	if((psHu32(DMAC_CTRL) & 0x1) == 0) return;

	test	BYTE PTR [eax+57344], 1
	je	SHORT $LN455@recExecute

; 101  : 	
; 102  : 	HW_LOG("dmacInterrupt %x\n", (psHu16(0xe012) & psHu16(0xe010) || 
; 103  : 								  psHu16(0xe010) & 0x8000));

	test	BYTE PTR ?varLog@@3IA, 4
	je	SHORT $LN454@recExecute
	test	dx, dx
	jne	SHORT $LN452@recExecute
	test	ecx, 32768				; 00008000H
	jne	SHORT $LN452@recExecute
	xor	eax, eax
	jmp	SHORT $LN453@recExecute
$LN452@recExecute:
	mov	eax, 1
$LN453@recExecute:
	push	eax
	push	OFFSET ??_C@_0BC@IOCBKJEO@dmacInterrupt?5?$CFx?6?$AA@
	call	?SrcLog_HW@@YA_NPBDZZ			; SrcLog_HW
	add	esp, 8
$LN454@recExecute:

; 104  : 
; 105  : 	cpuException(0x800, cpuRegs.branch);

	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+968
	mov	ecx, 2048				; 00000800H
	call	?cpuException@@YAXII@Z			; cpuException
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 356  : 	else

	jmp	SHORT $LN455@recExecute
$LN439@recExecute:

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+956
	sub	ecx, edx
	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+828
	cmp	ecx, eax
	jle	SHORT $LN455@recExecute

; 313  : 		g_nextBranchCycle = startCycle + delta;

	add	eax, edx
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
$LN455@recExecute:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 795  : 	while( !recEventTest() );

	cmp	BYTE PTR _vsyncEvent$1$[ebp], 0
	je	$LL3@recExecute

; 796  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
?recExecute@@YAXXZ ENDP					; recExecute
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\icore.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ifpu.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ifpu.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ifpu.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
_TEXT	SEGMENT
?recBREAK@OpcodeImpl@Dynarec@R5900@@YAXXZ PROC		; R5900::Dynarec::OpcodeImpl::recBREAK
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	ecx, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 898  : 	MOV32ItoM( (uptr)&cpuRegs.code, cpuRegs.code );

	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+684
	push	ebx
	push	esi
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	WORD PTR [ecx], 1479			; 000005c7H

; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [ecx+2], OFFSET ?cpuRegs@@3UcpuRegisters@@A+684
	mov	DWORD PTR [ecx+6], eax

; 1739 : 	*x86Ptr = (u8)val; 

	mov	WORD PTR [ecx+10], 1479			; 000005c7H
	push	edi

; 1761 : 	*(u32*)x86Ptr = val; 

	mov	edi, DWORD PTR ?pc@@3IA			; pc
	mov	DWORD PTR [ecx+12], OFFSET ?cpuRegs@@3UcpuRegisters@@A+680
	mov	DWORD PTR [ecx+16], edi

; 1762 : 	x86Ptr += 4; 

	add	ecx, 20					; 00000014H
	mov	DWORD PTR ?x86Ptr@@3PAEA, ecx		; x86Ptr
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1130 : 	_freeX86regs();

	call	?_freeX86regs@@YAXXZ			; _freeX86regs
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\icore.cpp

; 992  : 	for (i=0; i<XMMREGS; i++) {

	xor	esi, esi
$LL42@recBREAK:

; 993  : 		if (xmmregs[i].inuse == 0) continue;

	cmp	BYTE PTR ?xmmregs@@3PAU_xmmregs@@A[esi*8], 0
	je	SHORT $LN41@recBREAK

; 994  : 
; 995  : 		assert( xmmregs[i].type != XMMTYPE_TEMP );
; 996  : 		//assert( xmmregs[i].mode & (MODE_READ|MODE_WRITE) );
; 997  : 
; 998  : 		_freeXMMreg(i);

	mov	ecx, esi
	call	?_freeXMMreg@@YAXH@Z			; _freeXMMreg
$LN41@recBREAK:

; 992  : 	for (i=0; i<XMMREGS; i++) {

	inc	esi
	cmp	esi, 8
	jl	SHORT $LL42@recBREAK
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1143 : 		_flushConstRegs();

	call	?_freeMMXregs@@YAXXZ			; _freeMMXregs
	call	?_flushConstRegs@@YAXXZ			; _flushConstRegs
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ifpu.cpp

; 52   : 	if (iCWstate == 0) return;

	mov	ax, WORD PTR ?iCWstate@@3GA		; iCWstate
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	ebx, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ifpu.cpp

; 52   : 	if (iCWstate == 0) return;

	test	ax, ax
	je	SHORT $LN48@recBREAK

; 53   : 
; 54   : 	if (iCWstate & 2) {
; 55   : 		//SSE_LDMXCSR((uptr)&_mxcsrs);
; 56   : 	}
; 57   : 	if (iCWstate & 1) {

	test	al, 1
	je	SHORT $LN58@recBREAK
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	WORD PTR [ebx], 11737			; 00002dd9H

; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [ebx+2], OFFSET _fpucws

; 1762 : 	x86Ptr += 4; 

	add	ebx, 6
$LN58@recBREAK:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ifpu.cpp

; 60   : 	iCWstate = 0;

	xor	eax, eax
	mov	WORD PTR ?iCWstate@@3GA, ax		; iCWstate
$LN48@recBREAK:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1147 : 	if (x86FpuState==MMX_STATE) {

	cmp	WORD PTR ?x86FpuState@@3GA, 1		; x86FpuState
	jne	SHORT $LN29@recBREAK

; 1148 : 		if (cpucaps.has3DNOWInstructionExtensions) FEMMS();

	cmp	DWORD PTR ?cpucaps@@3UCAPABILITIES@@A+136, 0
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1745 : 	*(u16*)x86Ptr = (u16)val; 

	mov	eax, 3599				; 00000e0fH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1148 : 		if (cpucaps.has3DNOWInstructionExtensions) FEMMS();

	jne	SHORT $LN122@recBREAK
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1745 : 	*(u16*)x86Ptr = (u16)val; 

	mov	eax, 30479				; 0000770fH
$LN122@recBREAK:
	mov	WORD PTR [ebx], ax

; 1746 : 	x86Ptr += 2;  

	add	ebx, 2
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1150 : 		x86FpuState=FPU_STATE;

	xor	eax, eax
	mov	WORD PTR ?x86FpuState@@3GA, ax		; x86FpuState
$LN29@recBREAK:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp

; 2855 : 	func -= ( (uptr)x86Ptr + 5 );

	mov	eax, OFFSET ?BREAK@OpcodeImpl@Interpreter@R5900@@YAXXZ ; R5900::Interpreter::OpcodeImpl::BREAK
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	BYTE PTR [ebx], 232			; 000000e8H
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp

; 2855 : 	func -= ( (uptr)x86Ptr + 5 );

	sub	eax, ebx

; 142  : 	return (u8*)(x86Ptr - 1);

	lea	esi, DWORD PTR [ebx+16]

; 2855 : 	func -= ( (uptr)x86Ptr + 5 );

	sub	eax, 5
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 904  : 	j8Ptr[0] = JE8(0);

	mov	DWORD PTR ?j8Ptr@@3PAPAEA, esi
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [ebx+1], eax

; 1739 : 	*x86Ptr = (u8)val; 

	mov	WORD PTR [ebx+5], 15745			; 00003d81H

; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [ebx+7], OFFSET ?cpuRegs@@3UcpuRegisters@@A+680
	mov	DWORD PTR [ebx+11], edi

; 1739 : 	*x86Ptr = (u8)val; 

	mov	WORD PTR [ebx+15], 116			; 00000074H
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 905  : 	ADD32ItoM((uptr)&cpuRegs.cycle, eeScaleBlockCycles());

	call	?eeScaleBlockCycles@@YAIXZ		; eeScaleBlockCycles
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	WORD PTR [ebx+17], 1409			; 00000581H

; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [ebx+19], OFFSET ?cpuRegs@@3UcpuRegisters@@A+960
	mov	DWORD PTR [ebx+23], eax

; 1739 : 	*x86Ptr = (u8)val; 

	mov	BYTE PTR [ebx+27], 195			; 000000c3H

; 1740 : 	x86Ptr++; 

	add	ebx, 28					; 0000001cH
	mov	DWORD PTR ?x86Ptr@@3PAEA, ebx		; x86Ptr
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp

; 192  : 	u32 jump = ( x86Ptr - j8 ) - 1;

	sub	ebx, esi
	dec	ebx

; 193  : 
; 194  : 	if ( jump > 0x7f ) {

	cmp	ebx, 127				; 0000007fH
	jbe	SHORT $LN119@recBREAK

; 195  : 		Console::Error( "j8 greater than 0x7f!!" );

	mov	ecx, OFFSET ??_C@_0BH@PGICDMIF@j8?5greater?5than?50x7f?$CB?$CB?$AA@
	call	?Error@Console@@YA_NPBD@Z		; Console::Error
$LN119@recBREAK:
	pop	edi

; 196  : 		assert(0);
; 197  : 	}
; 198  : 	*j8 = (u8)jump;

	mov	BYTE PTR [esi], bl
	pop	esi
	pop	ebx
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 909  : }

	ret	0
?recBREAK@OpcodeImpl@Dynarec@R5900@@YAXXZ ENDP		; R5900::Dynarec::OpcodeImpl::recBREAK
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ifpu.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ifpu.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ifpu.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
_TEXT	SEGMENT
?recSYSCALL@OpcodeImpl@Dynarec@R5900@@YAXXZ PROC	; R5900::Dynarec::OpcodeImpl::recSYSCALL
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	ecx, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 883  : 	MOV32ItoM( (uptr)&cpuRegs.code, cpuRegs.code );

	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+684
	push	ebx
	push	esi
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1761 : 	*(u32*)x86Ptr = val; 

	mov	esi, DWORD PTR ?pc@@3IA			; pc

; 1739 : 	*x86Ptr = (u8)val; 

	mov	WORD PTR [ecx], 1479			; 000005c7H

; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [ecx+2], OFFSET ?cpuRegs@@3UcpuRegisters@@A+684
	mov	DWORD PTR [ecx+6], eax

; 1739 : 	*x86Ptr = (u8)val; 

	mov	WORD PTR [ecx+10], 1479			; 000005c7H

; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [ecx+12], OFFSET ?cpuRegs@@3UcpuRegisters@@A+680
	mov	DWORD PTR [ecx+16], esi

; 1762 : 	x86Ptr += 4; 

	add	ecx, 20					; 00000014H
	mov	DWORD PTR ?x86Ptr@@3PAEA, ecx		; x86Ptr
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1130 : 	_freeX86regs();

	call	?_freeX86regs@@YAXXZ			; _freeX86regs

; 1131 : 
; 1132 : 	if( flushtype & FLUSH_FREE_XMM )
; 1133 : 		_freeXMMregs();
; 1134 : 	else if( flushtype & FLUSH_FLUSH_XMM)
; 1135 : 		_flushXMMregs();

	call	?_flushXMMregs@@YAXXZ			; _flushXMMregs

; 1136 : 
; 1137 : 	if( flushtype & FLUSH_FREE_MMX )
; 1138 : 		_freeMMXregs();
; 1139 : 	else if( flushtype & FLUSH_FLUSH_MMX)
; 1140 : 		_flushMMXregs();

	call	?_flushMMXregs@@YAXXZ			; _flushMMXregs

; 1141 : 
; 1142 : 	if( flushtype & FLUSH_CACHED_REGS )
; 1143 : 		_flushConstRegs();

	call	?_flushConstRegs@@YAXXZ			; _flushConstRegs
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ifpu.cpp

; 52   : 	if (iCWstate == 0) return;

	mov	ax, WORD PTR ?iCWstate@@3GA		; iCWstate
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	ebx, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ifpu.cpp

; 52   : 	if (iCWstate == 0) return;

	test	ax, ax
	je	SHORT $LN48@recSYSCALL

; 53   : 
; 54   : 	if (iCWstate & 2) {
; 55   : 		//SSE_LDMXCSR((uptr)&_mxcsrs);
; 56   : 	}
; 57   : 	if (iCWstate & 1) {

	test	al, 1
	je	SHORT $LN58@recSYSCALL
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	WORD PTR [ebx], 11737			; 00002dd9H

; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [ebx+2], OFFSET _fpucws

; 1762 : 	x86Ptr += 4; 

	add	ebx, 6
$LN58@recSYSCALL:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ifpu.cpp

; 60   : 	iCWstate = 0;

	xor	eax, eax
	mov	WORD PTR ?iCWstate@@3GA, ax		; iCWstate
$LN48@recSYSCALL:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1147 : 	if (x86FpuState==MMX_STATE) {

	cmp	WORD PTR ?x86FpuState@@3GA, 1		; x86FpuState
	jne	SHORT $LN29@recSYSCALL

; 1148 : 		if (cpucaps.has3DNOWInstructionExtensions) FEMMS();

	cmp	DWORD PTR ?cpucaps@@3UCAPABILITIES@@A+136, 0
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1745 : 	*(u16*)x86Ptr = (u16)val; 

	mov	eax, 3599				; 00000e0fH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1148 : 		if (cpucaps.has3DNOWInstructionExtensions) FEMMS();

	jne	SHORT $LN124@recSYSCALL
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1745 : 	*(u16*)x86Ptr = (u16)val; 

	mov	eax, 30479				; 0000770fH
$LN124@recSYSCALL:
	mov	WORD PTR [ebx], ax

; 1746 : 	x86Ptr += 2;  

	add	ebx, 2
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1150 : 		x86FpuState=FPU_STATE;

	xor	eax, eax
	mov	WORD PTR ?x86FpuState@@3GA, ax		; x86FpuState
$LN29@recSYSCALL:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp

; 2855 : 	func -= ( (uptr)x86Ptr + 5 );

	mov	eax, OFFSET ?SYSCALL@OpcodeImpl@Interpreter@R5900@@YAXXZ ; R5900::Interpreter::OpcodeImpl::SYSCALL
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	BYTE PTR [ebx], 232			; 000000e8H
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp

; 2855 : 	func -= ( (uptr)x86Ptr + 5 );

	sub	eax, ebx
	sub	eax, 5
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [ebx+1], eax

; 1739 : 	*x86Ptr = (u8)val; 

	mov	WORD PTR [ebx+5], 15745			; 00003d81H

; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [ebx+7], OFFSET ?cpuRegs@@3UcpuRegisters@@A+680
	mov	DWORD PTR [ebx+11], esi
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp

; 142  : 	return (u8*)(x86Ptr - 1);

	lea	esi, DWORD PTR [ebx+16]
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	WORD PTR [ebx+15], 116			; 00000074H
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 889  : 	j8Ptr[0] = JE8(0);

	mov	DWORD PTR ?j8Ptr@@3PAPAEA, esi

; 890  : 	ADD32ItoM((uptr)&cpuRegs.cycle, eeScaleBlockCycles());

	call	?eeScaleBlockCycles@@YAIXZ		; eeScaleBlockCycles
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	WORD PTR [ebx+17], 1409			; 00000581H

; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [ebx+19], OFFSET ?cpuRegs@@3UcpuRegisters@@A+960
	mov	DWORD PTR [ebx+23], eax

; 1762 : 	x86Ptr += 4; 

	add	ebx, 27					; 0000001bH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 891  : 	JMP32((uptr)DispatcherReg - ( (uptr)x86Ptr + 5 ));

	mov	eax, OFFSET ?DispatcherReg@@YAXXZ	; DispatcherReg
	sub	eax, ebx
	sub	eax, 5
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	BYTE PTR [ebx], 233			; 000000e9H

; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [ebx+1], eax

; 1762 : 	x86Ptr += 4; 

	add	ebx, 5
	mov	DWORD PTR ?x86Ptr@@3PAEA, ebx		; x86Ptr
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp

; 192  : 	u32 jump = ( x86Ptr - j8 ) - 1;

	sub	ebx, esi
	dec	ebx

; 193  : 
; 194  : 	if ( jump > 0x7f ) {

	cmp	ebx, 127				; 0000007fH
	jbe	SHORT $LN121@recSYSCALL

; 195  : 		Console::Error( "j8 greater than 0x7f!!" );

	mov	ecx, OFFSET ??_C@_0BH@PGICDMIF@j8?5greater?5than?50x7f?$CB?$CB?$AA@
	call	?Error@Console@@YA_NPBD@Z		; Console::Error
$LN121@recSYSCALL:

; 196  : 		assert(0);
; 197  : 	}
; 198  : 	*j8 = (u8)jump;

	mov	BYTE PTR [esi], bl
	pop	esi
	pop	ebx
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 894  : }

	ret	0
?recSYSCALL@OpcodeImpl@Dynarec@R5900@@YAXXZ ENDP	; R5900::Dynarec::OpcodeImpl::recSYSCALL
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86_sse.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\icore.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
_TEXT	SEGMENT
?_eeMoveGPRtoM@@YAXIH@Z PROC				; _eeMoveGPRtoM
; _to$ = ecx
; _fromgpr$ = edx

; 366  : {

	push	ebx
	push	esi
	mov	esi, edx

; 367  : 	if( GPR_IS_CONST1(fromgpr) )

	mov	ebx, 1
	push	edi
	mov	edi, ecx
	cmp	esi, 32					; 00000020H
	jge	SHORT $LN6@eeMoveGPRt
	mov	eax, ebx
	mov	ecx, esi
	shl	eax, cl
	test	DWORD PTR ?g_cpuHasConstReg@@3IA, eax	; g_cpuHasConstReg
	je	SHORT $LN6@eeMoveGPRt
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	ecx, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 368  : 		MOV32ItoM( to, g_cpuConstRegs[fromgpr].UL[0] );

	shl	esi, 4
	mov	eax, DWORD PTR ?g_cpuConstRegs@@3PATGPR_reg64@@A[esi]
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	WORD PTR [ecx], 1479			; 000005c7H

; 1746 : 	x86Ptr += 2;  
; 1747 : } 
; 1748 : 
; 1749 : __forceinline void write24(u32 val ) 
; 1750 : { 
; 1751 : 	*(u8*)x86Ptr = (u8)(val & 0xff); 
; 1752 : 	x86Ptr++;  
; 1753 : 	*(u8*)x86Ptr = (u8)((val >> 8) & 0xff); 
; 1754 : 	x86Ptr++;  
; 1755 : 	*(u8*)x86Ptr = (u8)((val >> 16) & 0xff); 
; 1756 : 	x86Ptr++;  
; 1757 : } 
; 1758 : 
; 1759 : __forceinline void write32(u32 val ) 
; 1760 : { 
; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [ecx+2], edi
	pop	edi
	mov	DWORD PTR [ecx+6], eax

; 1762 : 	x86Ptr += 4; 

	add	ecx, 10					; 0000000aH
	pop	esi
	mov	DWORD PTR ?x86Ptr@@3PAEA, ecx		; x86Ptr
	pop	ebx
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 384  : }

	ret	0
$LN6@eeMoveGPRt:

; 369  : 	else {
; 370  : 		int mmreg;
; 371  : 		
; 372  : 		if( (mmreg = _checkXMMreg(XMMTYPE_GPRREG, fromgpr, MODE_READ)) >= 0 ) {

	push	1
	mov	ecx, 5
	call	?_checkXMMreg@@YAHHHH@Z			; _checkXMMreg
	mov	edx, eax
	add	esp, 4
	test	edx, edx
	js	SHORT $LN4@eeMoveGPRt
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86_sse.cpp

; 1334 : 	if( g_xmmtypes[from] == XMMT_INT ) SSE2_MOVD_XMM_to_M32(to, from);

	cmp	DWORD PTR ?g_xmmtypes@@3PAW4XMMSSEType@@A[edx*4], 0
	jne	SHORT $LN22@eeMoveGPRt
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	ecx, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
	and	dl, 7
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp

; 122  : 	write8( ( mod << 6 ) | ( (reg & 7) << 3 ) | ( rm & 7 ) );

	shl	dl, 3
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1745 : 	*(u16*)x86Ptr = (u16)val; 

	mov	eax, 32271				; 00007e0fH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp

; 122  : 	write8( ( mod << 6 ) | ( (reg & 7) << 3 ) | ( rm & 7 ) );

	or	dl, 5
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	BYTE PTR [ecx], 102			; 00000066H

; 1745 : 	*(u16*)x86Ptr = (u16)val; 

	mov	WORD PTR [ecx+1], ax

; 1739 : 	*x86Ptr = (u8)val; 

	mov	BYTE PTR [ecx+3], dl

; 1746 : 	x86Ptr += 2;  
; 1747 : } 
; 1748 : 
; 1749 : __forceinline void write24(u32 val ) 
; 1750 : { 
; 1751 : 	*(u8*)x86Ptr = (u8)(val & 0xff); 
; 1752 : 	x86Ptr++;  
; 1753 : 	*(u8*)x86Ptr = (u8)((val >> 8) & 0xff); 
; 1754 : 	x86Ptr++;  
; 1755 : 	*(u8*)x86Ptr = (u8)((val >> 16) & 0xff); 
; 1756 : 	x86Ptr++;  
; 1757 : } 
; 1758 : 
; 1759 : __forceinline void write32(u32 val ) 
; 1760 : { 
; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [ecx+4], edi

; 1762 : 	x86Ptr += 4; 

	add	ecx, 8
	pop	edi
	pop	esi
	mov	DWORD PTR ?x86Ptr@@3PAEA, ecx		; x86Ptr
	pop	ebx
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 384  : }

	ret	0
$LN22@eeMoveGPRt:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	eax, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
	and	dl, 7
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp

; 122  : 	write8( ( mod << 6 ) | ( (reg & 7) << 3 ) | ( rm & 7 ) );

	shl	dl, 3
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1745 : 	*(u16*)x86Ptr = (u16)val; 

	mov	ecx, 4367				; 0000110fH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp

; 122  : 	write8( ( mod << 6 ) | ( (reg & 7) << 3 ) | ( rm & 7 ) );

	or	dl, 5
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	BYTE PTR [eax], 243			; 000000f3H

; 1745 : 	*(u16*)x86Ptr = (u16)val; 

	mov	WORD PTR [eax+1], cx

; 1739 : 	*x86Ptr = (u8)val; 

	mov	BYTE PTR [eax+3], dl

; 1746 : 	x86Ptr += 2;  
; 1747 : } 
; 1748 : 
; 1749 : __forceinline void write24(u32 val ) 
; 1750 : { 
; 1751 : 	*(u8*)x86Ptr = (u8)(val & 0xff); 
; 1752 : 	x86Ptr++;  
; 1753 : 	*(u8*)x86Ptr = (u8)((val >> 8) & 0xff); 
; 1754 : 	x86Ptr++;  
; 1755 : 	*(u8*)x86Ptr = (u8)((val >> 16) & 0xff); 
; 1756 : 	x86Ptr++;  
; 1757 : } 
; 1758 : 
; 1759 : __forceinline void write32(u32 val ) 
; 1760 : { 
; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [eax+4], edi

; 1762 : 	x86Ptr += 4; 

	add	eax, 8
	pop	edi
	pop	esi
	mov	DWORD PTR ?x86Ptr@@3PAEA, eax		; x86Ptr
	pop	ebx
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 384  : }

	ret	0
$LN4@eeMoveGPRt:

; 373  : 			SSEX_MOVD_XMM_to_M32(to, mmreg);
; 374  : 		}
; 375  : 		else if( (mmreg = _checkMMXreg(MMX_GPR+fromgpr, MODE_READ)) >= 0 ) {

	mov	edx, ebx
	mov	ecx, esi
	call	?_checkMMXreg@@YAHHH@Z			; _checkMMXreg
	test	eax, eax
	js	SHORT $LN2@eeMoveGPRt
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1745 : 	*(u16*)x86Ptr = (u16)val; 

	mov	ecx, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr

; 1739 : 	*x86Ptr = (u8)val; 

	and	al, 7
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp

; 122  : 	write8( ( mod << 6 ) | ( (reg & 7) << 3 ) | ( rm & 7 ) );

	shl	al, 3
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1745 : 	*(u16*)x86Ptr = (u16)val; 

	mov	edx, 32271				; 00007e0fH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp

; 122  : 	write8( ( mod << 6 ) | ( (reg & 7) << 3 ) | ( rm & 7 ) );

	or	al, 5
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\icore.cpp

; 1135 : 	x86FpuState = MMX_STATE;

	mov	WORD PTR ?x86FpuState@@3GA, bx		; x86FpuState
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1745 : 	*(u16*)x86Ptr = (u16)val; 

	mov	WORD PTR [ecx], dx

; 1739 : 	*x86Ptr = (u8)val; 

	mov	BYTE PTR [ecx+2], al

; 1746 : 	x86Ptr += 2;  
; 1747 : } 
; 1748 : 
; 1749 : __forceinline void write24(u32 val ) 
; 1750 : { 
; 1751 : 	*(u8*)x86Ptr = (u8)(val & 0xff); 
; 1752 : 	x86Ptr++;  
; 1753 : 	*(u8*)x86Ptr = (u8)((val >> 8) & 0xff); 
; 1754 : 	x86Ptr++;  
; 1755 : 	*(u8*)x86Ptr = (u8)((val >> 16) & 0xff); 
; 1756 : 	x86Ptr++;  
; 1757 : } 
; 1758 : 
; 1759 : __forceinline void write32(u32 val ) 
; 1760 : { 
; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [ecx+3], edi

; 1762 : 	x86Ptr += 4; 

	add	ecx, 7
	pop	edi
	pop	esi
	mov	DWORD PTR ?x86Ptr@@3PAEA, ecx		; x86Ptr
	pop	ebx
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 384  : }

	ret	0
$LN2@eeMoveGPRt:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	eax, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 380  : 			MOV32MtoR(EAX, (int)&cpuRegs.GPR.r[ fromgpr ].UL[ 0 ] );

	shl	esi, 4
	add	esi, OFFSET ?cpuRegs@@3UcpuRegisters@@A	; cpuRegs
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	WORD PTR [eax], 1419			; 0000058bH

; 1746 : 	x86Ptr += 2;  
; 1747 : } 
; 1748 : 
; 1749 : __forceinline void write24(u32 val ) 
; 1750 : { 
; 1751 : 	*(u8*)x86Ptr = (u8)(val & 0xff); 
; 1752 : 	x86Ptr++;  
; 1753 : 	*(u8*)x86Ptr = (u8)((val >> 8) & 0xff); 
; 1754 : 	x86Ptr++;  
; 1755 : 	*(u8*)x86Ptr = (u8)((val >> 16) & 0xff); 
; 1756 : 	x86Ptr++;  
; 1757 : } 
; 1758 : 
; 1759 : __forceinline void write32(u32 val ) 
; 1760 : { 
; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [eax+2], esi

; 1739 : 	*x86Ptr = (u8)val; 

	mov	WORD PTR [eax+6], 1417			; 00000589H

; 1746 : 	x86Ptr += 2;  
; 1747 : } 
; 1748 : 
; 1749 : __forceinline void write24(u32 val ) 
; 1750 : { 
; 1751 : 	*(u8*)x86Ptr = (u8)(val & 0xff); 
; 1752 : 	x86Ptr++;  
; 1753 : 	*(u8*)x86Ptr = (u8)((val >> 8) & 0xff); 
; 1754 : 	x86Ptr++;  
; 1755 : 	*(u8*)x86Ptr = (u8)((val >> 16) & 0xff); 
; 1756 : 	x86Ptr++;  
; 1757 : } 
; 1758 : 
; 1759 : __forceinline void write32(u32 val ) 
; 1760 : { 
; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [eax+8], edi

; 1762 : 	x86Ptr += 4; 

	add	eax, 12					; 0000000cH
	pop	edi
	pop	esi
	mov	DWORD PTR ?x86Ptr@@3PAEA, eax		; x86Ptr
	pop	ebx
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 384  : }

	ret	0
?_eeMoveGPRtoM@@YAXIH@Z ENDP				; _eeMoveGPRtoM
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\icore.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ifpu.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ifpu.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ifpu.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
_TEXT	SEGMENT
?iFlushCall@@YAXH@Z PROC				; iFlushCall
; _flushtype$ = ecx

; 1129 : {

	push	ebx
	mov	ebx, ecx

; 1130 : 	_freeX86regs();

	call	?_freeX86regs@@YAXXZ			; _freeX86regs

; 1131 : 
; 1132 : 	if( flushtype & FLUSH_FREE_XMM )

	test	bl, 4
	je	SHORT $LN10@iFlushCall
	push	esi
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\icore.cpp

; 992  : 	for (i=0; i<XMMREGS; i++) {

	xor	esi, esi
$LL16@iFlushCall:

; 993  : 		if (xmmregs[i].inuse == 0) continue;

	cmp	BYTE PTR ?xmmregs@@3PAU_xmmregs@@A[esi*8], 0
	je	SHORT $LN15@iFlushCall

; 994  : 
; 995  : 		assert( xmmregs[i].type != XMMTYPE_TEMP );
; 996  : 		//assert( xmmregs[i].mode & (MODE_READ|MODE_WRITE) );
; 997  : 
; 998  : 		_freeXMMreg(i);

	mov	ecx, esi
	call	?_freeXMMreg@@YAXH@Z			; _freeXMMreg
$LN15@iFlushCall:

; 992  : 	for (i=0; i<XMMREGS; i++) {

	inc	esi
	cmp	esi, 8
	jl	SHORT $LL16@iFlushCall
	pop	esi

; 999  : 	}
; 1000 : }

	jmp	SHORT $LN8@iFlushCall
$LN10@iFlushCall:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1134 : 	else if( flushtype & FLUSH_FLUSH_XMM)

	test	bl, 2
	je	SHORT $LN8@iFlushCall

; 1135 : 		_flushXMMregs();

	call	?_flushXMMregs@@YAXXZ			; _flushXMMregs
$LN8@iFlushCall:

; 1136 : 
; 1137 : 	if( flushtype & FLUSH_FREE_MMX )

	test	bl, 16					; 00000010H
	je	SHORT $LN7@iFlushCall

; 1138 : 		_freeMMXregs();

	call	?_freeMMXregs@@YAXXZ			; _freeMMXregs
	jmp	SHORT $LN5@iFlushCall
$LN7@iFlushCall:

; 1139 : 	else if( flushtype & FLUSH_FLUSH_MMX)

	test	bl, 8
	je	SHORT $LN5@iFlushCall

; 1140 : 		_flushMMXregs();

	call	?_flushMMXregs@@YAXXZ			; _flushMMXregs
$LN5@iFlushCall:

; 1141 : 
; 1142 : 	if( flushtype & FLUSH_CACHED_REGS )

	test	bl, 1
	pop	ebx
	je	SHORT $LN4@iFlushCall

; 1143 : 		_flushConstRegs();

	call	?_flushConstRegs@@YAXXZ			; _flushConstRegs
$LN4@iFlushCall:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ifpu.cpp

; 52   : 	if (iCWstate == 0) return;

	mov	ax, WORD PTR ?iCWstate@@3GA		; iCWstate
	test	ax, ax
	je	SHORT $LN47@iFlushCall

; 57   : 	if (iCWstate & 1) {

	test	al, 1
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	eax, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ifpu.cpp

; 57   : 	if (iCWstate & 1) {

	je	SHORT $LN32@iFlushCall
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	WORD PTR [eax], 11737			; 00002dd9H

; 1747 : } 
; 1748 : 
; 1749 : __forceinline void write24(u32 val ) 
; 1750 : { 
; 1751 : 	*(u8*)x86Ptr = (u8)(val & 0xff); 
; 1752 : 	x86Ptr++;  
; 1753 : 	*(u8*)x86Ptr = (u8)((val >> 8) & 0xff); 
; 1754 : 	x86Ptr++;  
; 1755 : 	*(u8*)x86Ptr = (u8)((val >> 16) & 0xff); 
; 1756 : 	x86Ptr++;  
; 1757 : } 
; 1758 : 
; 1759 : __forceinline void write32(u32 val ) 
; 1760 : { 
; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [eax+2], OFFSET _fpucws

; 1762 : 	x86Ptr += 4; 

	add	eax, 6
	mov	DWORD PTR ?x86Ptr@@3PAEA, eax		; x86Ptr
$LN32@iFlushCall:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ifpu.cpp

; 60   : 	iCWstate = 0;

	xor	ecx, ecx
	mov	WORD PTR ?iCWstate@@3GA, cx		; iCWstate
	jmp	SHORT $LN22@iFlushCall
$LN47@iFlushCall:
	mov	eax, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
$LN22@iFlushCall:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1147 : 	if (x86FpuState==MMX_STATE) {

	cmp	WORD PTR ?x86FpuState@@3GA, 1		; x86FpuState
	jne	SHORT $LN3@iFlushCall

; 1148 : 		if (cpucaps.has3DNOWInstructionExtensions) FEMMS();

	cmp	DWORD PTR ?cpucaps@@3UCAPABILITIES@@A+136, 0
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1745 : 	*(u16*)x86Ptr = (u16)val; 

	mov	ecx, 3599				; 00000e0fH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1148 : 		if (cpucaps.has3DNOWInstructionExtensions) FEMMS();

	jne	SHORT $LN48@iFlushCall
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1745 : 	*(u16*)x86Ptr = (u16)val; 

	mov	ecx, 30479				; 0000770fH
$LN48@iFlushCall:
	mov	WORD PTR [eax], cx

; 1746 : 	x86Ptr += 2;  

	add	eax, 2
	mov	DWORD PTR ?x86Ptr@@3PAEA, eax		; x86Ptr
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1150 : 		x86FpuState=FPU_STATE;

	xor	eax, eax
	mov	WORD PTR ?x86FpuState@@3GA, ax		; x86FpuState
$LN3@iFlushCall:

; 1151 : 	}
; 1152 : }

	ret	0
?iFlushCall@@YAXH@Z ENDP				; iFlushCall
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
_TEXT	SEGMENT
?_eeFlushAllUnused@@YAXXZ PROC				; _eeFlushAllUnused

; 301  : {

	push	ebx

; 302  : 	int i;
; 303  : 	for(i = 0; i < 34; ++i) {

	mov	ebx, DWORD PTR ?g_pCurInstInfo@@3PAUEEINST@@A ; g_pCurInstInfo
	push	ebp
	mov	ebp, DWORD PTR ?pc@@3IA			; pc
	push	esi
	xor	esi, esi
	push	edi
	lea	edi, DWORD PTR [esi+1]
$LL13@eeFlushAll:

; 304  : 		if( pc < s_nEndBlock ) {

	cmp	ebp, DWORD PTR _s_nEndBlock
	jae	SHORT $LN10@eeFlushAll

; 305  : 			if( (g_pCurInstInfo[1].regs[i]&EEINST_USED) )

	test	BYTE PTR [ebx+esi+112], 64		; 00000040H

; 306  : 				continue;
; 307  : 		}

	jmp	SHORT $LN25@eeFlushAll
$LN10@eeFlushAll:

; 308  : 		else if( (g_pCurInstInfo[0].regs[i]&EEINST_USED) )

	test	BYTE PTR [ebx+esi], 64			; 00000040H
$LN25@eeFlushAll:
	jne	SHORT $LN12@eeFlushAll

; 309  : 			continue;
; 310  : 
; 311  : 		if( i < 32 && GPR_IS_CONST1(i) ) _flushConstReg(i);

	cmp	esi, 32					; 00000020H
	jge	SHORT $LN6@eeFlushAll
	test	edi, DWORD PTR ?g_cpuHasConstReg@@3IA	; g_cpuHasConstReg
	je	SHORT $LN6@eeFlushAll
	mov	ecx, esi
	call	?_flushConstReg@@YAXH@Z			; _flushConstReg

; 312  : 		else {	

	jmp	SHORT $LN12@eeFlushAll
$LN6@eeFlushAll:

; 313  : 			_deleteMMXreg(MMX_GPR+i, 1);

	mov	edx, 1
	mov	ecx, esi
	call	?_deleteMMXreg@@YAXHH@Z			; _deleteMMXreg

; 314  : 			_deleteGPRtoXMMreg(i, 1);

	mov	edx, 1
	mov	ecx, esi
	call	?_deleteGPRtoXMMreg@@YAXHH@Z		; _deleteGPRtoXMMreg
$LN12@eeFlushAll:

; 302  : 	int i;
; 303  : 	for(i = 0; i < 34; ++i) {

	inc	esi
	rol	edi, 1
	cmp	esi, 34					; 00000022H
	jl	SHORT $LL13@eeFlushAll

; 315  : 		}
; 316  : 	}
; 317  : 
; 318  : 	//TODO when used info is done for FPU and VU0
; 319  : 	for(i = 0; i < XMMREGS; ++i) {

	xor	esi, esi
$LL4@eeFlushAll:

; 320  : 		if( xmmregs[i].inuse && xmmregs[i].type != XMMTYPE_GPRREG )

	cmp	BYTE PTR ?xmmregs@@3PAU_xmmregs@@A[esi*8], 0
	je	SHORT $LN3@eeFlushAll
	cmp	BYTE PTR ?xmmregs@@3PAU_xmmregs@@A[esi*8+2], 5
	je	SHORT $LN3@eeFlushAll

; 321  : 			_freeXMMreg(i);

	mov	ecx, esi
	call	?_freeXMMreg@@YAXH@Z			; _freeXMMreg
$LN3@eeFlushAll:

; 315  : 		}
; 316  : 	}
; 317  : 
; 318  : 	//TODO when used info is done for FPU and VU0
; 319  : 	for(i = 0; i < XMMREGS; ++i) {

	inc	esi
	cmp	esi, 8
	jl	SHORT $LL4@eeFlushAll

; 322  : 	}
; 323  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	0
?_eeFlushAllUnused@@YAXXZ ENDP				; _eeFlushAllUnused
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\icore.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
_TEXT	SEGMENT
?_eeMoveGPRtoR@@YAXHH@Z PROC				; _eeMoveGPRtoR
; _to$ = ecx
; _fromgpr$ = edx

; 346  : {

	push	ebx
	push	esi
	mov	esi, edx
	mov	ebx, ecx
	push	edi

; 347  : 	if( GPR_IS_CONST1(fromgpr) )

	mov	edi, 1
	cmp	esi, 32					; 00000020H
	jge	SHORT $LN6@eeMoveGPRt
	mov	eax, edi
	mov	ecx, esi
	shl	eax, cl
	test	DWORD PTR ?g_cpuHasConstReg@@3IA, eax	; g_cpuHasConstReg
	je	SHORT $LN6@eeMoveGPRt
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	eax, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp

; 496  : 	write8( 0xB8 | (to & 0x7) ); 

	and	bl, 7
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 348  : 		MOV32ItoR( to, g_cpuConstRegs[fromgpr].UL[0] );

	shl	esi, 4
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp

; 496  : 	write8( 0xB8 | (to & 0x7) ); 

	or	bl, 184					; 000000b8H
	pop	edi
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 348  : 		MOV32ItoR( to, g_cpuConstRegs[fromgpr].UL[0] );

	mov	ecx, DWORD PTR ?g_cpuConstRegs@@3PATGPR_reg64@@A[esi]
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	BYTE PTR [eax], bl

; 1746 : 	x86Ptr += 2;  
; 1747 : } 
; 1748 : 
; 1749 : __forceinline void write24(u32 val ) 
; 1750 : { 
; 1751 : 	*(u8*)x86Ptr = (u8)(val & 0xff); 
; 1752 : 	x86Ptr++;  
; 1753 : 	*(u8*)x86Ptr = (u8)((val >> 8) & 0xff); 
; 1754 : 	x86Ptr++;  
; 1755 : 	*(u8*)x86Ptr = (u8)((val >> 16) & 0xff); 
; 1756 : 	x86Ptr++;  
; 1757 : } 
; 1758 : 
; 1759 : __forceinline void write32(u32 val ) 
; 1760 : { 
; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [eax+1], ecx

; 1762 : 	x86Ptr += 4; 

	add	eax, 5
	pop	esi
	mov	DWORD PTR ?x86Ptr@@3PAEA, eax		; x86Ptr
	pop	ebx
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 363  : }

	ret	0
$LN6@eeMoveGPRt:

; 349  : 	else {
; 350  : 		int mmreg;
; 351  : 		
; 352  : 		if( (mmreg = _checkXMMreg(XMMTYPE_GPRREG, fromgpr, MODE_READ)) >= 0 && (xmmregs[mmreg].mode&MODE_WRITE)) {

	push	1
	mov	ecx, 5
	call	?_checkXMMreg@@YAHHHH@Z			; _checkXMMreg
	add	esp, 4
	test	eax, eax
	js	SHORT $LN4@eeMoveGPRt
	test	BYTE PTR ?xmmregs@@3PAU_xmmregs@@A[eax*8+3], 2
	je	SHORT $LN4@eeMoveGPRt
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	ecx, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
	or	al, 248					; 000000f8H
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp

; 122  : 	write8( ( mod << 6 ) | ( (reg & 7) << 3 ) | ( rm & 7 ) );

	and	bl, 7
	shl	al, 3
	or	al, bl
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1745 : 	*(u16*)x86Ptr = (u16)val; 

	mov	edx, 32271				; 00007e0fH
	pop	edi

; 1739 : 	*x86Ptr = (u8)val; 

	mov	BYTE PTR [ecx], 102			; 00000066H

; 1745 : 	*(u16*)x86Ptr = (u16)val; 

	mov	WORD PTR [ecx+1], dx

; 1739 : 	*x86Ptr = (u8)val; 

	mov	BYTE PTR [ecx+3], al

; 1740 : 	x86Ptr++; 

	add	ecx, 4
	pop	esi
	mov	DWORD PTR ?x86Ptr@@3PAEA, ecx		; x86Ptr
	pop	ebx
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 363  : }

	ret	0
$LN4@eeMoveGPRt:

; 353  : 			SSE2_MOVD_XMM_to_R(to, mmreg);
; 354  : 		}
; 355  : 		else if( (mmreg = _checkMMXreg(MMX_GPR+fromgpr, MODE_READ)) >= 0 && (mmxregs[mmreg].mode&MODE_WRITE) ) {

	mov	edx, edi
	mov	ecx, esi
	call	?_checkMMXreg@@YAHHH@Z			; _checkMMXreg
	mov	edx, eax
	test	edx, edx
	js	SHORT $LN2@eeMoveGPRt
	lea	ecx, DWORD PTR [edx+edx*2]
	test	BYTE PTR ?mmxregs@@3PAU_mmxregs@@A[ecx*2+2], 2
	je	SHORT $LN2@eeMoveGPRt
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1745 : 	*(u16*)x86Ptr = (u16)val; 

	mov	eax, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr

; 1739 : 	*x86Ptr = (u8)val; 

	or	dl, 248					; 000000f8H
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp

; 122  : 	write8( ( mod << 6 ) | ( (reg & 7) << 3 ) | ( rm & 7 ) );

	and	bl, 7
	shl	dl, 3
	or	dl, bl
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\icore.cpp

; 1135 : 	x86FpuState = MMX_STATE;

	mov	WORD PTR ?x86FpuState@@3GA, di		; x86FpuState
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1745 : 	*(u16*)x86Ptr = (u16)val; 

	mov	ecx, 32271				; 00007e0fH
	mov	WORD PTR [eax], cx
	pop	edi

; 1739 : 	*x86Ptr = (u8)val; 

	mov	BYTE PTR [eax+2], dl

; 1740 : 	x86Ptr++; 

	add	eax, 3
	pop	esi

; 1762 : 	x86Ptr += 4; 

	mov	DWORD PTR ?x86Ptr@@3PAEA, eax		; x86Ptr
	pop	ebx
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 363  : }

	ret	0
$LN2@eeMoveGPRt:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	eax, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
	and	bl, 7
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp

; 122  : 	write8( ( mod << 6 ) | ( (reg & 7) << 3 ) | ( rm & 7 ) );

	shl	bl, 3
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 360  : 			MOV32MtoR(to, (int)&cpuRegs.GPR.r[ fromgpr ].UL[ 0 ] );

	shl	esi, 4
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp

; 122  : 	write8( ( mod << 6 ) | ( (reg & 7) << 3 ) | ( rm & 7 ) );

	or	bl, 5
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 360  : 			MOV32MtoR(to, (int)&cpuRegs.GPR.r[ fromgpr ].UL[ 0 ] );

	add	esi, OFFSET ?cpuRegs@@3UcpuRegisters@@A	; cpuRegs
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	BYTE PTR [eax], 139			; 0000008bH
	mov	BYTE PTR [eax+1], bl
	pop	edi

; 1746 : 	x86Ptr += 2;  
; 1747 : } 
; 1748 : 
; 1749 : __forceinline void write24(u32 val ) 
; 1750 : { 
; 1751 : 	*(u8*)x86Ptr = (u8)(val & 0xff); 
; 1752 : 	x86Ptr++;  
; 1753 : 	*(u8*)x86Ptr = (u8)((val >> 8) & 0xff); 
; 1754 : 	x86Ptr++;  
; 1755 : 	*(u8*)x86Ptr = (u8)((val >> 16) & 0xff); 
; 1756 : 	x86Ptr++;  
; 1757 : } 
; 1758 : 
; 1759 : __forceinline void write32(u32 val ) 
; 1760 : { 
; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [eax+2], esi

; 1762 : 	x86Ptr += 4; 

	add	eax, 6
	pop	esi
	mov	DWORD PTR ?x86Ptr@@3PAEA, eax		; x86Ptr
	pop	ebx
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 363  : }

	ret	0
?_eeMoveGPRtoR@@YAXHH@Z ENDP				; _eeMoveGPRtoR
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
_TEXT	SEGMENT
?LoadBranchState@@YAXXZ PROC				; LoadBranchState

; 1100 : 	x86FpuState = s_savex86FpuState;

	movzx	eax, WORD PTR _s_savex86FpuState
	mov	WORD PTR ?x86FpuState@@3GA, ax		; x86FpuState

; 1101 : 	iCWstate = s_saveiCWstate;

	movzx	eax, WORD PTR _s_saveiCWstate
	mov	WORD PTR ?iCWstate@@3GA, ax		; iCWstate

; 1102 : 	s_nBlockCycles = s_savenBlockCycles;

	mov	eax, DWORD PTR _s_savenBlockCycles
	mov	DWORD PTR ?s_nBlockCycles@@3IA, eax	; s_nBlockCycles

; 1103 : 
; 1104 : 	if( s_saveConstGPRreg != 0xffffffff ) {

	mov	eax, DWORD PTR ?s_saveConstGPRreg@@3IA	; s_saveConstGPRreg
	cmp	eax, -1
	je	SHORT $LN2@LoadBranch

; 1105 : 		assert( s_saveConstGPRreg > 0 );
; 1106 : 
; 1107 : 		// make sure right GPR was saved
; 1108 : 		assert( g_cpuHasConstReg == s_saveHasConstReg || (g_cpuHasConstReg ^ s_saveHasConstReg) == (1<<s_saveConstGPRreg) );
; 1109 : 
; 1110 : 		// restore the GPR reg
; 1111 : 		g_cpuConstRegs[s_saveConstGPRreg] = s_ConstGPRreg;

	movdqu	xmm0, XMMWORD PTR ?s_ConstGPRreg@@3TGPR_reg64@@A
	shl	eax, 4
	add	eax, OFFSET ?g_cpuConstRegs@@3PATGPR_reg64@@A ; g_cpuConstRegs

; 1112 : 		GPR_SET_CONST(s_saveConstGPRreg);
; 1113 : 
; 1114 : 		s_saveConstGPRreg = 0;

	mov	DWORD PTR ?s_saveConstGPRreg@@3IA, 0	; s_saveConstGPRreg
	movdqu	XMMWORD PTR [eax], xmm0
$LN2@LoadBranch:

; 1115 : 	}
; 1116 : 
; 1117 : 	g_cpuHasConstReg = s_saveHasConstReg;

	mov	eax, DWORD PTR _s_saveHasConstReg

; 1118 : 	g_cpuFlushedConstReg = s_saveFlushedConstReg;
; 1119 : 	g_pCurInstInfo = s_psaveInstInfo;
; 1120 : 	g_cpuRegHasLive1 = g_cpuPrevRegHasLive1 = s_saveRegHasLive1;
; 1121 : 	g_cpuRegHasSignExt = g_cpuPrevRegHasSignExt = s_saveRegHasSignExt;
; 1122 : 
; 1123 : 	// restore all mmx regs
; 1124 : 	memcpy_fast(mmxregs, s_saveMMXregs, sizeof(mmxregs));

	mov	edx, OFFSET ?s_saveMMXregs@@3PAU_mmxregs@@A ; s_saveMMXregs
	mov	DWORD PTR ?g_cpuHasConstReg@@3IA, eax	; g_cpuHasConstReg
	mov	ecx, OFFSET ?mmxregs@@3PAU_mmxregs@@A	; mmxregs
	mov	eax, DWORD PTR _s_saveFlushedConstReg
	mov	DWORD PTR ?g_cpuFlushedConstReg@@3IA, eax ; g_cpuFlushedConstReg
	mov	eax, DWORD PTR _s_psaveInstInfo
	mov	DWORD PTR ?g_pCurInstInfo@@3PAUEEINST@@A, eax ; g_pCurInstInfo
	mov	eax, DWORD PTR _s_saveRegHasLive1
	mov	DWORD PTR ?g_cpuPrevRegHasLive1@@3IA, eax ; g_cpuPrevRegHasLive1
	mov	DWORD PTR ?g_cpuRegHasLive1@@3IA, eax	; g_cpuRegHasLive1
	mov	eax, DWORD PTR _s_saveRegHasSignExt
	push	48					; 00000030H
	mov	DWORD PTR ?g_cpuPrevRegHasSignExt@@3IA, eax ; g_cpuPrevRegHasSignExt
	mov	DWORD PTR ?g_cpuRegHasSignExt@@3IA, eax	; g_cpuRegHasSignExt
	call	?memcpy_amd_@@YIXPAXPBXI@Z		; memcpy_amd_

; 1125 : 	memcpy_fast(xmmregs, s_saveXMMregs, sizeof(xmmregs));

	push	64					; 00000040H
	mov	edx, OFFSET ?s_saveXMMregs@@3PAU_xmmregs@@A ; s_saveXMMregs
	mov	ecx, OFFSET ?xmmregs@@3PAU_xmmregs@@A	; xmmregs
	call	?memcpy_amd_@@YIXPAXPBXI@Z		; memcpy_amd_

; 1126 : }

	ret	0
?LoadBranchState@@YAXXZ ENDP				; LoadBranchState
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\icore.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ifpu.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ifpu.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ifpu.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
_TEXT	SEGMENT
?SetBranchImm@@YAXI@Z PROC				; SetBranchImm
; _imm$ = ecx
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	eax, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
	push	esi
	push	edi
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1069 : {

	mov	edi, ecx

; 1070 : 	branch = 1;

	mov	DWORD PTR ?branch@@3HA, 1		; branch
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	WORD PTR [eax], 1479			; 000005c7H

; 1747 : } 
; 1748 : 
; 1749 : __forceinline void write24(u32 val ) 
; 1750 : { 
; 1751 : 	*(u8*)x86Ptr = (u8)(val & 0xff); 
; 1752 : 	x86Ptr++;  
; 1753 : 	*(u8*)x86Ptr = (u8)((val >> 8) & 0xff); 
; 1754 : 	x86Ptr++;  
; 1755 : 	*(u8*)x86Ptr = (u8)((val >> 16) & 0xff); 
; 1756 : 	x86Ptr++;  
; 1757 : } 
; 1758 : 
; 1759 : __forceinline void write32(u32 val ) 
; 1760 : { 
; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [eax+2], OFFSET ?cpuRegs@@3UcpuRegisters@@A+680
	mov	DWORD PTR [eax+6], edi

; 1762 : 	x86Ptr += 4; 

	add	eax, 10					; 0000000aH
	mov	DWORD PTR ?x86Ptr@@3PAEA, eax		; x86Ptr
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1130 : 	_freeX86regs();

	call	?_freeX86regs@@YAXXZ			; _freeX86regs
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\icore.cpp

; 992  : 	for (i=0; i<XMMREGS; i++) {

	xor	esi, esi
$LL30@SetBranchI:

; 993  : 		if (xmmregs[i].inuse == 0) continue;

	cmp	BYTE PTR ?xmmregs@@3PAU_xmmregs@@A[esi*8], 0
	je	SHORT $LN29@SetBranchI

; 994  : 
; 995  : 		assert( xmmregs[i].type != XMMTYPE_TEMP );
; 996  : 		//assert( xmmregs[i].mode & (MODE_READ|MODE_WRITE) );
; 997  : 
; 998  : 		_freeXMMreg(i);

	mov	ecx, esi
	call	?_freeXMMreg@@YAXH@Z			; _freeXMMreg
$LN29@SetBranchI:

; 992  : 	for (i=0; i<XMMREGS; i++) {

	inc	esi
	cmp	esi, 8
	jl	SHORT $LL30@SetBranchI
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1143 : 		_flushConstRegs();

	call	?_freeMMXregs@@YAXXZ			; _freeMMXregs
	call	?_flushConstRegs@@YAXXZ			; _flushConstRegs
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ifpu.cpp

; 52   : 	if (iCWstate == 0) return;

	mov	ax, WORD PTR ?iCWstate@@3GA		; iCWstate
	test	ax, ax
	je	SHORT $LN61@SetBranchI

; 57   : 	if (iCWstate & 1) {

	test	al, 1
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	eax, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ifpu.cpp

; 57   : 	if (iCWstate & 1) {

	je	SHORT $LN46@SetBranchI
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	WORD PTR [eax], 11737			; 00002dd9H

; 1747 : } 
; 1748 : 
; 1749 : __forceinline void write24(u32 val ) 
; 1750 : { 
; 1751 : 	*(u8*)x86Ptr = (u8)(val & 0xff); 
; 1752 : 	x86Ptr++;  
; 1753 : 	*(u8*)x86Ptr = (u8)((val >> 8) & 0xff); 
; 1754 : 	x86Ptr++;  
; 1755 : 	*(u8*)x86Ptr = (u8)((val >> 16) & 0xff); 
; 1756 : 	x86Ptr++;  
; 1757 : } 
; 1758 : 
; 1759 : __forceinline void write32(u32 val ) 
; 1760 : { 
; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [eax+2], OFFSET _fpucws

; 1762 : 	x86Ptr += 4; 

	add	eax, 6
	mov	DWORD PTR ?x86Ptr@@3PAEA, eax		; x86Ptr
$LN46@SetBranchI:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ifpu.cpp

; 60   : 	iCWstate = 0;

	xor	ecx, ecx
	mov	WORD PTR ?iCWstate@@3GA, cx		; iCWstate
	jmp	SHORT $LN36@SetBranchI
$LN61@SetBranchI:
	mov	eax, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
$LN36@SetBranchI:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1147 : 	if (x86FpuState==MMX_STATE) {

	cmp	WORD PTR ?x86FpuState@@3GA, 1		; x86FpuState
	jne	SHORT $LN17@SetBranchI

; 1148 : 		if (cpucaps.has3DNOWInstructionExtensions) FEMMS();

	cmp	DWORD PTR ?cpucaps@@3UCAPABILITIES@@A+136, 0
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1745 : 	*(u16*)x86Ptr = (u16)val; 

	mov	ecx, 3599				; 00000e0fH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1148 : 		if (cpucaps.has3DNOWInstructionExtensions) FEMMS();

	jne	SHORT $LN64@SetBranchI
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1745 : 	*(u16*)x86Ptr = (u16)val; 

	mov	ecx, 30479				; 0000770fH
$LN64@SetBranchI:
	mov	WORD PTR [eax], cx

; 1746 : 	x86Ptr += 2;  

	add	eax, 2
	mov	DWORD PTR ?x86Ptr@@3PAEA, eax		; x86Ptr
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1150 : 		x86FpuState=FPU_STATE;

	xor	eax, eax
	mov	WORD PTR ?x86FpuState@@3GA, ax		; x86FpuState
$LN17@SetBranchI:

; 1071 : 
; 1072 : 	assert( imm );
; 1073 : 
; 1074 : 	// end the current block
; 1075 : 	MOV32ItoM( (uptr)&cpuRegs.pc, imm );
; 1076 : 	iFlushCall(FLUSH_EVERYTHING);
; 1077 : 
; 1078 : 	iBranchTest(imm);

	mov	ecx, edi
	xor	dl, dl
	pop	edi
	pop	esi
	jmp	?iBranchTest@@YAXI_N@Z			; iBranchTest
?SetBranchImm@@YAXI@Z ENDP				; SetBranchImm
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\baseblockex.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vtlb.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\icore.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\icore.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\icore.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\icore.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\icore.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\icore.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900opcodeimpl.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
_TEXT	SEGMENT
_delayslot$1$ = -12					; size = 4
_inst$1$ = -8						; size = 4
?cpuRegs@@3UcpuRegisters@@A$1 = -4			; size = 4
?recompileNextInstruction@@YAXH@Z PROC			; recompileNextInstruction
; _delayslot$ = ecx

; 1312 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 12					; 0000000cH

; 1313 : 	static u8 s_bFlushReg = 1;
; 1314 : 	int i, count;
; 1315 : 
; 1316 : 	BASEBLOCK* pblock = PC_GETBLOCK(pc);

	mov	eax, DWORD PTR ?recLUT@@3PAIA		; recLUT
	push	ebx
	mov	ebx, DWORD PTR ?pc@@3IA			; pc
	push	esi
	movzx	esi, WORD PTR ?pc@@3IA+2
	movzx	edx, bx
	push	edi
	mov	DWORD PTR _delayslot$1$[esp+24], ecx
	mov	eax, DWORD PTR [eax+esi*4]

; 1317 : 
; 1318 : 	// need *ppblock != s_pCurBlock because of branches
; 1319 : 	if( pblock->GetFnptr() != 0 && pblock->startpc != s_pCurBlock->startpc ) {

	test	DWORD PTR [eax+edx*2], 268435455	; 0fffffffH
	lea	edi, DWORD PTR [eax+edx*2]
	je	$LN127@recompileN
	mov	eax, DWORD PTR _s_pCurBlock
	mov	ecx, DWORD PTR [edi+4]
	cmp	ecx, DWORD PTR [eax+4]

; 1320 : 
; 1321 : 		if( !delayslot && pc == pblock->startpc ) {

	mov	eax, DWORD PTR _delayslot$1$[esp+24]
	je	$LN28@recompileN
	test	eax, eax
	jne	SHORT $LN115@recompileN
	cmp	ebx, ecx
	jne	SHORT $LN29@recompileN

; 1322 : 			// code already in place, so jump to it and exit recomp
; 1323 : 			assert( PC_GETBLOCKEX(pblock)->startpc == pblock->startpc );
; 1324 : 			
; 1325 : 			iFlushCall(FLUSH_EVERYTHING);

	mov	ecx, 4095				; 00000fffH
	call	?iFlushCall@@YAXH@Z			; iFlushCall
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	ecx, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1336 : 			branch = 3;

	mov	DWORD PTR ?branch@@3HA, 3		; branch
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	WORD PTR [ecx], 1479			; 000005c7H

; 1740 : 	x86Ptr++; 
; 1741 : } 
; 1742 : 
; 1743 : __forceinline void write16(u16 val ) 
; 1744 : { 
; 1745 : 	*(u16*)x86Ptr = (u16)val; 
; 1746 : 	x86Ptr += 2;  
; 1747 : } 
; 1748 : 
; 1749 : __forceinline void write24(u32 val ) 
; 1750 : { 
; 1751 : 	*(u8*)x86Ptr = (u8)(val & 0xff); 
; 1752 : 	x86Ptr++;  
; 1753 : 	*(u8*)x86Ptr = (u8)((val >> 8) & 0xff); 
; 1754 : 	x86Ptr++;  
; 1755 : 	*(u8*)x86Ptr = (u8)((val >> 16) & 0xff); 
; 1756 : 	x86Ptr++;  
; 1757 : } 
; 1758 : 
; 1759 : __forceinline void write32(u32 val ) 
; 1760 : { 
; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [ecx+2], OFFSET ?cpuRegs@@3UcpuRegisters@@A+680
	mov	DWORD PTR [ecx+6], ebx

; 1762 : 	x86Ptr += 4; 

	add	ecx, 10					; 0000000aH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\baseblockex.h

; 35   : 	const uptr GetFnptr() const { return ((u32)m_pFnptr)<<4; }

	mov	eax, DWORD PTR [edi]
	shl	eax, 4
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1335 : 			JMP32((uptr)pblock->GetFnptr() - ((uptr)x86Ptr + 5));

	sub	eax, ecx
	sub	eax, 5
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	BYTE PTR [ecx], 233			; 000000e9H

; 1740 : 	x86Ptr++; 
; 1741 : } 
; 1742 : 
; 1743 : __forceinline void write16(u16 val ) 
; 1744 : { 
; 1745 : 	*(u16*)x86Ptr = (u16)val; 
; 1746 : 	x86Ptr += 2;  
; 1747 : } 
; 1748 : 
; 1749 : __forceinline void write24(u32 val ) 
; 1750 : { 
; 1751 : 	*(u8*)x86Ptr = (u8)(val & 0xff); 
; 1752 : 	x86Ptr++;  
; 1753 : 	*(u8*)x86Ptr = (u8)((val >> 8) & 0xff); 
; 1754 : 	x86Ptr++;  
; 1755 : 	*(u8*)x86Ptr = (u8)((val >> 16) & 0xff); 
; 1756 : 	x86Ptr++;  
; 1757 : } 
; 1758 : 
; 1759 : __forceinline void write32(u32 val ) 
; 1760 : { 
; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [ecx+1], eax

; 1762 : 	x86Ptr += 4; 

	add	ecx, 5
	mov	DWORD PTR ?x86Ptr@@3PAEA, ecx		; x86Ptr
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1495 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN115@recompileN:

; 1337 : 			return;
; 1338 : 		}
; 1339 : 		else {
; 1340 : 
; 1341 : 			if( !(delayslot && pblock->startpc == pc) ) {

	cmp	ecx, ebx
	je	SHORT $LN28@recompileN
$LN29@recompileN:

; 1342 : 				u8* oldX86 = x86Ptr;

	mov	esi, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr

; 1343 : 				//__Log("clear block %x\n", pblock->startpc);
; 1344 : 				recClearMem(pblock);

	mov	ecx, edi
	call	?recClearMem@@YAXPAUBASEBLOCK@@@Z	; recClearMem

; 1345 : 				x86Ptr = oldX86;
; 1346 : 				if( delayslot )

	cmp	DWORD PTR _delayslot$1$[esp+24], 0
	mov	DWORD PTR ?x86Ptr@@3PAEA, esi		; x86Ptr
	je	SHORT $LN27@recompileN

; 1347 : 					Console::Notice("delay slot %x", params pc);

	push	DWORD PTR ?pc@@3IA			; pc
	push	0
	push	OFFSET ??_C@_0O@HOCNDIGO@delay?5slot?5?$CFx?$AA@
	call	?Notice@Console@@YA_NPBDPBU_VARG_PARAM@@ZZ ; Console::Notice
	mov	eax, DWORD PTR _delayslot$1$[esp+36]
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN28@recompileN
$LN127@recompileN:
	mov	eax, ecx
$LN28@recompileN:

; 1348 : 			}
; 1349 : 		}
; 1350 : 	}
; 1351 : 
; 1352 : 	if( delayslot )

	test	eax, eax
	je	SHORT $LN27@recompileN

; 1353 : 		pblock->uType = BLOCKTYPE_DELAYSLOT;

	mov	eax, DWORD PTR [edi]
	and	eax, 268435455				; 0fffffffH
	or	eax, 268435456				; 10000000H
	mov	DWORD PTR [edi], eax
$LN27@recompileN:

; 1354 : 		
; 1355 : 	s_pCode = (int *)PSM( pc );

	mov	ebx, DWORD PTR ?pc@@3IA			; pc
	mov	ecx, ebx
	and	ecx, 536870911				; 1fffffffH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vtlb.cpp

; 440  : 	if (paddr>=VTLB_PMAP_SZ || pmap[paddr>>VTLB_PAGE_BITS]<0)

	cmp	ecx, 536870912				; 20000000H
	jae	SHORT $LN59@recompileN
	mov	eax, ecx
	shr	eax, 12					; 0000000cH
	mov	eax, DWORD PTR ?pmap@vtlb_private@@3PAHA[eax*4]
	test	eax, eax
	js	SHORT $LN59@recompileN

; 442  : 	else
; 443  : 		return reinterpret_cast<void*>(pmap[paddr>>VTLB_PAGE_BITS]+(paddr&VTLB_PAGE_MASK));

	and	ecx, 4095				; 00000fffH
	add	ecx, eax
	jmp	SHORT $LN58@recompileN
$LN59@recompileN:

; 441  : 		return 0;

	xor	ecx, ecx
$LN58@recompileN:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1362 : 	cpuRegs.code = *(int *)s_pCode;

	mov	eax, DWORD PTR [ecx]

; 1363 : 	pc += 4;

	add	ebx, 4
	mov	edi, DWORD PTR _s_nEndBlock
	mov	esi, OFFSET ?mmxregs@@3PAU_mmxregs@@A+4
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A$1[esp+24], eax
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+684, eax

; 1364 : 	
; 1365 : //#ifdef _DEBUG
; 1366 : //	CMP32ItoM((u32)s_pCode, cpuRegs.code);
; 1367 : //	j8Ptr[0] = JE8(0);
; 1368 : //	MOV32ItoR(EAX, pc);
; 1369 : //	CALLFunc((uptr)checkcodefn);
; 1370 : //	x86SetJ8( j8Ptr[ 0 ] );
; 1371 : //
; 1372 : //	if( !delayslot ) {
; 1373 : //		CMP32ItoM((u32)&cpuRegs.pc, s_pCurBlockEx->startpc);
; 1374 : //		j8Ptr[0] = JB8(0);
; 1375 : //		CMP32ItoM((u32)&cpuRegs.pc, pc);
; 1376 : //		j8Ptr[1] = JA8(0);
; 1377 : //		j8Ptr[2] = JMP8(0);
; 1378 : //		x86SetJ8( j8Ptr[ 0 ] );
; 1379 : //		x86SetJ8( j8Ptr[ 1 ] );
; 1380 : //		PUSH32I(s_pCurBlockEx->startpc);
; 1381 : //		ADD32ItoR(ESP, 4);
; 1382 : //		x86SetJ8( j8Ptr[ 2 ] );	
; 1383 : //	}
; 1384 : //#endif
; 1385 : 
; 1386 : 	g_pCurInstInfo++;

	mov	eax, DWORD PTR ?g_pCurInstInfo@@3PAUEEINST@@A ; g_pCurInstInfo
	add	eax, 112				; 00000070H
	mov	DWORD PTR _s_pCode, ecx
	mov	DWORD PTR ?pc@@3IA, ebx			; pc
	mov	DWORD PTR ?g_pCurInstInfo@@3PAUEEINST@@A, eax ; g_pCurInstInfo
$LL26@recompileN:

; 1397 : 		if( mmxregs[i].inuse ) {

	cmp	BYTE PTR [esi-4], 0
	je	SHORT $LN25@recompileN

; 1399 : 			count = _recIsRegWritten(g_pCurInstInfo, (s_nEndBlock-pc)/4 + 1, XMMTYPE_GPRREG, mmxregs[i].reg-MMX_GPR);

	sub	edi, ebx
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\icore.cpp

; 1076 : 	u32  i, inst = 1;

	mov	ebx, 1
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1399 : 			count = _recIsRegWritten(g_pCurInstInfo, (s_nEndBlock-pc)/4 + 1, XMMTYPE_GPRREG, mmxregs[i].reg-MMX_GPR);

	shr	edi, 2
	inc	edi
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\icore.cpp

; 1078 : 	while(size-- > 0) {

	test	edi, edi
	jle	SHORT $LN118@recompileN
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1399 : 			count = _recIsRegWritten(g_pCurInstInfo, (s_nEndBlock-pc)/4 + 1, XMMTYPE_GPRREG, mmxregs[i].reg-MMX_GPR);

	lea	edx, DWORD PTR [eax+71]
	npad	6
$LL68@recompileN:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\icore.cpp

; 1078 : 	while(size-- > 0) {

	dec	edi

; 1079 : 		for(i = 0; i < ARRAYSIZE(pinst->writeType); ++i) {

	xor	ecx, ecx
$LL66@recompileN:

; 1080 : 			if ((pinst->writeType[i] == xmmtype) && (pinst->writeReg[i] == reg))

	cmp	BYTE PTR [edx+ecx-3], 5
	jne	SHORT $LN65@recompileN
	mov	al, BYTE PTR [edx+ecx]
	cmp	al, BYTE PTR [esi-3]
	je	$LN69@recompileN
$LN65@recompileN:

; 1079 : 		for(i = 0; i < ARRAYSIZE(pinst->writeType); ++i) {

	inc	ecx
	cmp	ecx, 3
	jb	SHORT $LL66@recompileN

; 1081 : 				return inst;
; 1082 : 		}
; 1083 : 		++inst;

	inc	ebx

; 1084 : 		pinst++;

	add	edx, 112				; 00000070H
	test	edi, edi
	jg	SHORT $LL68@recompileN
$LN118@recompileN:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1401 : 			else mmxregs[i].counter = 0;

	xor	eax, eax
$LN128@recompileN:
	mov	edi, DWORD PTR _s_nEndBlock
	mov	ebx, DWORD PTR ?pc@@3IA			; pc
	mov	WORD PTR [esi], ax
$LN25@recompileN:

; 1387 : 
; 1388 : 	// reorder register priorities
; 1389 : //	for(i = 0; i < X86REGS; ++i) {
; 1390 : //		if( x86regs[i].inuse ) {
; 1391 : //			if( count > 0 ) mmxregs[i].counter = 1000-count;
; 1392 : //			else mmxregs[i].counter = 0;
; 1393 : //		}
; 1394 : //	}
; 1395 : 
; 1396 : 	for(i = 0; i < MMXREGS; ++i) {

	mov	eax, DWORD PTR ?g_pCurInstInfo@@3PAUEEINST@@A ; g_pCurInstInfo
	add	esi, 6
	cmp	esi, OFFSET ?mmxregs@@3PAU_mmxregs@@A+52
	jl	SHORT $LL26@recompileN

; 1402 : 		}
; 1403 : 	}
; 1404 : 
; 1405 : 	for(i = 0; i < XMMREGS; ++i) {

	mov	esi, OFFSET ?xmmregs@@3PAU_xmmregs@@A+1
	npad	6
$LL20@recompileN:

; 1406 : 		if( xmmregs[i].inuse ) {

	cmp	BYTE PTR [esi-1], 0
	je	SHORT $LN19@recompileN

; 1407 : 			count = _recIsRegWritten(g_pCurInstInfo, (s_nEndBlock-pc)/4 + 1, xmmregs[i].type, xmmregs[i].reg);

	sub	edi, ebx
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\icore.cpp

; 1076 : 	u32  i, inst = 1;

	mov	DWORD PTR _inst$1$[esp+24], 1
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1407 : 			count = _recIsRegWritten(g_pCurInstInfo, (s_nEndBlock-pc)/4 + 1, xmmregs[i].type, xmmregs[i].reg);

	shr	edi, 2
	inc	edi
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\icore.cpp

; 1078 : 	while(size-- > 0) {

	test	edi, edi
	jle	SHORT $LN120@recompileN
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1407 : 			count = _recIsRegWritten(g_pCurInstInfo, (s_nEndBlock-pc)/4 + 1, xmmregs[i].type, xmmregs[i].reg);

	mov	edx, DWORD PTR ?g_pCurInstInfo@@3PAUEEINST@@A ; g_pCurInstInfo
	mov	bl, BYTE PTR [esi+1]
	add	edx, 71					; 00000047H
$LL76@recompileN:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\icore.cpp

; 1078 : 	while(size-- > 0) {

	dec	edi

; 1079 : 		for(i = 0; i < ARRAYSIZE(pinst->writeType); ++i) {

	xor	eax, eax
$LL74@recompileN:

; 1080 : 			if ((pinst->writeType[i] == xmmtype) && (pinst->writeReg[i] == reg))

	cmp	BYTE PTR [edx+eax-3], bl
	jne	SHORT $LN73@recompileN
	mov	cl, BYTE PTR [edx+eax]
	cmp	cl, BYTE PTR [esi]
	je	$LN77@recompileN
$LN73@recompileN:

; 1079 : 		for(i = 0; i < ARRAYSIZE(pinst->writeType); ++i) {

	inc	eax
	cmp	eax, 3
	jb	SHORT $LL74@recompileN

; 1081 : 				return inst;
; 1082 : 		}
; 1083 : 		++inst;

	inc	DWORD PTR _inst$1$[esp+24]

; 1084 : 		pinst++;

	add	edx, 112				; 00000070H
	test	edi, edi
	jg	SHORT $LL76@recompileN
$LN120@recompileN:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1409 : 			else xmmregs[i].counter = 0;

	xor	eax, eax
$LN129@recompileN:
	mov	WORD PTR [esi+5], ax
$LN19@recompileN:

; 1402 : 		}
; 1403 : 	}
; 1404 : 
; 1405 : 	for(i = 0; i < XMMREGS; ++i) {

	mov	ebx, DWORD PTR ?pc@@3IA			; pc
	add	esi, 8
	mov	edi, DWORD PTR _s_nEndBlock
	cmp	esi, OFFSET ?xmmregs@@3PAU_xmmregs@@A+65
	jl	SHORT $LL20@recompileN
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900opcodeimpl.cpp

; 31   : 		const OPCODE* opcode = &R5900::OpcodeTables::tbl_Standard[_Opcode_];

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A$1[esp+24]
	mov	eax, ecx
	shr	eax, 26					; 0000001aH
	lea	eax, DWORD PTR [eax+eax*8]
	lea	esi, DWORD PTR ?tbl_Standard@OpcodeTables@R5900@@3QBUOPCODE@2@B[eax*4]

; 32   : 
; 33   : 		while( opcode->getsubclass != NULL )

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN79@recompileN
$LL80@recompileN:

; 34   : 			opcode = &opcode->getsubclass();

	call	eax
	mov	esi, eax
	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	jne	SHORT $LL80@recompileN

; 32   : 
; 33   : 		while( opcode->getsubclass != NULL )

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+684
$LN79@recompileN:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1447 : 		if( delayslot ) {

	mov	ebx, DWORD PTR _delayslot$1$[esp+24]
	test	ebx, ebx
	je	SHORT $LN12@recompileN

; 1448 : 			switch(_Opcode_) {

	mov	eax, ecx
	shr	eax, 26					; 0000001aH
	dec	eax
	cmp	eax, 22					; 00000016H
	ja	SHORT $LN12@recompileN
	movzx	eax, BYTE PTR $LN121@recompileN[eax]
	jmp	DWORD PTR $LN132@recompileN[eax*4]
$LN69@recompileN:

; 1400 : 			if( count > 0 ) mmxregs[i].counter = 1000-count;

	test	ebx, ebx
	jle	$LN118@recompileN
	mov	eax, 1000				; 000003e8H
	sub	eax, ebx
	jmp	$LN128@recompileN
$LN77@recompileN:

; 1408 : 			if( count > 0 ) xmmregs[i].counter = 1000-count;

	mov	ecx, DWORD PTR _inst$1$[esp+24]
	test	ecx, ecx
	jle	$LN120@recompileN
	mov	eax, 1000				; 000003e8H
	sub	eax, ecx
	jmp	$LN129@recompileN
$LN11@recompileN:

; 1449 : 				case 1:
; 1450 : 					switch(_Rt_) {

	movzx	eax, WORD PTR ?cpuRegs@@3UcpuRegisters@@A+686
	and	eax, 31					; 0000001fH
	cmp	eax, 19					; 00000013H
	ja	SHORT $LN12@recompileN
	movzx	eax, BYTE PTR $LN122@recompileN[eax]
	jmp	DWORD PTR $LN133@recompileN[eax*4]
$LN8@recompileN:

; 1451 : 						case 0: case 1: case 2: case 3: case 0x10: case 0x11: case 0x12: case 0x13:
; 1452 : 							Console::Notice("branch %x in delay slot!", params cpuRegs.code);

	push	ecx
	push	0
	push	OFFSET ??_C@_0BJ@BNOPKFMB@branch?5?$CFx?5in?5delay?5slot?$CB?$AA@
	call	?Notice@Console@@YA_NPBDPBU_VARG_PARAM@@ZZ ; Console::Notice
	add	esp, 12					; 0000000cH

; 1453 : 							_clearNeededX86regs();
; 1454 : 							_clearNeededMMXregs();
; 1455 : 							_clearNeededXMMregs();
; 1456 : 							return;

	jmp	SHORT $LN1@recompileN
$LN12@recompileN:

; 1457 : 					}
; 1458 : 					break;
; 1459 : 
; 1460 : 				case 2: case 3: case 4: case 5: case 6: case 7: case 0x14: case 0x15: case 0x16: case 0x17:
; 1461 : 					Console::Notice("branch %x in delay slot!", params cpuRegs.code);
; 1462 : 					_clearNeededX86regs();
; 1463 : 					_clearNeededMMXregs();
; 1464 : 					_clearNeededXMMregs();
; 1465 : 					return;
; 1466 : 			}
; 1467 : 		}
; 1468 : 		opcode.recompile();

	mov	eax, DWORD PTR [esi+28]
	call	eax

; 1469 : 		s_nBlockCycles += opcode.cycles;

	movzx	eax, BYTE PTR [esi+16]
	add	DWORD PTR ?s_nBlockCycles@@3IA, eax	; s_nBlockCycles

; 1470 : 	}
; 1471 : 
; 1472 : 	if( !delayslot ) {

	test	ebx, ebx
	jne	SHORT $LN6@recompileN

; 1473 : 		if( s_bFlushReg ) {

	cmp	BYTE PTR ?s_bFlushReg@?1??recompileNextInstruction@@YAXH@Z@4EA, bl
	je	SHORT $LN6@recompileN

; 1474 : 			//if( !_flushUnusedConstReg() ) {
; 1475 : 				int flushed = 0;

	xor	esi, esi

; 1476 : 				if( _getNumMMXwrite() > 3 ) flushed = _flushMMXunused();

	call	?_getNumMMXwrite@@YAHXZ			; _getNumMMXwrite
	cmp	eax, 3
	jle	SHORT $LN116@recompileN
	call	?_flushMMXunused@@YAHXZ			; _flushMMXunused
	mov	esi, eax

; 1477 : 				if( !flushed && _getNumXMMwrite() > 2 ) _flushXMMunused();

	test	esi, esi
	jne	SHORT $LN130@recompileN
$LN116@recompileN:
	call	?_getNumXMMwrite@@YAHXZ			; _getNumXMMwrite
	cmp	eax, 2
	jle	SHORT $LN3@recompileN
	call	?_flushXMMunused@@YAHXZ			; _flushXMMunused
$LN3@recompileN:

; 1478 : 				s_bFlushReg = !flushed;

	test	esi, esi
$LN130@recompileN:
	sete	BYTE PTR ?s_bFlushReg@?1??recompileNextInstruction@@YAXH@Z@4EA
	jmp	SHORT $LN1@recompileN
$LN6@recompileN:

; 1479 : //			}
; 1480 : //			else s_bFlushReg = 0;
; 1481 : 		}
; 1482 : 		else s_bFlushReg = 1;
; 1483 : 	}
; 1484 : 	else s_bFlushReg = 1;

	mov	BYTE PTR ?s_bFlushReg@?1??recompileNextInstruction@@YAXH@Z@4EA, 1
$LN1@recompileN:

; 1485 : 
; 1486 : 	//CHECK_XMMCHANGED();
; 1487 : 	_clearNeededX86regs();

	call	?_clearNeededX86regs@@YAXXZ		; _clearNeededX86regs

; 1488 : 	_clearNeededMMXregs();

	call	?_clearNeededMMXregs@@YAXXZ		; _clearNeededMMXregs

; 1489 : 	_clearNeededXMMregs();

	call	?_clearNeededXMMregs@@YAXXZ		; _clearNeededXMMregs

; 1495 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN132@recompileN:
	DD	$LN11@recompileN
	DD	$LN8@recompileN
	DD	$LN12@recompileN
$LN121@recompileN:
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	1
	DB	1
	DB	1
	DB	1
	npad	1
$LN133@recompileN:
	DD	$LN8@recompileN
	DD	$LN12@recompileN
$LN122@recompileN:
	DB	0
	DB	0
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	0
	DB	0
	DB	0
?recompileNextInstruction@@YAXH@Z ENDP			; recompileNextInstruction
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
_TEXT	SEGMENT
?SaveBranchState@@YAXXZ PROC				; SaveBranchState

; 1083 : 	s_savex86FpuState = x86FpuState;

	movzx	eax, WORD PTR ?x86FpuState@@3GA		; x86FpuState

; 1084 : 	s_saveiCWstate = iCWstate;
; 1085 : 	s_savenBlockCycles = s_nBlockCycles;
; 1086 : 	s_saveConstGPRreg = 0xffffffff; // indicate searching
; 1087 : 	s_saveHasConstReg = g_cpuHasConstReg;
; 1088 : 	s_saveFlushedConstReg = g_cpuFlushedConstReg;
; 1089 : 	s_psaveInstInfo = g_pCurInstInfo;
; 1090 : 	s_saveRegHasLive1 = g_cpuRegHasLive1;
; 1091 : 	s_saveRegHasSignExt = g_cpuRegHasSignExt;
; 1092 : 
; 1093 : 	// save all mmx regs
; 1094 : 	memcpy_fast(s_saveMMXregs, mmxregs, sizeof(mmxregs));

	mov	edx, OFFSET ?mmxregs@@3PAU_mmxregs@@A	; mmxregs
	mov	WORD PTR _s_savex86FpuState, ax
	mov	ecx, OFFSET ?s_saveMMXregs@@3PAU_mmxregs@@A ; s_saveMMXregs
	movzx	eax, WORD PTR ?iCWstate@@3GA		; iCWstate
	mov	WORD PTR _s_saveiCWstate, ax
	mov	eax, DWORD PTR ?s_nBlockCycles@@3IA	; s_nBlockCycles
	mov	DWORD PTR _s_savenBlockCycles, eax
	mov	eax, DWORD PTR ?g_cpuHasConstReg@@3IA	; g_cpuHasConstReg
	mov	DWORD PTR _s_saveHasConstReg, eax
	mov	eax, DWORD PTR ?g_cpuFlushedConstReg@@3IA ; g_cpuFlushedConstReg
	mov	DWORD PTR _s_saveFlushedConstReg, eax
	mov	eax, DWORD PTR ?g_pCurInstInfo@@3PAUEEINST@@A ; g_pCurInstInfo
	mov	DWORD PTR _s_psaveInstInfo, eax
	mov	eax, DWORD PTR ?g_cpuRegHasLive1@@3IA	; g_cpuRegHasLive1
	mov	DWORD PTR _s_saveRegHasLive1, eax
	mov	eax, DWORD PTR ?g_cpuRegHasSignExt@@3IA	; g_cpuRegHasSignExt
	push	48					; 00000030H
	mov	DWORD PTR ?s_saveConstGPRreg@@3IA, -1	; s_saveConstGPRreg
	mov	DWORD PTR _s_saveRegHasSignExt, eax
	call	?memcpy_amd_@@YIXPAXPBXI@Z		; memcpy_amd_

; 1095 : 	memcpy_fast(s_saveXMMregs, xmmregs, sizeof(xmmregs));

	push	64					; 00000040H
	mov	edx, OFFSET ?xmmregs@@3PAU_xmmregs@@A	; xmmregs
	mov	ecx, OFFSET ?s_saveXMMregs@@3PAU_xmmregs@@A ; s_saveXMMregs
	call	?memcpy_amd_@@YIXPAXPBXI@Z		; memcpy_amd_

; 1096 : }

	ret	0
?SaveBranchState@@YAXXZ ENDP				; SaveBranchState
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86_sse.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\icore.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
_TEXT	SEGMENT
?_eeMoveGPRtoRm@@YAXHH@Z PROC				; _eeMoveGPRtoRm
; _to$dead$ = ecx
; _fromgpr$ = edx

; 387  : {

	push	esi
	mov	esi, edx
	push	edi

; 388  : 	if( GPR_IS_CONST1(fromgpr) )

	mov	edi, 1
	cmp	esi, 32					; 00000020H
	jge	SHORT $LN6@eeMoveGPRt
	mov	eax, edi
	mov	ecx, esi
	shl	eax, cl
	test	DWORD PTR ?g_cpuHasConstReg@@3IA, eax	; g_cpuHasConstReg
	je	SHORT $LN6@eeMoveGPRt
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	ecx, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 389  : 		MOV32ItoRmOffset( to, g_cpuConstRegs[fromgpr].UL[0], 0 );

	shl	esi, 4
	pop	edi
	mov	eax, DWORD PTR ?g_cpuConstRegs@@3PATGPR_reg64@@A[esi]
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	WORD PTR [ecx], 1223			; 000004c7H
	mov	BYTE PTR [ecx+2], 36			; 00000024H

; 1746 : 	x86Ptr += 2;  
; 1747 : } 
; 1748 : 
; 1749 : __forceinline void write24(u32 val ) 
; 1750 : { 
; 1751 : 	*(u8*)x86Ptr = (u8)(val & 0xff); 
; 1752 : 	x86Ptr++;  
; 1753 : 	*(u8*)x86Ptr = (u8)((val >> 8) & 0xff); 
; 1754 : 	x86Ptr++;  
; 1755 : 	*(u8*)x86Ptr = (u8)((val >> 16) & 0xff); 
; 1756 : 	x86Ptr++;  
; 1757 : } 
; 1758 : 
; 1759 : __forceinline void write32(u32 val ) 
; 1760 : { 
; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [ecx+3], eax

; 1762 : 	x86Ptr += 4; 

	add	ecx, 7
	mov	DWORD PTR ?x86Ptr@@3PAEA, ecx		; x86Ptr
	pop	esi
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 405  : }

	ret	0
$LN6@eeMoveGPRt:

; 390  : 	else {
; 391  : 		int mmreg;
; 392  : 		
; 393  : 		if( (mmreg = _checkXMMreg(XMMTYPE_GPRREG, fromgpr, MODE_READ)) >= 0 ) {

	push	1
	mov	ecx, 5
	call	?_checkXMMreg@@YAHHHH@Z			; _checkXMMreg
	mov	edx, eax
	add	esp, 4
	test	edx, edx
	js	SHORT $LN4@eeMoveGPRt
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86_sse.cpp

; 1340 : 	if( g_xmmtypes[from] == XMMT_INT ) SSE2_MOVD_XMM_to_Rm(to, from);

	cmp	DWORD PTR ?g_xmmtypes@@3PAW4XMMSSEType@@A[edx*4], 0
	jne	SHORT $LN74@eeMoveGPRt
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	ecx, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
	and	dl, 7
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp

; 122  : 	write8( ( mod << 6 ) | ( (reg & 7) << 3 ) | ( rm & 7 ) );

	shl	dl, 3
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1745 : 	*(u16*)x86Ptr = (u16)val; 

	mov	eax, 32271				; 00007e0fH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp

; 122  : 	write8( ( mod << 6 ) | ( (reg & 7) << 3 ) | ( rm & 7 ) );

	or	dl, 4
	pop	edi
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	BYTE PTR [ecx], 102			; 00000066H

; 1745 : 	*(u16*)x86Ptr = (u16)val; 

	mov	WORD PTR [ecx+1], ax

; 1739 : 	*x86Ptr = (u8)val; 

	mov	BYTE PTR [ecx+3], dl

; 1740 : 	x86Ptr++; 

	add	ecx, 4
	mov	DWORD PTR ?x86Ptr@@3PAEA, ecx		; x86Ptr
	pop	esi
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 405  : }

	ret	0
$LN74@eeMoveGPRt:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	eax, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
	and	dl, 7
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp

; 122  : 	write8( ( mod << 6 ) | ( (reg & 7) << 3 ) | ( rm & 7 ) );

	shl	dl, 3
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1745 : 	*(u16*)x86Ptr = (u16)val; 

	mov	ecx, 4367				; 0000110fH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp

; 122  : 	write8( ( mod << 6 ) | ( (reg & 7) << 3 ) | ( rm & 7 ) );

	or	dl, 4
	pop	edi
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	BYTE PTR [eax], 243			; 000000f3H

; 1745 : 	*(u16*)x86Ptr = (u16)val; 

	mov	WORD PTR [eax+1], cx

; 1739 : 	*x86Ptr = (u8)val; 

	mov	BYTE PTR [eax+3], dl

; 1740 : 	x86Ptr++; 

	add	eax, 4
	mov	DWORD PTR ?x86Ptr@@3PAEA, eax		; x86Ptr
	pop	esi
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 405  : }

	ret	0
$LN4@eeMoveGPRt:

; 394  : 			SSEX_MOVD_XMM_to_Rm(to, mmreg);
; 395  : 		}
; 396  : 		else if( (mmreg = _checkMMXreg(MMX_GPR+fromgpr, MODE_READ)) >= 0 ) {

	mov	edx, edi
	mov	ecx, esi
	call	?_checkMMXreg@@YAHHH@Z			; _checkMMXreg
	test	eax, eax
	js	SHORT $LN2@eeMoveGPRt
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1745 : 	*(u16*)x86Ptr = (u16)val; 

	mov	ecx, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr

; 1739 : 	*x86Ptr = (u8)val; 

	and	al, 7
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp

; 122  : 	write8( ( mod << 6 ) | ( (reg & 7) << 3 ) | ( rm & 7 ) );

	shl	al, 3
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1745 : 	*(u16*)x86Ptr = (u16)val; 

	mov	edx, 32271				; 00007e0fH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp

; 122  : 	write8( ( mod << 6 ) | ( (reg & 7) << 3 ) | ( rm & 7 ) );

	or	al, 4
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\icore.cpp

; 1135 : 	x86FpuState = MMX_STATE;

	mov	WORD PTR ?x86FpuState@@3GA, di		; x86FpuState
	pop	edi
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1745 : 	*(u16*)x86Ptr = (u16)val; 

	mov	WORD PTR [ecx], dx

; 1739 : 	*x86Ptr = (u8)val; 

	mov	BYTE PTR [ecx+2], al
	mov	BYTE PTR [ecx+3], 36			; 00000024H

; 1740 : 	x86Ptr++; 

	add	ecx, 4
	mov	DWORD PTR ?x86Ptr@@3PAEA, ecx		; x86Ptr
	pop	esi
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 405  : }

	ret	0
$LN2@eeMoveGPRt:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	eax, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 401  : 			MOV32MtoR(EAX, (int)&cpuRegs.GPR.r[ fromgpr ].UL[ 0 ] );

	shl	esi, 4
	add	esi, OFFSET ?cpuRegs@@3UcpuRegisters@@A	; cpuRegs
	pop	edi
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	WORD PTR [eax], 1419			; 0000058bH

; 1746 : 	x86Ptr += 2;  
; 1747 : } 
; 1748 : 
; 1749 : __forceinline void write24(u32 val ) 
; 1750 : { 
; 1751 : 	*(u8*)x86Ptr = (u8)(val & 0xff); 
; 1752 : 	x86Ptr++;  
; 1753 : 	*(u8*)x86Ptr = (u8)((val >> 8) & 0xff); 
; 1754 : 	x86Ptr++;  
; 1755 : 	*(u8*)x86Ptr = (u8)((val >> 16) & 0xff); 
; 1756 : 	x86Ptr++;  
; 1757 : } 
; 1758 : 
; 1759 : __forceinline void write32(u32 val ) 
; 1760 : { 
; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [eax+2], esi

; 1739 : 	*x86Ptr = (u8)val; 

	mov	WORD PTR [eax+6], 1161			; 00000489H
	mov	BYTE PTR [eax+8], 36			; 00000024H

; 1740 : 	x86Ptr++; 

	add	eax, 9
	mov	DWORD PTR ?x86Ptr@@3PAEA, eax		; x86Ptr
	pop	esi
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 405  : }

	ret	0
?_eeMoveGPRtoRm@@YAXHH@Z ENDP				; _eeMoveGPRtoRm
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\exceptions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\exceptions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\exceptions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\exceptions.h
;	COMDAT ??0HardwareDeficiency@Exception@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_msg$ = 8						; size = 4
??0HardwareDeficiency@Exception@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Exception::HardwareDeficiency::HardwareDeficiency, COMDAT
; _this$ = ecx

; 141  : 			RuntimeError( msg ) {}

	push	-1
	push	__ehhandler$??0HardwareDeficiency@Exception@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 726  : 		assign(_Right, 0, npos);

	push	-1
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\exceptions.h

; 76   : 		{}

	lea	ecx, DWORD PTR [esi+4]

; 141  : 			RuntimeError( msg ) {}

	mov	DWORD PTR _this$[esp+24], esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 726  : 		assign(_Right, 0, npos);

	push	0
	push	DWORD PTR _msg$[esp+24]
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\exceptions.h

; 76   : 		{}

	mov	DWORD PTR [esi], OFFSET ??_7BaseException@Exception@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 726  : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\exceptions.h

; 88   : 		{}

	mov	DWORD PTR __$EHRec$[esp+28], 1
	mov	DWORD PTR [esi], OFFSET ??_7RuntimeError@Exception@@6B@

; 141  : 			RuntimeError( msg ) {}

	mov	DWORD PTR __$EHRec$[esp+28], 2
	mov	DWORD PTR [esi], OFFSET ??_7HardwareDeficiency@Exception@@6B@
	mov	DWORD PTR __$EHRec$[esp+28], -1
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0HardwareDeficiency@Exception@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0HardwareDeficiency@Exception@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1BaseException@Exception@@UAE@XZ	; Exception::BaseException::~BaseException
__unwindfunclet$??0HardwareDeficiency@Exception@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1RuntimeError@Exception@@UAE@XZ	; Exception::RuntimeError::~RuntimeError
__ehhandler$??0HardwareDeficiency@Exception@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0HardwareDeficiency@Exception@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0HardwareDeficiency@Exception@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Exception::HardwareDeficiency::HardwareDeficiency
; Function compile flags: /Ogtpy
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\exceptions.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\system.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ??_GHardwareDeficiency@Exception@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_GHardwareDeficiency@Exception@@UAEPAXI@Z PROC	; Exception::HardwareDeficiency::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??_GHardwareDeficiency@Exception@@UAEPAXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	mov	DWORD PTR __$EHRec$[esp+28], -1
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\exceptions.h

; 85   : 		virtual ~RuntimeError() throw() {}

	mov	DWORD PTR [esi], OFFSET ??_7RuntimeError@Exception@@6B@
	mov	DWORD PTR __$EHRec$[esp+28], -1
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\system.cpp

; 43   : 	BaseException::~BaseException() throw() {}

	mov	DWORD PTR [esi], OFFSET ??_7BaseException@Exception@@6B@
	mov	DWORD PTR __$EHRec$[esp+28], -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	jb	SHORT $LN33@scalar
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	push	DWORD PTR [esi+4]
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN33@scalar:
	test	BYTE PTR ___flags$[esp+16], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+24], 15			; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+20], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [esi+4], 0
	je	SHORT $LN45@scalar
	push	esi
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN45@scalar:
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_GHardwareDeficiency@Exception@@UAEPAXI@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1RuntimeError@Exception@@UAE@XZ	; Exception::RuntimeError::~RuntimeError
__unwindfunclet$??_GHardwareDeficiency@Exception@@UAEPAXI@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1BaseException@Exception@@UAE@XZ	; Exception::BaseException::~BaseException
__unwindfunclet$??_GHardwareDeficiency@Exception@@UAEPAXI@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??_GHardwareDeficiency@Exception@@UAEPAXI@Z:
	mov	eax, OFFSET __ehfuncinfo$??_GHardwareDeficiency@Exception@@UAEPAXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??_GHardwareDeficiency@Exception@@UAEPAXI@Z ENDP	; Exception::HardwareDeficiency::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\exceptions.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\system.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
;	COMDAT ??1HardwareDeficiency@Exception@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1HardwareDeficiency@Exception@@UAE@XZ PROC		; Exception::HardwareDeficiency::~HardwareDeficiency, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??1HardwareDeficiency@Exception@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	mov	DWORD PTR __$EHRec$[esp+28], -1
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\exceptions.h

; 85   : 		virtual ~RuntimeError() throw() {}

	mov	DWORD PTR [esi], OFFSET ??_7RuntimeError@Exception@@6B@
	mov	DWORD PTR __$EHRec$[esp+28], -1
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\system.cpp

; 43   : 	BaseException::~BaseException() throw() {}

	mov	DWORD PTR [esi], OFFSET ??_7BaseException@Exception@@6B@
	mov	DWORD PTR __$EHRec$[esp+28], -1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	jb	SHORT $LN30@HardwareDe
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 573  : 		::operator delete(_Ptr);

	push	DWORD PTR [esi+4]
	call	DWORD PTR __imp_??3@YAXPAX@Z
	add	esp, 4
$LN30@HardwareDe:
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+24], 15			; 0000000fH

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+20], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [esi+4], 0
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1HardwareDeficiency@Exception@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1RuntimeError@Exception@@UAE@XZ	; Exception::RuntimeError::~RuntimeError
__unwindfunclet$??1HardwareDeficiency@Exception@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1BaseException@Exception@@UAE@XZ	; Exception::BaseException::~BaseException
__unwindfunclet$??1HardwareDeficiency@Exception@@UAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??1HardwareDeficiency@Exception@@UAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1HardwareDeficiency@Exception@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1HardwareDeficiency@Exception@@UAE@XZ ENDP		; Exception::HardwareDeficiency::~HardwareDeficiency
; Function compile flags: /Ogtpy
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\baseblockex.h
;	COMDAT ?GetFnptr@BASEBLOCK@@QBE?BIXZ
_TEXT	SEGMENT
?GetFnptr@BASEBLOCK@@QBE?BIXZ PROC			; BASEBLOCK::GetFnptr, COMDAT
; _this$ = ecx

; 35   : 	const uptr GetFnptr() const { return ((u32)m_pFnptr)<<4; }

	mov	eax, DWORD PTR [ecx]
	shl	eax, 4
	ret	0
?GetFnptr@BASEBLOCK@@QBE?BIXZ ENDP			; BASEBLOCK::GetFnptr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\baseblockex.h
;	COMDAT ?SetFnptr@BASEBLOCK@@QAEXI@Z
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
?SetFnptr@BASEBLOCK@@QAEXI@Z PROC			; BASEBLOCK::SetFnptr, COMDAT
; _this$ = ecx

; 38   : 		// 16 byte alignments only, please!
; 39   : 		jASSUME( (ptr & 0xf) == 0 );
; 40   : 		m_pFnptr = ptr>>4;

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR _ptr$[esp-4]
	and	eax, -268435456				; f0000000H
	shr	edx, 4
	or	edx, eax
	mov	DWORD PTR [ecx], edx

; 41   : 	}

	ret	4
?SetFnptr@BASEBLOCK@@QAEXI@Z ENDP			; BASEBLOCK::SetFnptr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\baseblockex.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
_TEXT	SEGMENT
?PC_GETBLOCKEX@@YAPAUBASEBLOCKEX@@PAUBASEBLOCK@@@Z PROC	; PC_GETBLOCKEX
; _p$ = ecx
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\baseblockex.cpp

; 133  : 	return s_vecBaseBlocksEx[cpu].blocks[s_vecBaseBlocksEx[cpu].Get(startpc)];

	push	DWORD PTR [ecx+4]
	mov	ecx, OFFSET _s_vecBaseBlocksEx
	call	?Get@BASEBLOCKS@@QAEHI@Z		; BASEBLOCKS::Get
	mov	ecx, eax
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 131  : 	return GetBaseBlockEx(p->startpc, 0);

	mov	eax, DWORD PTR _s_vecBaseBlocksEx
	mov	eax, DWORD PTR [eax+ecx*4]

; 132  : }

	ret	0
?PC_GETBLOCKEX@@YAPAUBASEBLOCKEX@@PAUBASEBLOCK@@@Z ENDP	; PC_GETBLOCKEX
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
_TEXT	SEGMENT
?_eeGetConstReg@@YAPAIH@Z PROC				; _eeGetConstReg
; _reg$ = ecx

; 327  : 	assert( GPR_IS_CONST1( reg ) );
; 328  : 
; 329  : 	if( g_cpuFlushedConstReg & (1<<reg) )

	mov	eax, 1
	shl	eax, cl
	push	esi
	mov	esi, ecx
	test	DWORD PTR ?g_cpuFlushedConstReg@@3IA, eax ; g_cpuFlushedConstReg
	jne	SHORT $LN8@eeGetConst

; 330  : 		return &cpuRegs.GPR.r[ reg ].UL[0];
; 331  : 
; 332  : 	// if written in the future, don't flush
; 333  : 	if( _recIsRegWritten(g_pCurInstInfo+1, (s_nEndBlock-pc)/4, XMMTYPE_GPRREG, reg) ) {

	mov	ecx, DWORD PTR ?g_pCurInstInfo@@3PAUEEINST@@A ; g_pCurInstInfo
	mov	edx, DWORD PTR _s_nEndBlock
	sub	edx, DWORD PTR ?pc@@3IA			; pc
	push	esi
	push	5
	shr	edx, 2
	lea	ecx, DWORD PTR [ecx+112]
	call	?_recIsRegWritten@@YAIPAUEEINST@@HEE@Z	; _recIsRegWritten
	add	esp, 8
	test	eax, eax
	je	SHORT $LN1@eeGetConst

; 344  : 
; 345  : void _eeMoveGPRtoR(x86IntRegType to, int fromgpr)
; 346  : {
; 347  : 	if( GPR_IS_CONST1(fromgpr) )
; 348  : 		MOV32ItoR( to, g_cpuConstRegs[fromgpr].UL[0] );
; 349  : 	else {
; 350  : 		int mmreg;
; 351  : 		
; 352  : 		if( (mmreg = _checkXMMreg(XMMTYPE_GPRREG, fromgpr, MODE_READ)) >= 0 && (xmmregs[mmreg].mode&MODE_WRITE)) {
; 353  : 			SSE2_MOVD_XMM_to_R(to, mmreg);
; 354  : 		}
; 355  : 		else if( (mmreg = _checkMMXreg(MMX_GPR+fromgpr, MODE_READ)) >= 0 && (mmxregs[mmreg].mode&MODE_WRITE) ) {
; 356  : 			MOVD32MMXtoR(to, mmreg);
; 357  : 			SetMMXstate();
; 358  : 		}
; 359  : 		else {
; 360  : 			MOV32MtoR(to, (int)&cpuRegs.GPR.r[ fromgpr ].UL[ 0 ] );
; 361  : 		}
; 362  : 	}
; 363  : }
; 364  : 
; 365  : void _eeMoveGPRtoM(u32 to, int fromgpr)
; 366  : {
; 367  : 	if( GPR_IS_CONST1(fromgpr) )
; 368  : 		MOV32ItoM( to, g_cpuConstRegs[fromgpr].UL[0] );
; 369  : 	else {
; 370  : 		int mmreg;
; 371  : 		
; 372  : 		if( (mmreg = _checkXMMreg(XMMTYPE_GPRREG, fromgpr, MODE_READ)) >= 0 ) {
; 373  : 			SSEX_MOVD_XMM_to_M32(to, mmreg);
; 374  : 		}
; 375  : 		else if( (mmreg = _checkMMXreg(MMX_GPR+fromgpr, MODE_READ)) >= 0 ) {
; 376  : 			MOVDMMXtoM(to, mmreg);
; 377  : 			SetMMXstate();
; 378  : 		}
; 379  : 		else {
; 380  : 			MOV32MtoR(EAX, (int)&cpuRegs.GPR.r[ fromgpr ].UL[ 0 ] );
; 381  : 			MOV32RtoM(to, EAX );
; 382  : 		}
; 383  : 	}
; 384  : }
; 385  : 
; 386  : void _eeMoveGPRtoRm(x86IntRegType to, int fromgpr)
; 387  : {
; 388  : 	if( GPR_IS_CONST1(fromgpr) )
; 389  : 		MOV32ItoRmOffset( to, g_cpuConstRegs[fromgpr].UL[0], 0 );
; 390  : 	else {
; 391  : 		int mmreg;
; 392  : 		
; 393  : 		if( (mmreg = _checkXMMreg(XMMTYPE_GPRREG, fromgpr, MODE_READ)) >= 0 ) {
; 394  : 			SSEX_MOVD_XMM_to_Rm(to, mmreg);
; 395  : 		}
; 396  : 		else if( (mmreg = _checkMMXreg(MMX_GPR+fromgpr, MODE_READ)) >= 0 ) {
; 397  : 			MOVD32MMXtoRm(to, mmreg);
; 398  : 			SetMMXstate();
; 399  : 		}
; 400  : 		else {
; 401  : 			MOV32MtoR(EAX, (int)&cpuRegs.GPR.r[ fromgpr ].UL[ 0 ] );
; 402  : 			MOV32RtoRm(to, EAX );
; 403  : 		}
; 404  : 	}
; 405  : }
; 406  : 
; 407  : int _flushXMMunused()
; 408  : {
; 409  : 	int i;
; 410  : 	for (i=0; i<XMMREGS; i++) {
; 411  : 		if (!xmmregs[i].inuse || xmmregs[i].needed || !(xmmregs[i].mode&MODE_WRITE) ) continue;
; 412  : 		
; 413  : 		if (xmmregs[i].type == XMMTYPE_GPRREG ) {
; 414  : 			//if( !(g_pCurInstInfo->regs[xmmregs[i].reg]&EEINST_USED) ) {
; 415  : 			if( !_recIsRegWritten(g_pCurInstInfo+1, (s_nEndBlock-pc)/4, XMMTYPE_GPRREG, xmmregs[i].reg) ) {
; 416  : 				_freeXMMreg(i);
; 417  : 				xmmregs[i].inuse = 1;
; 418  : 				return 1;
; 419  : 			}
; 420  : 		}
; 421  : 	}
; 422  : 
; 423  : 	return 0;
; 424  : }
; 425  : 
; 426  : int _flushMMXunused()
; 427  : {
; 428  : 	int i;
; 429  : 	for (i=0; i<MMXREGS; i++) {
; 430  : 		if (!mmxregs[i].inuse || mmxregs[i].needed || !(mmxregs[i].mode&MODE_WRITE) ) continue;
; 431  : 		
; 432  : 		if( MMX_ISGPR(mmxregs[i].reg) ) {
; 433  : 			//if( !(g_pCurInstInfo->regs[mmxregs[i].reg-MMX_GPR]&EEINST_USED) ) {
; 434  : 			if( !_recIsRegWritten(g_pCurInstInfo+1, (s_nEndBlock-pc)/4, XMMTYPE_GPRREG, mmxregs[i].reg-MMX_GPR) ) {
; 435  : 				_freeMMXreg(i);
; 436  : 				mmxregs[i].inuse = 1;
; 437  : 				return 1;
; 438  : 			}
; 439  : 		}
; 440  : 	}
; 441  : 
; 442  : 	return 0;
; 443  : }
; 444  : 
; 445  : int _flushUnusedConstReg()
; 446  : {
; 447  : 	int i;
; 448  : 	for(i = 1; i < 32; ++i) {
; 449  : 		if( (g_cpuHasConstReg & (1<<i)) && !(g_cpuFlushedConstReg&(1<<i)) &&
; 450  : 			!_recIsRegWritten(g_pCurInstInfo+1, (s_nEndBlock-pc)/4, XMMTYPE_GPRREG, i) ) {
; 451  : 
; 452  : 			// check if will be written in the future
; 453  : 			MOV32ItoM((uptr)&cpuRegs.GPR.r[i].UL[0], g_cpuConstRegs[i].UL[0]);
; 454  : 			MOV32ItoM((uptr)&cpuRegs.GPR.r[i].UL[1], g_cpuConstRegs[i].UL[1]);
; 455  : 			g_cpuFlushedConstReg |= 1<<i;
; 456  : 			return 1;
; 457  : 		}
; 458  : 	}
; 459  : 
; 460  : 	return 0;
; 461  : }
; 462  : 
; 463  : u32* recAllocStackMem(int size, int align)
; 464  : {
; 465  : 	// write to a temp loc, trick
; 466  : 	if( (u32)recStackPtr % align ) recStackPtr += align - ((u32)recStackPtr%align);

	mov	ecx, DWORD PTR _recStackPtr
	mov	edx, ecx
	and	edx, 3
	je	SHORT $LN5@eeGetConst
	mov	eax, 4
	sub	eax, edx
	add	ecx, eax
$LN5@eeGetConst:

; 467  : 	recStackPtr += size;

	add	ecx, 8

; 334  : 		u32* ptempmem;
; 335  : 		ptempmem = recAllocStackMem(8, 4);
; 336  : 		ptempmem[0] = g_cpuConstRegs[ reg ].UL[0];

	shl	esi, 4

; 468  : 	return (u32*)(recStackPtr-size);

	lea	eax, DWORD PTR [ecx-8]
	mov	DWORD PTR _recStackPtr, ecx

; 334  : 		u32* ptempmem;
; 335  : 		ptempmem = recAllocStackMem(8, 4);
; 336  : 		ptempmem[0] = g_cpuConstRegs[ reg ].UL[0];

	mov	ecx, DWORD PTR ?g_cpuConstRegs@@3PATGPR_reg64@@A[esi]
	mov	DWORD PTR [eax], ecx

; 337  : 		ptempmem[1] = g_cpuConstRegs[ reg ].UL[1];

	mov	ecx, DWORD PTR ?g_cpuConstRegs@@3PATGPR_reg64@@A[esi+4]
	mov	DWORD PTR [eax+4], ecx
	pop	esi

; 343  : }

	ret	0
$LN1@eeGetConst:

; 338  : 		return ptempmem;
; 339  : 	}
; 340  : 	
; 341  : 	_flushConstReg(reg);

	mov	ecx, esi
	call	?_flushConstReg@@YAXH@Z			; _flushConstReg
$LN8@eeGetConst:

; 342  : 	return &cpuRegs.GPR.r[ reg ].UL[0];

	shl	esi, 4
	add	esi, OFFSET ?cpuRegs@@3UcpuRegisters@@A	; cpuRegs
	mov	eax, esi
	pop	esi

; 343  : }

	ret	0
?_eeGetConstReg@@YAPAIH@Z ENDP				; _eeGetConstReg
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
_TEXT	SEGMENT
?_flushXMMunused@@YAHXZ PROC				; _flushXMMunused

; 408  : {

	push	ebx

; 409  : 	int i;
; 410  : 	for (i=0; i<XMMREGS; i++) {

	mov	ebx, DWORD PTR ?pc@@3IA			; pc
	push	ebp
	mov	ebp, DWORD PTR ?g_pCurInstInfo@@3PAUEEINST@@A ; g_pCurInstInfo
	push	esi
	push	edi
	mov	edi, DWORD PTR _s_nEndBlock
	xor	esi, esi
	npad	8
$LL7@flushXMMun:

; 411  : 		if (!xmmregs[i].inuse || xmmregs[i].needed || !(xmmregs[i].mode&MODE_WRITE) ) continue;

	cmp	BYTE PTR ?xmmregs@@3PAU_xmmregs@@A[esi*8], 0
	je	SHORT $LN6@flushXMMun
	cmp	BYTE PTR ?xmmregs@@3PAU_xmmregs@@A[esi*8+4], 0
	jne	SHORT $LN6@flushXMMun
	test	BYTE PTR ?xmmregs@@3PAU_xmmregs@@A[esi*8+3], 2
	je	SHORT $LN6@flushXMMun

; 412  : 		
; 413  : 		if (xmmregs[i].type == XMMTYPE_GPRREG ) {

	cmp	BYTE PTR ?xmmregs@@3PAU_xmmregs@@A[esi*8+2], 5
	jne	SHORT $LN6@flushXMMun

; 414  : 			//if( !(g_pCurInstInfo->regs[xmmregs[i].reg]&EEINST_USED) ) {
; 415  : 			if( !_recIsRegWritten(g_pCurInstInfo+1, (s_nEndBlock-pc)/4, XMMTYPE_GPRREG, xmmregs[i].reg) ) {

	movzx	eax, BYTE PTR ?xmmregs@@3PAU_xmmregs@@A[esi*8+1]
	lea	ecx, DWORD PTR [ebp+112]
	mov	edx, edi
	push	eax
	sub	edx, ebx
	push	5
	shr	edx, 2
	call	?_recIsRegWritten@@YAIPAUEEINST@@HEE@Z	; _recIsRegWritten
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@flushXMMun
$LN6@flushXMMun:

; 409  : 	int i;
; 410  : 	for (i=0; i<XMMREGS; i++) {

	inc	esi
	cmp	esi, 8
	jl	SHORT $LL7@flushXMMun

; 419  : 			}
; 420  : 		}
; 421  : 	}
; 422  : 
; 423  : 	return 0;

	pop	edi
	pop	esi
	pop	ebp
	xor	eax, eax
	pop	ebx

; 424  : }

	ret	0
$LN11@flushXMMun:

; 416  : 				_freeXMMreg(i);

	mov	ecx, esi
	call	?_freeXMMreg@@YAXH@Z			; _freeXMMreg
	pop	edi

; 417  : 				xmmregs[i].inuse = 1;

	mov	BYTE PTR ?xmmregs@@3PAU_xmmregs@@A[esi*8], 1

; 418  : 				return 1;

	mov	eax, 1
	pop	esi
	pop	ebp
	pop	ebx

; 424  : }

	ret	0
?_flushXMMunused@@YAHXZ ENDP				; _flushXMMunused
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
_TEXT	SEGMENT
?_flushMMXunused@@YAHXZ PROC				; _flushMMXunused

; 427  : {

	push	ebx

; 428  : 	int i;
; 429  : 	for (i=0; i<MMXREGS; i++) {

	mov	ebx, DWORD PTR _s_nEndBlock
	push	ebp
	mov	ebp, DWORD PTR ?pc@@3IA			; pc
	push	esi
	push	edi
	xor	edi, edi
	mov	esi, OFFSET ?mmxregs@@3PAU_mmxregs@@A+3
$LL7@flushMMXun:

; 430  : 		if (!mmxregs[i].inuse || mmxregs[i].needed || !(mmxregs[i].mode&MODE_WRITE) ) continue;

	cmp	BYTE PTR [esi-3], 0
	je	SHORT $LN6@flushMMXun
	cmp	BYTE PTR [esi], 0
	jne	SHORT $LN6@flushMMXun
	test	BYTE PTR [esi-1], 2
	je	SHORT $LN6@flushMMXun

; 431  : 		
; 432  : 		if( MMX_ISGPR(mmxregs[i].reg) ) {

	mov	al, BYTE PTR [esi-2]
	cmp	al, 34					; 00000022H
	jae	SHORT $LN6@flushMMXun

; 433  : 			//if( !(g_pCurInstInfo->regs[mmxregs[i].reg-MMX_GPR]&EEINST_USED) ) {
; 434  : 			if( !_recIsRegWritten(g_pCurInstInfo+1, (s_nEndBlock-pc)/4, XMMTYPE_GPRREG, mmxregs[i].reg-MMX_GPR) ) {

	mov	ecx, DWORD PTR ?g_pCurInstInfo@@3PAUEEINST@@A ; g_pCurInstInfo
	mov	edx, ebx
	push	eax
	sub	edx, ebp
	push	5
	shr	edx, 2
	lea	ecx, DWORD PTR [ecx+112]
	call	?_recIsRegWritten@@YAIPAUEEINST@@HEE@Z	; _recIsRegWritten
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@flushMMXun
$LN6@flushMMXun:

; 428  : 	int i;
; 429  : 	for (i=0; i<MMXREGS; i++) {

	add	esi, 6
	inc	edi
	cmp	esi, OFFSET ?mmxregs@@3PAU_mmxregs@@A+51
	jl	SHORT $LL7@flushMMXun

; 438  : 			}
; 439  : 		}
; 440  : 	}
; 441  : 
; 442  : 	return 0;

	pop	edi
	pop	esi
	pop	ebp
	xor	eax, eax
	pop	ebx

; 443  : }

	ret	0
$LN11@flushMMXun:

; 435  : 				_freeMMXreg(i);

	mov	ecx, edi
	call	?_freeMMXreg@@YAXH@Z			; _freeMMXreg

; 436  : 				mmxregs[i].inuse = 1;

	lea	eax, DWORD PTR [edi+edi*2]
	pop	edi
	pop	esi
	pop	ebp
	mov	BYTE PTR ?mmxregs@@3PAU_mmxregs@@A[eax*2], 1

; 437  : 				return 1;

	mov	eax, 1
	pop	ebx

; 443  : }

	ret	0
?_flushMMXunused@@YAHXZ ENDP				; _flushMMXunused
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
_TEXT	SEGMENT
?recAllocStackMem@@YAPAIHH@Z PROC			; recAllocStackMem
; _size$dead$ = ecx
; _align$ = edx

; 465  : 	// write to a temp loc, trick
; 466  : 	if( (u32)recStackPtr % align ) recStackPtr += align - ((u32)recStackPtr%align);

	mov	ecx, DWORD PTR _recStackPtr
	mov	eax, ecx
	push	esi
	mov	esi, edx
	xor	edx, edx
	div	esi
	test	edx, edx
	je	SHORT $LN1@recAllocSt
	sub	esi, edx
	add	ecx, esi
$LN1@recAllocSt:

; 467  : 	recStackPtr += size;

	add	ecx, 8
	mov	DWORD PTR _recStackPtr, ecx
	pop	esi

; 468  : 	return (u32*)(recStackPtr-size);

	lea	eax, DWORD PTR [ecx-8]

; 469  : }

	ret	0
?recAllocStackMem@@YAPAIHH@Z ENDP			; recAllocStackMem
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\exceptions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\exceptions.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\windows\winsysexec.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\system.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\windows\winsysexec.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\system.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
_TEXT	SEGMENT
$T2 = -328						; size = 28
$T3 = -300						; size = 24
$T4 = -276						; size = 24
$T5 = -252						; size = 24
$T6 = -228						; size = 24
$T7 = -204						; size = 24
$T8 = -180						; size = 24
$T9 = -156						; size = 28
$T10 = -128						; size = 28
$T11 = -100						; size = 28
$T12 = -72						; size = 28
$T13 = -44						; size = 28
__$EHRec$ = -12						; size = 12
?recAlloc@@YAXXZ PROC					; recAlloc

; 484  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?recAlloc@@YAXXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 320				; 00000140H

; 485  : 	// Hardware Requirements Check...
; 486  : 
; 487  : 	if ( !( cpucaps.hasMultimediaExtensions  ) )

	cmp	DWORD PTR ?cpucaps@@3UCAPABILITIES@@A+80, 0
	push	esi
	jne	$LN10@recAlloc

; 488  : 		throw Exception::HardwareDeficiency( _( "Processor doesn't support MMX" ) );

	push	OFFSET ??_C@_0BO@BJGNDGDH@Processor?5doesn?8t?5support?5MMX?$AA@
	push	OFFSET ??_C@_05FFJFDMOL@pcsx2?$AA@
	call	DWORD PTR __imp__dgettext
	mov	edx, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 494  : 		_Mysize = 0;

	mov	DWORD PTR $T3[esp+360], 0

; 495  : 		_Myres = 0;

	mov	DWORD PTR $T3[esp+364], 0
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 488  : 		throw Exception::HardwareDeficiency( _( "Processor doesn't support MMX" ) );

	add	esp, 8
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T3[esp+356], 15		; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T3[esp+352], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T3[esp+336], 0

; 523  : 			: _CSTD strlen(_First));

	cmp	BYTE PTR [edx], 0
	jne	SHORT $LN61@recAlloc
	xor	ecx, ecx
	jmp	SHORT $LN62@recAlloc
$LN61@recAlloc:
	mov	ecx, edx
	lea	esi, DWORD PTR [ecx+1]
$LL132@recAlloc:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL132@recAlloc
	sub	ecx, esi
$LN62@recAlloc:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	ecx
	push	edx
	lea	ecx, DWORD PTR $T3[esp+344]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 488  : 		throw Exception::HardwareDeficiency( _( "Processor doesn't support MMX" ) );

	mov	DWORD PTR __$EHRec$[esp+344], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 726  : 		assign(_Right, 0, npos);

	lea	eax, DWORD PTR $T3[esp+336]
	push	-1
	push	0

; 494  : 		_Mysize = 0;

	mov	DWORD PTR $T2[esp+364], 0

; 726  : 		assign(_Right, 0, npos);

	lea	ecx, DWORD PTR $T2[esp+348]

; 495  : 		_Myres = 0;

	mov	DWORD PTR $T2[esp+368], 0

; 726  : 		assign(_Right, 0, npos);

	push	eax
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\exceptions.h

; 76   : 		{}

	mov	DWORD PTR $T2[esp+348], OFFSET ??_7BaseException@Exception@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T2[esp+372], 15		; 0000000fH

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T2[esp+368], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T2[esp+352], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 726  : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\exceptions.h

; 88   : 		{}

	mov	BYTE PTR __$EHRec$[esp+344], 2
	mov	DWORD PTR $T2[esp+336], OFFSET ??_7RuntimeError@Exception@@6B@

; 89   : 	};
; 90   : 
; 91   : 	class LogicError : public BaseException
; 92   : 	{
; 93   : 	public:
; 94   : 		virtual ~LogicError() throw() {}
; 95   : 		explicit LogicError( const std::string& msg="An unhandled logic error has occured." ) :
; 96   : 			BaseException( msg )
; 97   : 		{}
; 98   : 	};
; 99   : 	
; 100  : 	class OutOfMemory : public RuntimeError
; 101  : 	{
; 102  : 	public:
; 103  : 		explicit OutOfMemory( const std::string& msg="Out of memory!" ) :
; 104  : 			RuntimeError( msg ) {}
; 105  : 	};
; 106  : 
; 107  : 	// This exception thrown any time an operation is attempted when an object
; 108  : 	// is in an uninitialized state.
; 109  : 	class InvalidOperation : public LogicError
; 110  : 	{
; 111  : 	public:
; 112  : 		virtual ~InvalidOperation() throw() {}
; 113  : 		explicit InvalidOperation( const std::string& msg="Attempted method call is invalid for the current object or program state." ) :
; 114  : 			LogicError( msg ) {}
; 115  : 	};
; 116  : 
; 117  : 	// This exception thrown any time an operation is attempted when an object
; 118  : 	// is in an uninitialized state.
; 119  : 	class InvalidArgument : public LogicError
; 120  : 	{
; 121  : 	public:
; 122  : 		virtual ~InvalidArgument() throw() {}
; 123  : 		explicit InvalidArgument( const std::string& msg="Invalid argument passed to a function." ) :
; 124  : 			LogicError( msg ) {}
; 125  : 	};
; 126  : 
; 127  : 	// Keep those array indexers in bounds when using the SafeArray type, or you'll be
; 128  : 	// seeing these.
; 129  : 	class IndexBoundsFault : public LogicError
; 130  : 	{
; 131  : 	public:
; 132  : 		virtual ~IndexBoundsFault() throw() {}
; 133  : 		explicit IndexBoundsFault( const std::string& msg="Array index is outsides the bounds of an array." ) :
; 134  : 			LogicError( msg ) {}
; 135  : 	};
; 136  : 
; 137  : 	class HardwareDeficiency : public RuntimeError
; 138  : 	{
; 139  : 	public:
; 140  : 		explicit HardwareDeficiency( const std::string& msg="Your machine's hardware is incapable of running Pcsx2.  Sorry dood." ) :
; 141  : 			RuntimeError( msg ) {}

	mov	BYTE PTR __$EHRec$[esp+344], 3
	mov	DWORD PTR $T2[esp+336], OFFSET ??_7HardwareDeficiency@Exception@@6B@
	mov	BYTE PTR __$EHRec$[esp+344], 0
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 488  : 		throw Exception::HardwareDeficiency( _( "Processor doesn't support MMX" ) );

	lea	eax, DWORD PTR $T2[esp+336]
	push	OFFSET __TI3?AVHardwareDeficiency@Exception@@
	push	eax
	call	__CxxThrowException@8
$LN135@recAlloc:
$LN10@recAlloc:

; 489  : 
; 490  : 	if ( !( cpucaps.hasStreamingSIMDExtensions ) )

	cmp	DWORD PTR ?cpucaps@@3UCAPABILITIES@@A+88, 0
	jne	SHORT $LN9@recAlloc

; 491  : 		throw Exception::HardwareDeficiency( _( "Processor doesn't support SSE" ) );

	push	OFFSET ??_C@_0BO@EAHPPEPN@Processor?5doesn?8t?5support?5SSE?$AA@
	push	OFFSET ??_C@_05FFJFDMOL@pcsx2?$AA@
	call	DWORD PTR __imp__dgettext
	add	esp, 8
	lea	ecx, DWORD PTR $T6[esp+336]
	push	eax
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[esp+344], 4
	lea	eax, DWORD PTR $T6[esp+336]
	push	eax
	lea	ecx, DWORD PTR $T9[esp+340]
	call	??0HardwareDeficiency@Exception@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Exception::HardwareDeficiency::HardwareDeficiency
	push	OFFSET __TI3?AVHardwareDeficiency@Exception@@
	lea	eax, DWORD PTR $T9[esp+340]
	push	eax
	call	__CxxThrowException@8
$LN136@recAlloc:
$LN9@recAlloc:

; 492  : 
; 493  : 	if ( !( cpucaps.hasStreamingSIMD2Extensions ) )

	cmp	DWORD PTR ?cpucaps@@3UCAPABILITIES@@A+92, 0
	jne	SHORT $LN8@recAlloc

; 494  : 		throw Exception::HardwareDeficiency( _( "Processor doesn't support SSE2" ) );

	push	OFFSET ??_C@_0BP@CODMKFCE@Processor?5doesn?8t?5support?5SSE2?$AA@
	push	OFFSET ??_C@_05FFJFDMOL@pcsx2?$AA@
	call	DWORD PTR __imp__dgettext
	add	esp, 8
	lea	ecx, DWORD PTR $T8[esp+336]
	push	eax
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[esp+344], 5
	lea	eax, DWORD PTR $T8[esp+336]
	push	eax
	lea	ecx, DWORD PTR $T12[esp+340]
	call	??0HardwareDeficiency@Exception@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Exception::HardwareDeficiency::HardwareDeficiency
	push	OFFSET __TI3?AVHardwareDeficiency@Exception@@
	lea	eax, DWORD PTR $T12[esp+340]
	push	eax
	call	__CxxThrowException@8
$LN137@recAlloc:
$LN8@recAlloc:

; 495  : 
; 496  : 	if( recLUT == NULL )

	cmp	DWORD PTR ?recLUT@@3PAIA, 0		; recLUT
	jne	SHORT $LN7@recAlloc

; 497  : 		recLUT = (uptr*) _aligned_malloc( 0x010000 * sizeof(uptr), 16 );

	push	16					; 00000010H
	push	262144					; 00040000H
	call	DWORD PTR __imp___aligned_malloc
	add	esp, 8
	mov	DWORD PTR ?recLUT@@3PAIA, eax		; recLUT
$LN7@recAlloc:

; 498  : 
; 499  : 	if( recMem == NULL )

	mov	esi, DWORD PTR _recMem
	test	esi, esi
	jne	$LN5@recAlloc
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\windows\winsysexec.cpp

; 903  : 	mem = VirtualAlloc((void*)base, size, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);

	push	64					; 00000040H
	push	12288					; 00003000H
	push	16781312				; 01001000H
	push	536870912				; 20000000H
	call	DWORD PTR __imp__VirtualAlloc@16
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\system.cpp

; 313  : 	u8 *Mem = (u8*)SysMmap( base, size );

	mov	esi, eax

; 314  : 
; 315  : 	if( (Mem == NULL) || (bounds != 0 && (((uptr)Mem + size) > bounds)) )

	test	esi, esi
	jne	SHORT $LN114@recAlloc

; 316  : 	{
; 317  : 		DevCon::Notice( "First try failed allocating %s at address 0x%x", params caller, base );

	push	536870912				; 20000000H
	push	OFFSET ??_C@_0BA@GOFBLDMA@recAlloc?$CIR5900?$CJ?$AA@
	push	eax
	push	OFFSET ??_C@_0CP@LIOIKNAO@First?5try?5failed?5allocating?5?$CFs?5a@
	call	?Notice@Console@@YA_NPBDPBU_VARG_PARAM@@ZZ ; Console::Notice
	add	esp, 16					; 00000010H
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\windows\winsysexec.cpp

; 903  : 	mem = VirtualAlloc((void*)base, size, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);

	push	64					; 00000040H
	push	12288					; 00003000H
	push	16781312				; 01001000H
	push	esi
	call	DWORD PTR __imp__VirtualAlloc@16
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\system.cpp

; 324  : 		Mem = (u8*)SysMmap( NULL, size );

	mov	esi, eax
$LN114@recAlloc:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 506  : 		recMem = (u8*)SysMmapEx( 0x20000000, cachememsize, 0, "recAlloc(R5900)" );

	mov	DWORD PTR _recMem, esi

; 507  : 	}
; 508  : 
; 509  : 	if( recMem == NULL )

	test	esi, esi
	jne	SHORT $LN5@recAlloc

; 510  : 		throw Exception::OutOfMemory( "R5900-32 > failed to allocate recompiler memory." );

	push	OFFSET ??_C@_0DB@KMMEHCKA@R5900?932?5?$DO?5failed?5to?5allocate?5re@
	lea	ecx, DWORD PTR $T7[esp+340]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[esp+344], 6
	lea	eax, DWORD PTR $T7[esp+336]
	push	eax
	lea	ecx, DWORD PTR $T10[esp+340]
	call	??0OutOfMemory@Exception@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Exception::OutOfMemory::OutOfMemory
	push	OFFSET __TI3?AVOutOfMemory@Exception@@
	lea	eax, DWORD PTR $T10[esp+340]
	push	eax
	call	__CxxThrowException@8
$LN138@recAlloc:
$LN5@recAlloc:

; 511  : 
; 512  : 	// Goal: Allocate BASEBLOCKs for every possible branch target in PS2 memory.
; 513  : 	// Any 4-byte aligned address makes a valid branch target as per MIPS design (all instructions are
; 514  : 	// always 4 bytes long).
; 515  : 
; 516  :     if( m_recBlockAlloc == NULL )

	mov	eax, DWORD PTR _m_recBlockAlloc
	test	eax, eax
	jne	SHORT $LN3@recAlloc

; 517  : 		m_recBlockAlloc = (u8*) _aligned_malloc( m_recBlockAllocSize, 4096 );

	push	4096					; 00001000H
	push	76873728				; 04950000H
	call	DWORD PTR __imp___aligned_malloc
	add	esp, 8
	mov	DWORD PTR _m_recBlockAlloc, eax

; 518  : 
; 519  : 	if( m_recBlockAlloc == NULL )

	test	eax, eax
	jne	SHORT $LN3@recAlloc

; 520  : 		throw Exception::OutOfMemory( "R5900-32 Init > Failed to allocate memory for BASEBLOCK tables." );

	push	OFFSET ??_C@_0EA@NGEJMDFP@R5900?932?5Init?5?$DO?5Failed?5to?5alloca@
	lea	ecx, DWORD PTR $T5[esp+340]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[esp+344], 7
	lea	eax, DWORD PTR $T5[esp+336]
	push	eax
	lea	ecx, DWORD PTR $T11[esp+340]
	call	??0OutOfMemory@Exception@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Exception::OutOfMemory::OutOfMemory
	push	OFFSET __TI3?AVOutOfMemory@Exception@@
	lea	eax, DWORD PTR $T11[esp+340]
	push	eax
	call	__CxxThrowException@8
$LN139@recAlloc:
$LN3@recAlloc:

; 521  : 
; 522  : 	u8* curpos = m_recBlockAlloc;
; 523  : 	recRAM = (BASEBLOCK*)curpos; curpos += (Ps2MemSize::Base / 4) * sizeof(BASEBLOCK);

	mov	DWORD PTR _recRAM, eax
	add	eax, 67108864				; 04000000H

; 524  : 	recROM = (BASEBLOCK*)curpos; curpos += (Ps2MemSize::Rom / 4) * sizeof(BASEBLOCK);

	mov	DWORD PTR _recROM, eax
	add	eax, 8388608				; 00800000H

; 525  : 	recROM1 = (BASEBLOCK*)curpos; curpos += (Ps2MemSize::Rom1 / 4) * sizeof(BASEBLOCK);

	mov	DWORD PTR _recROM1, eax
	add	eax, 524288				; 00080000H

; 526  : 	recBlocks = (BASEBLOCKEX*)curpos; curpos += sizeof(BASEBLOCKEX)*EE_NUMBLOCKS;

	mov	DWORD PTR _recBlocks, eax
	add	eax, 786432				; 000c0000H

; 527  : 	recStack = (u8*)curpos;
; 528  : 
; 529  : 	if( s_pInstCache == NULL )

	cmp	DWORD PTR _s_pInstCache, 0
	mov	DWORD PTR _recStack, eax
	jne	SHORT $LN1@recAlloc

; 530  : 	{
; 531  : 		s_nInstCacheSize = 128;
; 532  : 		s_pInstCache = (EEINST*)malloc( sizeof(EEINST) * s_nInstCacheSize );

	push	14336					; 00003800H
	mov	DWORD PTR _s_nInstCacheSize, 128	; 00000080H
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	DWORD PTR _s_pInstCache, eax

; 533  : 	}
; 534  : 
; 535  : 	if( s_pInstCache == NULL )

	test	eax, eax
	jne	SHORT $LN1@recAlloc

; 536  : 		throw Exception::OutOfMemory( "R5900-32 Init > failed to allocate memory for pInstCache." );

	push	OFFSET ??_C@_0DK@KMFNGPCI@R5900?932?5Init?5?$DO?5failed?5to?5alloca@
	lea	ecx, DWORD PTR $T4[esp+340]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[esp+344], 8
	lea	eax, DWORD PTR $T4[esp+336]
	push	eax
	lea	ecx, DWORD PTR $T13[esp+340]
	call	??0OutOfMemory@Exception@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Exception::OutOfMemory::OutOfMemory
	push	OFFSET __TI3?AVOutOfMemory@Exception@@
	lea	eax, DWORD PTR $T13[esp+340]
	push	eax
	call	__CxxThrowException@8
$LN140@recAlloc:
$LN1@recAlloc:

; 537  : 
; 538  : 	// No errors.. Proceed with initialization:
; 539  : 
; 540  : 	ProfilerRegisterSource( "EERec", recMem, REC_CACHEMEM+0x1000 );

	push	16781312				; 01001000H
	mov	edx, esi
	mov	ecx, OFFSET ??_C@_05OAHDOEDM@EERec?$AA@
	call	?ProfilerRegisterSource@@YAXPBDPBXI@Z	; ProfilerRegisterSource

; 541  : 
; 542  : 	x86FpuState = FPU_STATE;
; 543  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+340]
	add	esp, 4
	xor	eax, eax
	mov	WORD PTR ?x86FpuState@@3GA, ax		; x86FpuState
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN134@recAlloc:
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?recAlloc@@YAXXZ$0:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?recAlloc@@YAXXZ$8:
	lea	ecx, DWORD PTR $T2[ebp+4]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?recAlloc@@YAXXZ$7:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1BaseException@Exception@@UAE@XZ	; Exception::BaseException::~BaseException
__unwindfunclet$?recAlloc@@YAXXZ$6:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1RuntimeError@Exception@@UAE@XZ	; Exception::RuntimeError::~RuntimeError
__unwindfunclet$?recAlloc@@YAXXZ$1:
	lea	ecx, DWORD PTR $T6[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?recAlloc@@YAXXZ$2:
	lea	ecx, DWORD PTR $T8[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?recAlloc@@YAXXZ$3:
	lea	ecx, DWORD PTR $T7[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?recAlloc@@YAXXZ$4:
	lea	ecx, DWORD PTR $T5[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?recAlloc@@YAXXZ$5:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?recAlloc@@YAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?recAlloc@@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?recAlloc@@YAXXZ ENDP					; recAlloc
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??0HardwareDeficiency@Exception@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0HardwareDeficiency@Exception@@QAE@ABV01@@Z PROC	; Exception::HardwareDeficiency::HardwareDeficiency, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0HardwareDeficiency@Exception@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	eax, DWORD PTR ___that$[esp+12]
	push	esi
	mov	esi, ecx
	add	eax, 4

; 726  : 		assign(_Right, 0, npos);

	push	-1
	lea	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR _this$[esp+24], esi
	push	0
	mov	DWORD PTR [esi], OFFSET ??_7BaseException@Exception@@6B@

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 727  : 		}
; 728  : 
; 729  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 730  : 		: _Mybase(_Al)
; 731  : 		{	// construct by copying with allocator
; 732  : 		_Tidy();
; 733  : 		assign(_Right, 0, npos);
; 734  : 		}
; 735  : 
; 736  : 	basic_string()
; 737  : 		: _Mybase()
; 738  : 		{	// construct empty string
; 739  : 		_Tidy();
; 740  : 		}
; 741  : 
; 742  : 	explicit basic_string(const _Alloc& _Al)
; 743  : 		: _Mybase(_Al)
; 744  : 		{	// construct empty string with allocator
; 745  : 		_Tidy();
; 746  : 		}
; 747  : 
; 748  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 749  : 		size_type _Count = npos)
; 750  : 		: _Mybase(_Right._Getal())
; 751  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 752  : 		_Tidy();
; 753  : 		assign(_Right, _Roff, _Count);
; 754  : 		}
; 755  : 
; 756  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 757  : 		const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 760  : 		_Tidy();
; 761  : 		assign(_Right, _Roff, _Count);
; 762  : 		}
; 763  : 
; 764  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 765  : 		: _Mybase()
; 766  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 767  : 		_Tidy();
; 768  : 		assign(_Ptr, _Count);
; 769  : 		}
; 770  : 
; 771  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 772  : 		: _Mybase(_Al)
; 773  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 774  : 		_Tidy();
; 775  : 		assign(_Ptr, _Count);
; 776  : 		}
; 777  : 
; 778  : 	basic_string(const _Elem *_Ptr)
; 779  : 		: _Mybase()
; 780  : 		{	// construct from [_Ptr, <null>)
; 781  : 		_Tidy();
; 782  : 		assign(_Ptr);
; 783  : 		}
; 784  : 
; 785  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 786  : 		: _Mybase(_Al)
; 787  : 		{	// construct from [_Ptr, <null>) with allocator
; 788  : 		_Tidy();
; 789  : 		assign(_Ptr);
; 790  : 		}
; 791  : 
; 792  : 	basic_string(size_type _Count, _Elem _Ch)
; 793  : 		: _Mybase()
; 794  : 		{	// construct from _Count * _Ch
; 795  : 		_Tidy();
; 796  : 		assign(_Count, _Ch);
; 797  : 		}
; 798  : 
; 799  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 800  : 		: _Mybase(_Al)
; 801  : 		{	// construct from _Count * _Ch with allocator
; 802  : 		_Tidy();
; 803  : 		assign(_Count, _Ch);
; 804  : 		}
; 805  : 
; 806  : 	template<class _Iter,
; 807  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 808  : 			void>::type>
; 809  : 		basic_string(_Iter _First, _Iter _Last)
; 810  : 		: _Mybase()
; 811  : 		{	// construct from [_First, _Last)
; 812  : 		_Tidy();
; 813  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 814  : 		}
; 815  : 
; 816  : 	template<class _Iter,
; 817  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 818  : 			void>::type>
; 819  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 820  : 		: _Mybase(_Al)
; 821  : 		{	// construct from [_First, _Last) with allocator
; 822  : 		_Tidy();
; 823  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 824  : 		}
; 825  : 
; 826  : 	template<class _Iter>
; 827  : 		void _Construct(_Iter _First,
; 828  : 			_Iter _Last, input_iterator_tag)
; 829  : 		{	// initialize from [_First, _Last), input iterators
; 830  : 		_TRY_BEGIN
; 831  : 		for (; _First != _Last; ++_First)
; 832  : 			append((size_type)1, (_Elem)*_First);
; 833  : 		_CATCH_ALL
; 834  : 		_Tidy(true);
; 835  : 		_RERAISE;
; 836  : 		_CATCH_END
; 837  : 		}
; 838  : 
; 839  : 	template<class _Iter>
; 840  : 		void _Construct(_Iter _First,
; 841  : 			_Iter _Last, forward_iterator_tag)
; 842  : 		{	// initialize from [_First, _Last), forward iterators
; 843  : 		_DEBUG_RANGE(_First, _Last);
; 844  : 		size_type _Count = 0;
; 845  : 		_Distance(_First, _Last, _Count);
; 846  : 		reserve(_Count);
; 847  : 
; 848  : 		_TRY_BEGIN
; 849  : 		for (; _First != _Last; ++_First)
; 850  : 			append((size_type)1, (_Elem)*_First);
; 851  : 		_CATCH_ALL
; 852  : 		_Tidy(true);
; 853  : 		_RERAISE;
; 854  : 		_CATCH_END
; 855  : 		}
; 856  : 
; 857  : 	basic_string(const_pointer _First, const_pointer _Last)
; 858  : 		: _Mybase()
; 859  : 		{	// construct from [_First, _Last), const pointers
; 860  : 		_DEBUG_RANGE(_First, _Last);
; 861  : 		_Tidy();
; 862  : 		if (_First != _Last)
; 863  : 			assign(&*_First, _Last - _First);
; 864  : 		}
; 865  : 
; 866  : 	basic_string(const_pointer _First, const_pointer _Last,
; 867  : 		const _Alloc& _Al)
; 868  : 		: _Mybase(_Al)
; 869  : 		{	// construct from [_First, _Last), const pointers
; 870  : 		_DEBUG_RANGE(_First, _Last);
; 871  : 		_Tidy();
; 872  : 		if (_First != _Last)
; 873  : 			assign(&*_First, _Last - _First);
; 874  : 		}
; 875  : 
; 876  : 	basic_string(const_iterator _First, const_iterator _Last)
; 877  : 		: _Mybase()
; 878  : 		{	// construct from [_First, _Last), const_iterators
; 879  : 		_DEBUG_RANGE(_First, _Last);
; 880  : 		_Tidy();
; 881  : 		if (_First != _Last)
; 882  : 			assign(&*_First, _Last - _First);
; 883  : 		}
; 884  : 
; 885  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 886  : 		: _Mybase(_Right._Getal())
; 887  : 		{	// construct by moving _Right
; 888  : 		_Tidy();
; 889  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 890  : 		}
; 891  : 
; 892  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 893  : 		: _Mybase(_Al)
; 894  : 		{	// construct by moving _Right, allocator
; 895  : 		if (this->_Getal() != _Right._Getal())
; 896  : 			assign(_Right.begin(), _Right.end());
; 897  : 		else
; 898  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 899  : 		}
; 900  : 
; 901  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 902  : 		{	// assign by moving _Right
; 903  : 		if (this != &_Right)
; 904  : 			{	// different, assign it
; 905  : 			_Tidy(true);
; 906  : 
; 907  : 			if (_Alty::propagate_on_container_move_assignment::value
; 908  : 				&& this->_Getal() != _Right._Getal())
; 909  : 				this->_Change_alloc(_Right._Getal());
; 910  : 
; 911  : 			if (this->_Getal() != _Right._Getal())
; 912  : 				assign(_Right.begin(), _Right.end());
; 913  : 			else
; 914  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 915  : 			}
; 916  : 		return (*this);
; 917  : 		}
; 918  : 
; 919  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 920  : 		{	// assign by moving _Right
; 921  : 		if (this == &_Right)
; 922  : 			;
; 923  : 		else if (get_allocator() != _Right.get_allocator()
; 924  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 925  : 			*this = _Right;
; 926  : 		else
; 927  : 			{	// not same, clear this and steal from _Right
; 928  : 			_Tidy(true);
; 929  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 930  : 			}
; 931  : 		return (*this);
; 932  : 		}
; 933  : 
; 934  : 	void _Assign_rv(_Myt&& _Right)
; 935  : 		{	// assign by moving _Right
; 936  : 		if (_Right._Myres < this->_BUF_SIZE)
; 937  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 938  : 				_Right._Mysize + 1);
; 939  : 		else
; 940  : 			{	// copy pointer
; 941  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 942  : 			_Right._Bx._Ptr = pointer();
; 943  : 			}
; 944  : 		this->_Mysize = _Right._Mysize;
; 945  : 		this->_Myres = _Right._Myres;
; 946  : 		_Right._Tidy();
; 947  : 		}
; 948  : 
; 949  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 950  : 		const _Alloc& _Al = allocator_type())
; 951  : 		: _Mybase(_Al)
; 952  : 		{	// construct from initializer_list
; 953  : 		_Tidy();
; 954  : 		assign(_Ilist.begin(), _Ilist.end());
; 955  : 		}
; 956  : 
; 957  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 958  : 		{	// assign initializer_list
; 959  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 960  : 		}
; 961  : 
; 962  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 963  : 		{	// append initializer_list
; 964  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 965  : 		}
; 966  : 
; 967  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 968  : 		{	// assign initializer_list
; 969  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 970  : 		}
; 971  : 
; 972  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 973  : 		{	// append initializer_list
; 974  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 975  : 		}
; 976  : 
; 977  : 	iterator insert(const_iterator _Where,
; 978  : 		_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// insert initializer_list
; 980  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 984  : 		_XSTD initializer_list<_Elem> _Ilist)
; 985  : 		{	// replace with initializer_list
; 986  : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 987  : 		}
; 988  : 
; 989  : 	~basic_string() _NOEXCEPT
; 990  : 		{	// destroy the string
; 991  : 		_Tidy(true);
; 992  : 		}
; 993  : 
; 994  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 995  : 
; 996  : 	_Myt& operator=(const _Myt& _Right)
; 997  : 		{	// assign _Right
; 998  : 		if (this != &_Right)
; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& assign(const _Myt& _Right,
; 1128 : 		size_type _Roff, size_type _Count)
; 1129 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1130 : 		if (_Right.size() < _Roff)
; 1131 : 			_Xran();	// _Roff off end
; 1132 : 		size_type _Num = _Right.size() - _Roff;
; 1133 : 		if (_Count < _Num)
; 1134 : 			_Num = _Count;	// trim _Num to size
; 1135 : 
; 1136 : 		if (this == &_Right)
; 1137 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1138 : 		else if (_Grow(_Num))
; 1139 : 			{	// make room and assign new stuff
; 1140 : 			_Traits::copy(this->_Myptr(),
; 1141 : 				_Right._Myptr() + _Roff, _Num);
; 1142 : 			_Eos(_Num);
; 1143 : 			}
; 1144 : 		return (*this);
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1148 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1149 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1150 : 		if (_Count != 0)
; 1151 : 			_DEBUG_POINTER(_Ptr);
; 1152 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1153 : 
; 1154 : 		if (_Inside(_Ptr))
; 1155 : 			return (assign(*this,
; 1156 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1157 : 
; 1158 : 		if (_Grow(_Count))
; 1159 : 			{	// make room and assign new stuff
; 1160 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1161 : 			_Eos(_Count);
; 1162 : 			}
; 1163 : 		return (*this);
; 1164 : 		}
; 1165 : 
; 1166 : 	_Myt& assign(const _Elem *_Ptr)
; 1167 : 		{	// assign [_Ptr, <null>)
; 1168 : 		_DEBUG_POINTER(_Ptr);
; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], 0

; 726  : 		assign(_Right, 0, npos);

	push	eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 726  : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	DWORD PTR __$EHRec$[esp+28], 1
	mov	DWORD PTR [esi], OFFSET ??_7RuntimeError@Exception@@6B@
	mov	DWORD PTR __$EHRec$[esp+28], 2
	mov	DWORD PTR [esi], OFFSET ??_7HardwareDeficiency@Exception@@6B@
	mov	DWORD PTR __$EHRec$[esp+28], -1
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0HardwareDeficiency@Exception@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0HardwareDeficiency@Exception@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1BaseException@Exception@@UAE@XZ	; Exception::BaseException::~BaseException
__unwindfunclet$??0HardwareDeficiency@Exception@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1RuntimeError@Exception@@UAE@XZ	; Exception::RuntimeError::~RuntimeError
__ehhandler$??0HardwareDeficiency@Exception@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0HardwareDeficiency@Exception@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0HardwareDeficiency@Exception@@QAE@ABV01@@Z ENDP	; Exception::HardwareDeficiency::HardwareDeficiency
; Function compile flags: /Ogtpy
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\windows\memzero.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\windows\memzero.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\baseblockex.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\windows\memzero.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86_tools.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86_tools.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86_tools.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
_TEXT	SEGMENT
__xmm_backup$1 = -20					; size = 16
__xmm_backup$2 = -20					; size = 16
_dest$ = -4						; size = 4
_dest$ = -4						; size = 4
_dest$ = -4						; size = 4
?recResetEE@@YAXXZ PROC					; recResetEE

; 547  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 548  : 	DbgCon::Status( "iR5900-32 > Resetting recompiler memory and structures." );
; 549  : 
; 550  : 	s_nNextBlock = 0;
; 551  : 	maxrecmem = 0;
; 552  : 
; 553  : 	memset_8<0xcd, REC_CACHEMEM>(recMem);

	mov	eax, DWORD PTR _recMem
	push	edi
	mov	DWORD PTR _s_nNextBlock, 0
	mov	DWORD PTR ?maxrecmem@@3IA, 0		; maxrecmem
	mov	DWORD PTR _dest$[ebp], eax
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\windows\memzero.h

; 378  : 				cld;

	cld

; 379  : 				mov ecx, remdat;

	mov	ecx, 4194304				; 00400000H

; 380  : 				mov edi, dest;

	mov	edi, DWORD PTR _dest$[ebp]

; 381  : 				mov eax, data32;

	mov	eax, -842150451				; cdcdcdcdH

; 382  : 				rep stosd;

	rep	 stosd
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 554  : 	memzero_ptr<m_recBlockAllocSize>( m_recBlockAlloc );

	mov	eax, DWORD PTR _m_recBlockAlloc
	mov	DWORD PTR _dest$[ebp], eax
	pop	edi
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\windows\memzero.h

; 77   : 		if( ((uptr)dest & 0xf) != 0 )

	test	al, 15					; 0000000fH
	je	SHORT $LN38@recResetEE

; 78   : 		{
; 79   : 			// UNALIGNED COPY MODE.
; 80   : 			// For unaligned copies we have a threshold of at least 128 vectors.  Anything
; 81   : 			// less and it's probably better off just falling back on the rep movsd.
; 82   : 			if( bytes128 > 128 )
; 83   : 			{
; 84   : 				__asm
; 85   : 				{
; 86   : 					movups _xmm_backup,xmm0;

	movups	XMMWORD PTR __xmm_backup$2[ebp], xmm0

; 87   : 					mov ecx,dest

	mov	ecx, DWORD PTR _dest$[ebp]

; 88   : 					pxor xmm0,xmm0

	pxor	xmm0, xmm0

; 89   : 					mov eax,bytes128

	mov	eax, 600576				; 00092a00H
$_loop_6$117:

; 90   : 
; 91   : 					align 16
; 92   : 
; 93   : 				_loop_6:
; 94   : 					movups [ecx],xmm0;

	movups	XMMWORD PTR [ecx], xmm0

; 95   : 					movups [ecx+0x10],xmm0;

	movups	XMMWORD PTR [ecx+16], xmm0

; 96   : 					movups [ecx+0x20],xmm0;

	movups	XMMWORD PTR [ecx+32], xmm0

; 97   : 					movups [ecx+0x30],xmm0;

	movups	XMMWORD PTR [ecx+48], xmm0

; 98   : 					movups [ecx+0x40],xmm0;

	movups	XMMWORD PTR [ecx+64], xmm0

; 99   : 					movups [ecx+0x50],xmm0;

	movups	XMMWORD PTR [ecx+80], xmm0

; 100  : 					movups [ecx+0x60],xmm0;

	movups	XMMWORD PTR [ecx+96], xmm0

; 101  : 					movups [ecx+0x70],xmm0;

	movups	XMMWORD PTR [ecx+112], xmm0

; 102  : 					sub ecx,-128

	sub	ecx, -128				; ffffff80H

; 103  : 					dec eax;

	dec	eax

; 104  : 					jnz _loop_6;

	jne	SHORT $_loop_6$117

; 105  : 				}
; 106  : 				if( remainder != 0 )
; 107  : 				{
; 108  : 					// Copy the remainder in reverse (using the decrementing eax as our indexer)
; 109  : 					__asm
; 110  : 					{
; 111  : 						mov eax, remainder
; 112  : 
; 113  : 					_loop_5:
; 114  : 						movups [ecx+eax],xmm0;
; 115  : 						sub eax,16;
; 116  : 						jnz _loop_5;
; 117  : 					}
; 118  : 				}
; 119  : 				__asm
; 120  : 				{
; 121  : 					movups xmm0,[_xmm_backup];

	movups	xmm0, XMMWORD PTR __xmm_backup$2[ebp]

; 122  : 				}
; 123  : 				return;

	jmp	SHORT $LN31@recResetEE
$LN38@recResetEE:

; 124  : 			}
; 125  : 		}
; 126  : 		else if( bytes128 > 48 )
; 127  : 		{
; 128  : 			// ALIGNED COPY MODE
; 129  : 			// Data is aligned and the size of data is large enough to merit a nice
; 130  : 			// fancy chunk of unrolled goodness:
; 131  : 
; 132  : 			__asm
; 133  : 			{
; 134  : 				movups _xmm_backup,xmm0;

	movups	XMMWORD PTR __xmm_backup$2[ebp], xmm0

; 135  : 				mov ecx,dest

	mov	ecx, DWORD PTR _dest$[ebp]

; 136  : 				pxor xmm0,xmm0

	pxor	xmm0, xmm0

; 137  : 				mov eax,bytes128

	mov	eax, 600576				; 00092a00H
	npad	5
$_loop_8$118:

; 138  : 
; 139  : 				align 16
; 140  : 
; 141  : 			_loop_8:
; 142  : 				movaps [ecx],xmm0;

	movaps	XMMWORD PTR [ecx], xmm0

; 143  : 				movaps [ecx+0x10],xmm0;

	movaps	XMMWORD PTR [ecx+16], xmm0

; 144  : 				movaps [ecx+0x20],xmm0;

	movaps	XMMWORD PTR [ecx+32], xmm0

; 145  : 				movaps [ecx+0x30],xmm0;

	movaps	XMMWORD PTR [ecx+48], xmm0

; 146  : 				movaps [ecx+0x40],xmm0;

	movaps	XMMWORD PTR [ecx+64], xmm0

; 147  : 				movaps [ecx+0x50],xmm0;

	movaps	XMMWORD PTR [ecx+80], xmm0

; 148  : 				movaps [ecx+0x60],xmm0;

	movaps	XMMWORD PTR [ecx+96], xmm0

; 149  : 				movaps [ecx+0x70],xmm0;

	movaps	XMMWORD PTR [ecx+112], xmm0

; 150  : 				sub ecx,-128

	sub	ecx, -128				; ffffff80H

; 151  : 				dec eax;

	dec	eax

; 152  : 				jnz _loop_8;

	jne	SHORT $_loop_8$118

; 153  : 			}
; 154  : 			if( remainder != 0 )
; 155  : 			{
; 156  : 				// Copy the remainder in reverse (using the decrementing eax as our indexer)
; 157  : 				__asm
; 158  : 				{
; 159  : 					mov eax, remainder
; 160  : 
; 161  : 				_loop_10:
; 162  : 					movaps [ecx+eax],xmm0;
; 163  : 					sub eax,16;
; 164  : 					jnz _loop_10;
; 165  : 				}
; 166  : 			}
; 167  : 			__asm
; 168  : 			{
; 169  : 				movups xmm0,[_xmm_backup];

	movups	xmm0, XMMWORD PTR __xmm_backup$2[ebp]
$LN31@recResetEE:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 556  : 	if( s_pInstCache )

	mov	ecx, DWORD PTR _s_pInstCache
	test	ecx, ecx
	je	SHORT $LN10@recResetEE

; 557  : 		memset( s_pInstCache, 0, sizeof(EEINST)*s_nInstCacheSize );

	imul	eax, DWORD PTR _s_nInstCacheSize, 112
	push	eax
	push	0
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
$LN10@recResetEE:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\baseblockex.cpp

; 113  : 	blocks.resize(0);

	push	ecx
	mov	ecx, OFFSET _s_vecBaseBlocksEx
	call	?resize@?$vector@PAUBASEBLOCKEX@@V?$allocator@PAUBASEBLOCKEX@@@std@@@std@@QAEXI@Z ; std::vector<BASEBLOCKEX *,std::allocator<BASEBLOCKEX *> >::resize
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1010 : 		return (this->_Myend - this->_Myfirst);

	mov	eax, DWORD PTR _s_vecBaseBlocksEx+8
	sub	eax, DWORD PTR _s_vecBaseBlocksEx
	sar	eax, 2

; 1000 : 		if (capacity() < _Count)

	cmp	eax, 512				; 00000200H
	jae	SHORT $LN49@recResetEE

; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);

	push	512					; 00000200H
	mov	ecx, OFFSET _s_vecBaseBlocksEx
	call	?_Reallocate@?$vector@PAUBASEBLOCKEX@@V?$allocator@PAUBASEBLOCKEX@@@std@@@std@@IAEXI@Z ; std::vector<BASEBLOCKEX *,std::allocator<BASEBLOCKEX *> >::_Reallocate
$LN49@recResetEE:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 560  : 	mmap_ResetBlockTracking();

	call	?mmap_ResetBlockTracking@@YAXXZ		; mmap_ResetBlockTracking

; 561  : 
; 562  : #ifdef _MSC_VER
; 563  : 	__asm emms;

	emms

; 564  : #else
; 565  :     __asm__("emms");
; 566  : #endif
; 567  : 
; 568  : 	memzero_ptr<0x010000 * sizeof(uptr)>( recLUT );

	mov	eax, DWORD PTR ?recLUT@@3PAIA		; recLUT
	mov	DWORD PTR _dest$[ebp], eax
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\windows\memzero.h

; 77   : 		if( ((uptr)dest & 0xf) != 0 )

	test	al, 15					; 0000000fH
	je	SHORT $LN83@recResetEE

; 78   : 		{
; 79   : 			// UNALIGNED COPY MODE.
; 80   : 			// For unaligned copies we have a threshold of at least 128 vectors.  Anything
; 81   : 			// less and it's probably better off just falling back on the rep movsd.
; 82   : 			if( bytes128 > 128 )
; 83   : 			{
; 84   : 				__asm
; 85   : 				{
; 86   : 					movups _xmm_backup,xmm0;

	movups	XMMWORD PTR __xmm_backup$1[ebp], xmm0

; 87   : 					mov ecx,dest

	mov	ecx, DWORD PTR _dest$[ebp]

; 88   : 					pxor xmm0,xmm0

	pxor	xmm0, xmm0

; 89   : 					mov eax,bytes128

	mov	eax, 2048				; 00000800H
	npad	8
$_loop_6$119:

; 90   : 
; 91   : 					align 16
; 92   : 
; 93   : 				_loop_6:
; 94   : 					movups [ecx],xmm0;

	movups	XMMWORD PTR [ecx], xmm0

; 95   : 					movups [ecx+0x10],xmm0;

	movups	XMMWORD PTR [ecx+16], xmm0

; 96   : 					movups [ecx+0x20],xmm0;

	movups	XMMWORD PTR [ecx+32], xmm0

; 97   : 					movups [ecx+0x30],xmm0;

	movups	XMMWORD PTR [ecx+48], xmm0

; 98   : 					movups [ecx+0x40],xmm0;

	movups	XMMWORD PTR [ecx+64], xmm0

; 99   : 					movups [ecx+0x50],xmm0;

	movups	XMMWORD PTR [ecx+80], xmm0

; 100  : 					movups [ecx+0x60],xmm0;

	movups	XMMWORD PTR [ecx+96], xmm0

; 101  : 					movups [ecx+0x70],xmm0;

	movups	XMMWORD PTR [ecx+112], xmm0

; 102  : 					sub ecx,-128

	sub	ecx, -128				; ffffff80H

; 103  : 					dec eax;

	dec	eax

; 104  : 					jnz _loop_6;

	jne	SHORT $_loop_6$119

; 105  : 				}
; 106  : 				if( remainder != 0 )
; 107  : 				{
; 108  : 					// Copy the remainder in reverse (using the decrementing eax as our indexer)
; 109  : 					__asm
; 110  : 					{
; 111  : 						mov eax, remainder
; 112  : 
; 113  : 					_loop_5:
; 114  : 						movups [ecx+eax],xmm0;
; 115  : 						sub eax,16;
; 116  : 						jnz _loop_5;
; 117  : 					}
; 118  : 				}
; 119  : 				__asm
; 120  : 				{
; 121  : 					movups xmm0,[_xmm_backup];

	movups	xmm0, XMMWORD PTR __xmm_backup$1[ebp]

; 122  : 				}
; 123  : 				return;

	jmp	SHORT $LN76@recResetEE
$LN83@recResetEE:

; 124  : 			}
; 125  : 		}
; 126  : 		else if( bytes128 > 48 )
; 127  : 		{
; 128  : 			// ALIGNED COPY MODE
; 129  : 			// Data is aligned and the size of data is large enough to merit a nice
; 130  : 			// fancy chunk of unrolled goodness:
; 131  : 
; 132  : 			__asm
; 133  : 			{
; 134  : 				movups _xmm_backup,xmm0;

	movups	XMMWORD PTR __xmm_backup$1[ebp], xmm0

; 135  : 				mov ecx,dest

	mov	ecx, DWORD PTR _dest$[ebp]

; 136  : 				pxor xmm0,xmm0

	pxor	xmm0, xmm0

; 137  : 				mov eax,bytes128

	mov	eax, 2048				; 00000800H
	npad	5
$_loop_8$120:

; 138  : 
; 139  : 				align 16
; 140  : 
; 141  : 			_loop_8:
; 142  : 				movaps [ecx],xmm0;

	movaps	XMMWORD PTR [ecx], xmm0

; 143  : 				movaps [ecx+0x10],xmm0;

	movaps	XMMWORD PTR [ecx+16], xmm0

; 144  : 				movaps [ecx+0x20],xmm0;

	movaps	XMMWORD PTR [ecx+32], xmm0

; 145  : 				movaps [ecx+0x30],xmm0;

	movaps	XMMWORD PTR [ecx+48], xmm0

; 146  : 				movaps [ecx+0x40],xmm0;

	movaps	XMMWORD PTR [ecx+64], xmm0

; 147  : 				movaps [ecx+0x50],xmm0;

	movaps	XMMWORD PTR [ecx+80], xmm0

; 148  : 				movaps [ecx+0x60],xmm0;

	movaps	XMMWORD PTR [ecx+96], xmm0

; 149  : 				movaps [ecx+0x70],xmm0;

	movaps	XMMWORD PTR [ecx+112], xmm0

; 150  : 				sub ecx,-128

	sub	ecx, -128				; ffffff80H

; 151  : 				dec eax;

	dec	eax

; 152  : 				jnz _loop_8;

	jne	SHORT $_loop_8$120

; 153  : 			}
; 154  : 			if( remainder != 0 )
; 155  : 			{
; 156  : 				// Copy the remainder in reverse (using the decrementing eax as our indexer)
; 157  : 				__asm
; 158  : 				{
; 159  : 					mov eax, remainder
; 160  : 
; 161  : 				_loop_10:
; 162  : 					movaps [ecx+eax],xmm0;
; 163  : 					sub eax,16;
; 164  : 					jnz _loop_10;
; 165  : 				}
; 166  : 			}
; 167  : 			__asm
; 168  : 			{
; 169  : 				movups xmm0,[_xmm_backup];

	movups	xmm0, XMMWORD PTR __xmm_backup$1[ebp]
$LN76@recResetEE:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 570  : 	for ( int i = 0x0000; i < 0x0200; i++ )

	mov	eax, DWORD PTR _recRAM
	mov	edx, 512				; 00000200H
	push	esi
	mov	esi, DWORD PTR ?recLUT@@3PAIA		; recLUT
	lea	ecx, DWORD PTR [esi+49152]
$LL100@recResetEE:

; 571  : 	{
; 572  : 		recLUT[ i + 0x0000 ] = (uptr)&recRAM[ i << 14 ];

	mov	DWORD PTR [ecx-49152], eax
	lea	ecx, DWORD PTR [ecx+4]

; 573  : 		recLUT[ i + 0x2000 ] = (uptr)&recRAM[ i << 14 ];

	mov	DWORD PTR [ecx-16388], eax

; 574  : 		recLUT[ i + 0x3000 ] = (uptr)&recRAM[ i << 14 ];

	mov	DWORD PTR [ecx-4], eax
	add	eax, 131072				; 00020000H
	dec	edx
	jne	SHORT $LL100@recResetEE

; 575  : 	}
; 576  : 
; 577  : 	for ( int i = 0x0000; i < 0x0040; i++ )

	mov	ecx, DWORD PTR _recROM
	lea	eax, DWORD PTR [esi+163584]
	mov	edx, 64					; 00000040H
	npad	5
$LL102@recResetEE:

; 578  : 	{
; 579  : 		recLUT[ i + 0x1fc0 ] = (uptr)&recROM[ i << 14 ];

	mov	DWORD PTR [eax-131072], ecx
	lea	eax, DWORD PTR [eax+4]

; 580  : 		recLUT[ i + 0x9fc0 ] = (uptr)&recROM[ i << 14 ];

	mov	DWORD PTR [eax-4], ecx

; 581  : 		recLUT[ i + 0xbfc0 ] = (uptr)&recROM[ i << 14 ];

	mov	DWORD PTR [eax+32764], ecx
	add	ecx, 131072				; 00020000H
	dec	edx
	jne	SHORT $LL102@recResetEE

; 582  : 	}
; 583  : 
; 584  : 	for ( int i = 0x0000; i < 0x0004; i++ )
; 585  : 	{
; 586  : 		recLUT[ i + 0x1e00 ] = (uptr)&recROM1[ i << 14 ];

	mov	ecx, DWORD PTR _recROM1

; 587  : 		recLUT[ i + 0x9e00 ] = (uptr)&recROM1[ i << 14 ];
; 588  : 		recLUT[ i + 0xbe00 ] = (uptr)&recROM1[ i << 14 ];
; 589  : 	}
; 590  : 
; 591  : 	memcpy_fast( recLUT + 0x8000, recLUT, 0x2000 * sizeof(uptr) );

	mov	edx, esi
	mov	DWORD PTR [esi+30720], ecx
	mov	DWORD PTR [esi+161792], ecx
	mov	DWORD PTR [esi+194560], ecx
	lea	eax, DWORD PTR [ecx+131072]
	mov	DWORD PTR [esi+30724], eax
	mov	DWORD PTR [esi+161796], eax
	mov	DWORD PTR [esi+194564], eax
	lea	eax, DWORD PTR [ecx+262144]
	mov	DWORD PTR [esi+30728], eax
	mov	DWORD PTR [esi+161800], eax
	mov	DWORD PTR [esi+194568], eax
	lea	eax, DWORD PTR [ecx+393216]
	push	32768					; 00008000H
	lea	ecx, DWORD PTR [esi+131072]
	mov	DWORD PTR [esi+30732], eax
	mov	DWORD PTR [esi+161804], eax
	mov	DWORD PTR [esi+194572], eax
	call	?memcpy_amd_@@YIXPAXPBXI@Z		; memcpy_amd_

; 592  : 	memcpy_fast( recLUT + 0xa000, recLUT, 0x2000 * sizeof(uptr) );

	mov	edx, DWORD PTR ?recLUT@@3PAIA		; recLUT
	push	32768					; 00008000H
	lea	ecx, DWORD PTR [edx+163840]
	call	?memcpy_amd_@@YIXPAXPBXI@Z		; memcpy_amd_
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp

; 181  : 	x86Ptr = ptr;

	mov	eax, DWORD PTR _recMem
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86_tools.cpp

; 51   : 	sseVUMXCSR &= 0xffff;

	movzx	ecx, WORD PTR ?Config@@3UPcsxConfig@@A+3632
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp

; 181  : 	x86Ptr = ptr;

	mov	DWORD PTR ?x86Ptr@@3PAEA, eax		; x86Ptr
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 605  : 	recPtr = recMem;

	mov	DWORD PTR _recPtr, eax

; 606  : 	recStackPtr = recStack;

	mov	eax, DWORD PTR _recStack
	mov	DWORD PTR _recStackPtr, eax

; 607  : 	x86FpuState = FPU_STATE;

	xor	eax, eax
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86_tools.cpp

; 53   : 	if( !cpucaps.hasStreamingSIMD2Extensions )

	cmp	DWORD PTR ?cpucaps@@3UCAPABILITIES@@A+92, 0
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 607  : 	x86FpuState = FPU_STATE;

	mov	WORD PTR ?x86FpuState@@3GA, ax		; x86FpuState

; 608  : 	iCWstate = 0;

	mov	WORD PTR ?iCWstate@@3GA, ax		; iCWstate

; 609  : 
; 610  : 	branch = 0;

	mov	DWORD PTR ?branch@@3HA, eax		; branch
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86_tools.cpp

; 50   : 	sseMXCSR &= 0xffff; // clear the upper 16 bits since they shouldn't be set

	movzx	eax, WORD PTR ?Config@@3UPcsxConfig@@A+3628
	pop	esi

; 53   : 	if( !cpucaps.hasStreamingSIMD2Extensions )

	jne	SHORT $LN91@recResetEE

; 54   : 	{
; 55   : 		// SSE1 cpus do not support Denormals Are Zero flag (throws an exception
; 56   : 		// if we don't mask them off)
; 57   : 
; 58   : 		sseMXCSR &= ~0x0040;

	and	eax, -65				; ffffffbfH

; 59   : 		sseVUMXCSR &= ~0x0040;

	and	ecx, -65				; ffffffbfH
$LN91@recResetEE:

; 60   : 	}
; 61   : 
; 62   : 	g_sseMXCSR = sseMXCSR;

	mov	DWORD PTR ?g_sseMXCSR@@3IA, eax		; g_sseMXCSR

; 63   : 	g_sseVUMXCSR = sseVUMXCSR;

	mov	DWORD PTR ?g_sseVUMXCSR@@3IA, ecx	; g_sseVUMXCSR

; 64   : 
; 65   : #ifdef _MSC_VER
; 66   : 	__asm ldmxcsr g_sseMXCSR; // set the new sse control

	ldmxcsr	DWORD PTR ?g_sseMXCSR@@3IA		; g_sseMXCSR
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 612  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?recResetEE@@YAXXZ ENDP					; recResetEE
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\baseblockex.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\windows\winsysexec.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
_TEXT	SEGMENT
?recShutdown@@YAXXZ PROC				; recShutdown

; 616  : 	ProfilerTerminateSource( "EERec" );

	mov	ecx, OFFSET ??_C@_05OAHDOEDM@EERec?$AA@
	call	?ProfilerTerminateSource@@YAXPBD@Z	; ProfilerTerminateSource
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\baseblockex.cpp

; 113  : 	blocks.resize(0);

	push	ecx
	mov	ecx, OFFSET _s_vecBaseBlocksEx
	call	?resize@?$vector@PAUBASEBLOCKEX@@V?$allocator@PAUBASEBLOCKEX@@@std@@@std@@QAEXI@Z ; std::vector<BASEBLOCKEX *,std::allocator<BASEBLOCKEX *> >::resize
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1010 : 		return (this->_Myend - this->_Myfirst);

	mov	eax, DWORD PTR _s_vecBaseBlocksEx+8
	sub	eax, DWORD PTR _s_vecBaseBlocksEx
	sar	eax, 2

; 1000 : 		if (capacity() < _Count)

	cmp	eax, 512				; 00000200H
	jae	SHORT $LN12@recShutdow

; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);

	push	512					; 00000200H
	mov	ecx, OFFSET _s_vecBaseBlocksEx
	call	?_Reallocate@?$vector@PAUBASEBLOCKEX@@V?$allocator@PAUBASEBLOCKEX@@@std@@@std@@IAEXI@Z ; std::vector<BASEBLOCKEX *,std::allocator<BASEBLOCKEX *> >::_Reallocate
$LN12@recShutdow:
	push	esi
	push	edi
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 619  : 	SafeSysMunmap( recMem, REC_CACHEMEM );

	mov	edi, DWORD PTR _recMem
	test	edi, edi
	je	SHORT $LN4@recShutdow
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\windows\winsysexec.cpp

; 910  : 	VirtualFree((void*)base, size, MEM_DECOMMIT);

	mov	esi, DWORD PTR __imp__VirtualFree@12
	push	16384					; 00004000H
	push	16777216				; 01000000H
	push	edi
	call	esi

; 911  : 	VirtualFree((void*)base, 0, MEM_RELEASE);

	push	32768					; 00008000H
	push	0
	push	edi
	call	esi
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 619  : 	SafeSysMunmap( recMem, REC_CACHEMEM );

	mov	DWORD PTR _recMem, 0
$LN4@recShutdow:

; 620  : 	safe_aligned_free( recLUT );

	mov	eax, DWORD PTR ?recLUT@@3PAIA		; recLUT
	mov	esi, DWORD PTR __imp___aligned_free
	test	eax, eax
	je	SHORT $LN3@recShutdow
	push	eax
	call	esi
	add	esp, 4
	mov	DWORD PTR ?recLUT@@3PAIA, 0		; recLUT
$LN3@recShutdow:

; 621  : 	safe_aligned_free( m_recBlockAlloc );

	mov	eax, DWORD PTR _m_recBlockAlloc
	test	eax, eax
	je	SHORT $LN2@recShutdow
	push	eax
	call	esi
	add	esp, 4
	mov	DWORD PTR _m_recBlockAlloc, 0
$LN2@recShutdow:

; 622  : 	recRAM = recROM = recROM1 = NULL;
; 623  : 	recBlocks = NULL;
; 624  : 	recStack = NULL;
; 625  : 
; 626  : 	safe_free( s_pInstCache );

	mov	eax, DWORD PTR _s_pInstCache
	mov	DWORD PTR _recROM1, 0
	mov	DWORD PTR _recROM, 0
	mov	DWORD PTR _recRAM, 0
	mov	DWORD PTR _recBlocks, 0
	mov	DWORD PTR _recStack, 0
	pop	edi
	pop	esi
	test	eax, eax
	je	SHORT $LN38@recShutdow
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	mov	DWORD PTR _s_pInstCache, 0
$LN38@recShutdow:

; 627  : 	s_nInstCacheSize = 0;

	mov	DWORD PTR _s_nInstCacheSize, 0

; 628  : 
; 629  : 	x86Shutdown();
; 630  : }

	ret	0
?recShutdown@@YAXXZ ENDP				; recShutdown
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
_TEXT	SEGMENT
?recStep@@YAXXZ PROC					; recStep

; 636  : }

	ret	0
?recStep@@YAXXZ ENDP					; recStep
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\console.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\windows\winconsole.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\iopcounters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\windows\winthreads.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vumicromem.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vumicromem.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\iopcounters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\misc.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\misc.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\misc.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\windows\winthreads.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\misc.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\iopcounters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vifdma.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vifdma.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vifdma.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vifdma.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vifdma.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vifdma.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\gif.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\gif.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\gif.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\sif.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\sif.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\sif.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\ipu\ipu.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\ipu\ipu.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\ipu\ipu.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\spr.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
_TEXT	SEGMENT
_vsyncEvent$1$ = -41					; size = 1
tv3158 = -40						; size = 4
_i$1$ = -40						; size = 4
_sDeltaTime$1$ = -36					; size = 4
_sDeltaTime$1 = -36					; size = 8
_uExpectedEnd$1$ = -28					; size = 4
_count$2 = -28						; size = 8
_result$3 = -28						; size = 4
_tmp$4 = -16						; size = 4
_count$5 = -12						; size = 8
?recEventTest@@YA_NXZ PROC				; recEventTest

; 639  : {

	sub	esp, 48					; 00000030H

; 640  : #ifdef PCSX2_DEVBUILD
; 641  :     // dont' remove this check unless doing an official release
; 642  :     if( g_globalXMMSaved || g_globalMMXSaved)

	cmp	BYTE PTR ?g_globalXMMSaved@@3EA, 0	; g_globalXMMSaved
	push	ebx
	push	esi
	push	edi
	mov	edi, 1
	jne	SHORT $LN1@recEventTe
	cmp	BYTE PTR ?g_globalMMXSaved@@3EA, 0	; g_globalMMXSaved
	je	SHORT $LN9@recEventTe
$LN1@recEventTe:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\console.cpp

; 97   : 		Write( color, fmt );

	mov	edx, OFFSET ??_C@_0DF@HHKJLMIF@Pcsx2?5Foopah?$CB?5?5Frozen?5regs?5have?5@
	mov	ecx, edi
	call	?Write@Console@@YA_NW4Colors@1@PBD@Z	; Console::Write
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\windows\winconsole.cpp

; 90   : 		if (hConsole != NULL)

	mov	eax, DWORD PTR _hConsole
	test	eax, eax
	je	SHORT $LN10@recEventTe

; 91   : 		{
; 92   : 			DWORD tmp;
; 93   : 			WriteConsole(hConsole, "\r\n", 2, &tmp, 0);

	push	0
	lea	ecx, DWORD PTR _tmp$4[esp+64]
	push	ecx
	push	2
	push	OFFSET ??_C@_02PCIJFNDE@?$AN?6?$AA@
	push	eax
	call	DWORD PTR __imp__WriteConsoleA@20
$LN10@recEventTe:

; 94   : 		}
; 95   : 
; 96   : 		if (emuLog != NULL)

	mov	eax, DWORD PTR ?emuLog@@3PAU_iobuf@@A	; emuLog
	test	eax, eax
	je	SHORT $LN9@recEventTe

; 97   : 		{
; 98   : 			fputs("\n", emuLog);

	push	eax
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	DWORD PTR __imp__fputs

; 99   : 			fflush( emuLog );

	push	DWORD PTR ?emuLog@@3PAU_iobuf@@A	; emuLog
	call	DWORD PTR __imp__fflush
	add	esp, 12					; 0000000cH
$LN9@recEventTe:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 443  : 	g_nextBranchCycle = cpuRegs.cycle + eeWaitCycles;

	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	eax, DWORD PTR _eeWaitCycles

; 444  : 
; 445  : 	EEsCycle += cpuRegs.cycle - EEoCycle;

	mov	ecx, DWORD PTR ?EEsCycle@@3HA		; EEsCycle
	add	eax, ebx
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
	mov	eax, ebx
	sub	eax, DWORD PTR ?EEoCycle@@3IA		; EEoCycle
	add	ecx, eax
	mov	BYTE PTR ?eeEventTestIsActive@@3_NA, 1	; eeEventTestIsActive

; 447  : 
; 448  : 	if( EEsCycle > 0 )

	movzx	eax, BYTE PTR ?iopBranchAction@@3_NA	; iopBranchAction
	test	ecx, ecx
	mov	DWORD PTR ?EEsCycle@@3HA, ecx		; EEsCycle

; 332  : 	return (int)(cpuRegs.cycle - startCycle) >= delta;

	mov	ecx, DWORD PTR ?counters@@3PAUCounter@@A+188

; 447  : 
; 448  : 	if( EEsCycle > 0 )

	cmovg	eax, edi
	mov	BYTE PTR ?iopBranchAction@@3_NA, al	; iopBranchAction

; 332  : 	return (int)(cpuRegs.cycle - startCycle) >= delta;

	mov	eax, ebx
	sub	eax, ecx

; 446  : 	EEoCycle = cpuRegs.cycle;

	mov	DWORD PTR ?EEoCycle@@3IA, ebx		; EEoCycle

; 449  : 		iopBranchAction = true;
; 450  : 
; 451  : 	// ---- Counters -------------
; 452  : 	bool vsyncEvent = false;

	mov	BYTE PTR _vsyncEvent$1$[esp+60], 0

; 332  : 	return (int)(cpuRegs.cycle - startCycle) >= delta;

	cmp	eax, DWORD PTR ?counters@@3PAUCounter@@A+192
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp

; 471  : 	if( !cpuTestCycle( counters[4].sCycle, counters[4].CycleT ) ) return;

	jl	$LN457@recEventTe

; 472  : 
; 473  : 	//iopBranchAction = 1;
; 474  : 	if (counters[4].modeval & MODE_HBLANK) { //HBLANK Start

	test	BYTE PTR ?counters@@3PAUCounter@@A+164, 1
	je	SHORT $LN28@recEventTe

; 475  : 		rcntStartGate(false, counters[4].sCycle);

	mov	edx, ecx
	xor	cl, cl
	call	?rcntStartGate@@YIX_NI@Z		; rcntStartGate

; 476  : 		psxCheckStartGate16(0);

	xor	ecx, ecx
	call	?psxCheckStartGate16@@YAXH@Z		; psxCheckStartGate16

; 477  : 		
; 478  : 		// Setup the hRender's start and end cycle information:
; 479  : 		counters[4].sCycle += vSyncInfo.hBlank;		// start  (absolute cycle value)

	mov	eax, DWORD PTR _vSyncInfo+20
	add	DWORD PTR ?counters@@3PAUCounter@@A+188, eax

; 480  : 		counters[4].CycleT = vSyncInfo.hRender;		// endpoint (delta from start value)

	mov	eax, DWORD PTR _vSyncInfo+16

; 481  : 		counters[4].modeval = MODE_HRENDER;
; 482  : 	}
; 483  : 	else { //HBLANK END / HRENDER Begin

	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	DWORD PTR ?counters@@3PAUCounter@@A+164, 0
	jmp	$LN475@recEventTe
$LN28@recEventTe:

; 484  : 		if (CSRw & 0x4) GSCSRr |= 4; // signal

	test	BYTE PTR ?CSRw@@3IA, 4
	je	SHORT $LN26@recEventTe
	mov	eax, DWORD PTR ?g_RealGSMem@@3PAEA+4100
	or	DWORD PTR ?g_RealGSMem@@3PAEA+4096, 4
	mov	DWORD PTR ?g_RealGSMem@@3PAEA+4100, eax
$LN26@recEventTe:

; 485  : 		if (!(GSIMR&0x400)) gsIrq();

	test	DWORD PTR ?g_RealGSMem@@3PAEA+4112, 1024 ; 00000400H
	jne	SHORT $LN36@recEventTe
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp

; 109  : 	psHu32(INTC_STAT)|= 1<<n;

	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
	or	DWORD PTR [eax+61440], edi

; 110  : 	cpuTestINTCInts();

	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	ecx, DWORD PTR ?counters@@3PAUCounter@@A+188
$LN36@recEventTe:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp

; 486  : 		if (gates) rcntEndGate(false, counters[4].sCycle);

	cmp	DWORD PTR ?gates@@3HA, 0		; gates
	je	SHORT $LN24@recEventTe
	mov	edx, ecx
	xor	cl, cl
	call	?rcntEndGate@@YIX_NI@Z			; rcntEndGate
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	ecx, DWORD PTR ?counters@@3PAUCounter@@A+188
$LN24@recEventTe:

; 487  : 		if (psxhblankgate) psxCheckEndGate16(0);

	cmp	BYTE PTR ?psxhblankgate@@3EA, 0		; psxhblankgate
	je	SHORT $LN38@recEventTe
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\iopcounters.cpp

; 330  : 	_psxCheckEndGate( i );

	xor	ecx, ecx
	call	?_psxCheckEndGate@@YAXH@Z		; _psxCheckEndGate
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	ecx, DWORD PTR ?counters@@3PAUCounter@@A+188
$LN38@recEventTe:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp

; 490  : 		counters[4].sCycle += vSyncInfo.hRender;	// start (absolute cycle value)

	add	ecx, DWORD PTR _vSyncInfo+16

; 491  : 		counters[4].CycleT = vSyncInfo.hBlank;		// endpoint (delta from start value)

	mov	eax, DWORD PTR _vSyncInfo+20
	mov	DWORD PTR ?counters@@3PAUCounter@@A+188, ecx

; 492  : 		counters[4].modeval = MODE_HBLANK;

	mov	DWORD PTR ?counters@@3PAUCounter@@A+164, edi
$LN475@recEventTe:

; 491  : 		counters[4].CycleT = vSyncInfo.hBlank;		// endpoint (delta from start value)

	mov	DWORD PTR ?counters@@3PAUCounter@@A+192, eax
$LN457@recEventTe:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 332  : 	return (int)(cpuRegs.cycle - startCycle) >= delta;

	mov	eax, ebx
	sub	eax, DWORD PTR ?nextsCounter@@3IA	; nextsCounter
	cmp	eax, DWORD PTR ?nextCounter@@3HA	; nextCounter

; 453  : 	rcntUpdate_hScanline();
; 454  : 
; 455  : 	if( cpuTestCycle( nextsCounter, nextCounter ) )

	jl	$LN459@recEventTe
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp

; 502  : 	s32 diff = (cpuRegs.cycle - counters[5].sCycle);

	mov	esi, DWORD PTR ?counters@@3PAUCounter@@A+228
	mov	eax, ebx
	sub	eax, esi

; 503  : 	if( diff < counters[5].CycleT ) return false;

	cmp	eax, DWORD PTR ?counters@@3PAUCounter@@A+232
	jl	$LN476@recEventTe

; 504  : 
; 505  : 	//iopBranchAction = 1;
; 506  : 	if (counters[5].modeval == MODE_VSYNC)

	cmp	DWORD PTR ?counters@@3PAUCounter@@A+204, 3
	jne	$LN52@recEventTe

; 414  : 
; 415  : 	// INTC - VB Blank Start Hack --
; 416  : 	// Hack fix!  This corrects a freezeup in Granda 2 where it decides to spin
; 417  : 	// on the INTC_STAT register after the exception handler has already cleared
; 418  : 	// it.  But be warned!  Set the value to larger than 4 and it breaks Dark
; 419  : 	// Cloud and other games. -_-
; 420  : 
; 421  : 	// How it works: Normally the INTC raises exceptions immediately at the end of the
; 422  : 	// current branch test.  But in the case of Grandia 2, the game's code is spinning
; 423  : 	// on the INTC status, and the exception handler (for some reason?) clears the INTC
; 424  : 	// before returning *and* returns to a location other than EPC.  So the game never
; 425  : 	// gets to the point where it sees the INTC Irq set true.
; 426  : 
; 427  : 	// (I haven't investigated why Dark Cloud freezes on larger values)
; 428  : 	// (all testing done using the recompiler -- dunno how the ints respond yet)
; 429  : 
; 430  : 	//cpuRegs.eCycle[30] = 2;
; 431  : 
; 432  : 	// Should no longer be required (Refraction)
; 433  : }
; 434  : 
; 435  : static __forceinline void VSyncEnd(u32 sCycle)
; 436  : {
; 437  : 	EECNT_LOG( "/////////  EE COUNTER VSYNC END  \\\\\\\\\\\\\\\\\\\\  (frame: %d)\n", iFrame );

	test	DWORD PTR ?varLog@@3IA, 1073741824	; varLog, 40000000H
	je	SHORT $LN61@recEventTe
	push	DWORD PTR _iFrame
	push	OFFSET ??_C@_0DK@GPMLIACH@?1?1?1?1?1?1?1?1?1?5?5EE?5COUNTER?5VSYNC?5END?5@
	call	?SrcLog_EECNT@@YA_NPBDZZ		; SrcLog_EECNT
	add	esp, 8
$LN61@recEventTe:

; 438  : 
; 439  : 	iFrame++;

	inc	DWORD PTR _iFrame

; 440  : 
; 441  : 	if( g_vu1SkipCount > 0 )

	cmp	DWORD PTR ?g_vu1SkipCount@@3IA, 0	; g_vu1SkipCount
	jbe	SHORT $LN58@recEventTe

; 442  : 	{
; 443  : 		gsPostVsyncEnd( false );

	xor	cl, cl
	call	?gsPostVsyncEnd@@YAX_N@Z		; gsPostVsyncEnd
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\windows\winthreads.cpp

; 119  : 				mov          ecx,dword ptr [target]

	mov	ecx, OFFSET ?g_vu1SkipCount@@3IA	; g_vu1SkipCount

; 120  : 				mov          eax,dword ptr [srcval]

	mov	eax, -1

; 121  : 				lock xadd    dword ptr [ecx],eax

	lock	 xadd	 DWORD PTR [ecx], eax

; 122  : 				mov          dword ptr [result], eax

	mov	DWORD PTR _result$3[esp+60], eax
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vumicromem.cpp

; 43   : 	CpuVU1.ExecuteBlock = DummyExecuteVU1Block;

	mov	DWORD PTR ?CpuVU1@@3UVUmicroCpu@@A+8, OFFSET ?DummyExecuteVU1Block@@YAXXZ ; DummyExecuteVU1Block
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp

; 447  : 	else

	jmp	SHORT $LN73@recEventTe
$LN58@recEventTe:

; 448  : 	{
; 449  : 		gsPostVsyncEnd( true );

	mov	cl, 1
	call	?gsPostVsyncEnd@@YAX_N@Z		; gsPostVsyncEnd
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vumicromem.cpp

; 48   : 	CpuVU1.ExecuteBlock = CHECK_VU1REC ? recVU1.ExecuteBlock : intVU1.ExecuteBlock;

	test	BYTE PTR ?g_Session@@3USessionOverrideFlags@@A, 4 ; g_Session
	jne	SHORT $LN72@recEventTe
	test	BYTE PTR ?Config@@3UPcsxConfig@@A+3576, 64 ; 00000040H
	mov	eax, DWORD PTR ?recVU1@@3UVUmicroCpu@@B+8
	jne	SHORT $LN477@recEventTe
$LN72@recEventTe:
	mov	eax, DWORD PTR ?intVU1@@3UVUmicroCpu@@B+8
$LN477@recEventTe:
	mov	DWORD PTR ?CpuVU1@@3UVUmicroCpu@@A+8, eax
$LN73@recEventTe:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp

; 109  : 	psHu32(INTC_STAT)|= 1<<n;

	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
	or	DWORD PTR [eax+61440], 8

; 110  : 	cpuTestINTCInts();

	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\iopcounters.cpp

; 357  : 	psxHu32(0x1070) |= 0x800;

	mov	eax, DWORD PTR ?psxH@@3PAEA		; psxH
	or	DWORD PTR [eax+4208], 2048		; 00000800H

; 358  : 	if(psxvblankgate & (1 << 1)) psxCheckEndGate16(1);

	mov	al, BYTE PTR ?psxvblankgate@@3EA	; psxvblankgate
	test	al, 2
	je	SHORT $LN80@recEventTe

; 330  : 	_psxCheckEndGate( i );

	mov	ecx, edi
	call	?_psxCheckEndGate@@YAXH@Z		; _psxCheckEndGate
	mov	al, BYTE PTR ?psxvblankgate@@3EA	; psxvblankgate
$LN80@recEventTe:

; 359  : 	if(psxvblankgate & (1 << 3)) psxCheckEndGate32(3);

	test	al, 8
	je	SHORT $LN82@recEventTe

; 338  : }
; 339  : 
; 340  : static void psxCheckEndGate32(int i)
; 341  : {
; 342  : 	assert(i == 3);
; 343  : 	_psxCheckEndGate( i );

	mov	ecx, 3
	call	?_psxCheckEndGate@@YAXH@Z		; _psxCheckEndGate
$LN82@recEventTe:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp

; 455  : 	if (gates) rcntEndGate(true, sCycle); // Counters End Gate Code

	cmp	DWORD PTR ?gates@@3HA, 0		; gates
	je	SHORT $LN56@recEventTe
	mov	edx, esi
	mov	cl, 1
	call	?rcntEndGate@@YIX_NI@Z			; rcntEndGate
$LN56@recEventTe:

; 111  : }
; 112  : 
; 113  : void rcntInit() {
; 114  : 	int i;
; 115  : 
; 116  : 	memzero_obj(counters);
; 117  : 
; 118  : 	for (i=0; i<4; i++) {
; 119  : 		counters[i].rate = 2;
; 120  : 		counters[i].target = 0xffff;
; 121  : 	}
; 122  : 	counters[0].interrupt =  9;
; 123  : 	counters[1].interrupt = 10;
; 124  : 	counters[2].interrupt = 11;
; 125  : 	counters[3].interrupt = 12;
; 126  : 
; 127  : 	counters[4].modeval = MODE_HRENDER;
; 128  : 	counters[4].sCycle = cpuRegs.cycle;
; 129  : 	counters[5].modeval = MODE_VRENDER; 
; 130  : 	counters[5].sCycle = cpuRegs.cycle;
; 131  : 
; 132  : 	UpdateVSyncRate();
; 133  : 
; 134  : 	for (i=0; i<4; i++) rcntReset(i);
; 135  : 	cpuRcntSet();
; 136  : }
; 137  : 
; 138  : // debug code, used for stats
; 139  : int g_nCounters[4];
; 140  : static int iFrame = 0;	
; 141  : 
; 142  : #ifndef _WIN32
; 143  : #include <sys/time.h>
; 144  : #endif
; 145  : 
; 146  : static s64 m_iTicks=0;
; 147  : static u64 m_iStart=0;
; 148  : 
; 149  : struct vSyncTimingInfo
; 150  : {
; 151  : 	u32 Framerate;			// frames per second * 100 (so 2500 for PAL and 2997 for NTSC)
; 152  : 	u32 Render;				// time from vblank end to vblank start (cycles)
; 153  : 	u32 Blank;				// time from vblank start to vblank end (cycles)
; 154  : 
; 155  : 	u32 hSyncError;			// rounding error after the duration of a rendered frame (cycles)
; 156  : 	u32 hRender;			// time from hblank end to hblank start (cycles)
; 157  : 	u32 hBlank;				// time from hblank start to hblank end (cycles)
; 158  : 	u32 hScanlinesPerFrame;	// number of scanlines per frame (525/625 for NTSC/PAL)
; 159  : };
; 160  : 
; 161  : 
; 162  : static vSyncTimingInfo vSyncInfo;
; 163  : 
; 164  : 
; 165  : static __forceinline void vSyncInfoCalc( vSyncTimingInfo* info, u32 framesPerSecond, u32 scansPerFrame )
; 166  : {
; 167  : 	// Important: Cannot use floats or doubles here.  The emulator changes rounding modes
; 168  : 	// depending on user-set speedhack options, and it can break float/double code
; 169  : 	// (as in returning infinities and junk)
; 170  : 
; 171  : 	// NOTE: mgs3 likes a /4 vsync, but many games prefer /2.  This seems to indicate a
; 172  : 	// problem in the counters vsync gates somewhere.
; 173  : 
; 174  : 	u64 Frame = ((u64)PS2CLK * 1000000ULL) / framesPerSecond;
; 175  : 	u64 HalfFrame = Frame / 2;
; 176  : 	u64 Blank = HalfFrame / 2;		// two blanks and renders per frame
; 177  : 	u64 Render = HalfFrame - Blank;	// so use the half-frame value for these...
; 178  : 
; 179  : 	// Important!  The hRender/hBlank timers should be 50/50 for best results.
; 180  : 	// In theory a 70%/30% ratio would be more correct but in practice it runs
; 181  : 	// like crap and totally screws audio synchronization and other things.
; 182  : 	
; 183  : 	u64 Scanline = Frame / scansPerFrame;
; 184  : 	u64 hBlank = Scanline / 2;
; 185  : 	u64 hRender = Scanline - hBlank;
; 186  : 	
; 187  : 	info->Framerate = framesPerSecond;
; 188  : 	info->Render = (u32)(Render/10000);
; 189  : 	info->Blank  = (u32)(Blank/10000);
; 190  : 
; 191  : 	info->hRender = (u32)(hRender/10000);
; 192  : 	info->hBlank  = (u32)(hBlank/10000);
; 193  : 	info->hScanlinesPerFrame = scansPerFrame;
; 194  : 	
; 195  : 	// Apply rounding:
; 196  : 	if( ( Render - info->Render ) >= 5000 ) info->Render++;
; 197  : 	else if( ( Blank - info->Blank ) >= 5000 ) info->Blank++;
; 198  : 
; 199  : 	if( ( hRender - info->hRender ) >= 5000 ) info->hRender++;
; 200  : 	else if( ( hBlank - info->hBlank ) >= 5000 ) info->hBlank++;
; 201  : 	
; 202  : 	// Calculate accumulative hSync rounding error per half-frame:
; 203  : 	{
; 204  : 	u32 hSyncCycles = ((info->hRender + info->hBlank) * scansPerFrame) / 2;
; 205  : 	u32 vSyncCycles = (info->Render + info->Blank);
; 206  : 	info->hSyncError = vSyncCycles - hSyncCycles;
; 207  : 	}
; 208  : 
; 209  : 	// Note: In NTSC modes there is some small rounding error in the vsync too,
; 210  : 	// however it would take thousands of frames for it to amount to anything and
; 211  : 	// is thus not worth the effort at this time.
; 212  : }
; 213  : 
; 214  : 
; 215  : u32 UpdateVSyncRate()
; 216  : {
; 217  : 	const char *limiterMsg = "Framelimiter rate updated (UpdateVSyncRate): %d.%d fps";
; 218  : 
; 219  : 	// fixme - According to some docs, progressive-scan modes actually refresh slower than
; 220  : 	// interlaced modes.  But I can't fathom how, since the refresh rate is a function of
; 221  : 	// the television and all the docs I found on TVs made no indication that they ever
; 222  : 	// run anything except their native refresh rate.
; 223  : 
; 224  : 	//#define VBLANK_NTSC			((Config.PsxType & 2) ? 59.94 : 59.82) //59.94 is more precise
; 225  : 	//#define VBLANK_PAL			((Config.PsxType & 2) ? 50.00 : 49.76)
; 226  : 
; 227  : 	if(Config.PsxType & 1)
; 228  : 	{
; 229  : 		if( vSyncInfo.Framerate != FRAMERATE_PAL )
; 230  : 			vSyncInfoCalc( &vSyncInfo, FRAMERATE_PAL, SCANLINES_TOTAL_PAL );
; 231  : 	}
; 232  : 	else
; 233  : 	{
; 234  : 		if( vSyncInfo.Framerate != FRAMERATE_NTSC )
; 235  : 			vSyncInfoCalc( &vSyncInfo, FRAMERATE_NTSC, SCANLINES_TOTAL_NTSC );
; 236  : 	}
; 237  : 
; 238  : 	counters[4].CycleT = vSyncInfo.hRender; // Amount of cycles before the counter will be updated
; 239  : 	counters[5].CycleT = vSyncInfo.Render; // Amount of cycles before the counter will be updated
; 240  : 
; 241  : 	if (Config.CustomFps > 0)
; 242  : 	{
; 243  : 		s64 ticks = GetTickFrequency() / Config.CustomFps;
; 244  : 		if( m_iTicks != ticks )
; 245  : 		{
; 246  : 			m_iTicks = ticks;
; 247  : 			gsOnModeChanged( vSyncInfo.Framerate, m_iTicks );
; 248  : 			Console::Status( limiterMsg, params Config.CustomFps, 0 );
; 249  : 		}
; 250  : 	}
; 251  : 	else
; 252  : 	{
; 253  : 		s64 ticks = (GetTickFrequency() * 50) / vSyncInfo.Framerate;
; 254  : 		if( m_iTicks != ticks )
; 255  : 		{
; 256  : 			m_iTicks = ticks;
; 257  : 			gsOnModeChanged( vSyncInfo.Framerate, m_iTicks );
; 258  : 			Console::Status( limiterMsg, params vSyncInfo.Framerate/50, (vSyncInfo.Framerate*2)%100 );
; 259  : 		}
; 260  : 	}
; 261  : 
; 262  : 	m_iStart = GetCPUTicks();
; 263  : 	cpuRcntSet();
; 264  : 
; 265  : 	// Initialize VU Skip Stuff...
; 266  : 	g_vu1SkipCount = 0;
; 267  : 
; 268  : 	return (u32)m_iTicks;
; 269  : }
; 270  : 
; 271  : extern u32 vu0time;
; 272  : 
; 273  : 
; 274  : void vSyncDebugStuff() {
; 275  : 
; 276  : #ifdef PCSX2_DEVBUILD
; 277  : 		if( g_TestRun.enabled && g_TestRun.frame > 0 ) {
; 278  : 			if( iFrame > g_TestRun.frame ) {
; 279  : 				// take a snapshot
; 280  : 				if( g_TestRun.pimagename != NULL && GSmakeSnapshot2 != NULL ) {
; 281  : 					if( g_TestRun.snapdone ) {
; 282  : 						g_TestRun.curimage++;
; 283  : 						g_TestRun.snapdone = 0;
; 284  : 						g_TestRun.frame += 20;
; 285  : 						if( g_TestRun.curimage >= g_TestRun.numimages ) {
; 286  : 							// exit
; 287  : 							SysClose();
; 288  : 							exit(0);
; 289  : 						}
; 290  : 					}
; 291  : 					else {
; 292  : 						// query for the image
; 293  : 						GSmakeSnapshot2(g_TestRun.pimagename, &g_TestRun.snapdone, g_TestRun.jpgcapture);
; 294  : 					}
; 295  : 				}
; 296  : 				else {
; 297  : 					// exit
; 298  : 					SysClose();
; 299  : 					exit(0);
; 300  : 				}
; 301  : 			}
; 302  : 		}
; 303  : 
; 304  : 		GSVSYNC();
; 305  : 
; 306  : 		if( g_SaveGSStream == 1 ) {
; 307  : 			freezeData fP;
; 308  : 
; 309  : 			g_SaveGSStream = 2;
; 310  : 			g_fGSSave->gsFreeze();
; 311  : 			
; 312  : 			if (GSfreeze(FREEZE_SIZE, &fP) == -1) {
; 313  : 				safe_delete( g_fGSSave );
; 314  : 				g_SaveGSStream = 0;
; 315  : 			}
; 316  : 			else {
; 317  : 				fP.data = (s8*)malloc(fP.size);
; 318  : 				if (fP.data == NULL) {
; 319  : 					safe_delete( g_fGSSave );
; 320  : 					g_SaveGSStream = 0;
; 321  : 				}
; 322  : 				else {
; 323  : 					if (GSfreeze(FREEZE_SAVE, &fP) == -1) {
; 324  : 						safe_delete( g_fGSSave );
; 325  : 						g_SaveGSStream = 0;
; 326  : 					}
; 327  : 					else {
; 328  : 						g_fGSSave->Freeze( fP.size );
; 329  : 						if (fP.size) {
; 330  : 							g_fGSSave->FreezeMem( fP.data, fP.size );
; 331  : 							free(fP.data);
; 332  : 						}
; 333  : 					}
; 334  : 				}
; 335  : 			}
; 336  : 		}
; 337  : 		else if( g_SaveGSStream == 2 ) {
; 338  : 			
; 339  : 			if( --g_nLeftGSFrames <= 0 ) {
; 340  : 				safe_delete( g_fGSSave );
; 341  : 				g_SaveGSStream = 0;
; 342  : 				Console::WriteLn("Done saving GS stream");
; 343  : 			}
; 344  : 		}
; 345  : #endif
; 346  : }
; 347  : 
; 348  : void frameLimitReset()
; 349  : {
; 350  : 	m_iStart = GetCPUTicks();
; 351  : }
; 352  : 
; 353  : // Framelimiter - Measures the delta time between calls and stalls until a
; 354  : // certain amount of time passes if such time hasn't passed yet.
; 355  : // See the GS FrameSkip function for details on why this is here and not in the GS.
; 356  : static __forceinline void frameLimit()
; 357  : {
; 358  : 	s64 sDeltaTime;
; 359  : 	u64 uExpectedEnd;
; 360  : 	u64 iEnd;
; 361  : 
; 362  : 	if( CHECK_FRAMELIMIT == PCSX2_FRAMELIMIT_NORMAL ) return;

	test	DWORD PTR ?Config@@3UPcsxConfig@@A+3576, 3072 ; 00000c00H
	je	$LN458@recEventTe

; 363  : 	if( Config.CustomFps >= 999 ) return;	// means the user would rather just have framelimiting turned off...

	cmp	DWORD PTR ?Config@@3UPcsxConfig@@A+3604, 999 ; 000003e7H
	jge	$LN458@recEventTe

; 365  : 	uExpectedEnd = m_iStart + m_iTicks;

	mov	esi, DWORD PTR _m_iTicks
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\misc.cpp

; 825  :     QueryPerformanceCounter(&count);

	lea	eax, DWORD PTR _count$5[esp+60]
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp

; 365  : 	uExpectedEnd = m_iStart + m_iTicks;

	add	esi, DWORD PTR _m_iStart
	mov	edi, DWORD PTR _m_iTicks+4
	adc	edi, DWORD PTR _m_iStart+4
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\misc.cpp

; 825  :     QueryPerformanceCounter(&count);

	push	eax
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp

; 365  : 	uExpectedEnd = m_iStart + m_iTicks;

	mov	DWORD PTR _uExpectedEnd$1$[esp+64], esi
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\misc.cpp

; 825  :     QueryPerformanceCounter(&count);

	call	DWORD PTR __imp__QueryPerformanceCounter@4
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp

; 368  : 	sDeltaTime = iEnd - uExpectedEnd;

	mov	ecx, DWORD PTR _count$5[esp+60]
	mov	ebx, ecx
	mov	edx, DWORD PTR _count$5[esp+64]
	sub	ebx, esi

; 369  : 
; 370  : 	// If the framerate drops too low, reset the expected value.  This avoids
; 371  : 	// excessive amounts of "fast forward" syndrome which would occur if we
; 372  : 	// tried to catch up too much.
; 373  : 	
; 374  : 	if( sDeltaTime > m_iTicks*8 )

	mov	esi, DWORD PTR _m_iTicks
	mov	eax, edx
	sbb	eax, edi
	mov	DWORD PTR _sDeltaTime$1$[esp+60], eax
	mov	eax, DWORD PTR _m_iTicks+4
	shld	eax, esi, 3
	shl	esi, 3
	mov	DWORD PTR tv3158[esp+60], esi
	mov	esi, DWORD PTR _uExpectedEnd$1$[esp+60]
	cmp	DWORD PTR _sDeltaTime$1$[esp+60], eax
	jl	SHORT $LN86@recEventTe
	jg	SHORT $LN451@recEventTe
	cmp	ebx, DWORD PTR tv3158[esp+60]
	jbe	SHORT $LN86@recEventTe
$LN451@recEventTe:

; 375  : 	{
; 376  : 		m_iStart = iEnd - m_iTicks;

	sub	ecx, DWORD PTR _m_iTicks
	mov	DWORD PTR _m_iStart, ecx
	sbb	edx, DWORD PTR _m_iTicks+4

; 377  : 
; 378  : 		// Let the GS Skipper know we lost time.
; 379  : 		// Keeps the GS skipper from trying to catch up to a framerate
; 380  : 		// that the limiter already gave up on.
; 381  : 
; 382  : 		gsSyncLimiterLostTime( (s32)(m_iStart - uExpectedEnd) );

	sub	ecx, esi
	mov	DWORD PTR _m_iStart+4, edx
	call	?gsSyncLimiterLostTime@@YAXH@Z		; gsSyncLimiterLostTime

; 383  : 		return;

	jmp	SHORT $LN458@recEventTe
$LN86@recEventTe:

; 384  : 	}
; 385  : 
; 386  : 	// use the expected frame completion time as our starting point.
; 387  : 	// improves smoothness by making the framelimiter more adaptive to the
; 388  : 	// imperfect TIMESLICE() wait, and allows it to speed up a wee bit after
; 389  : 	// slow frames to "catch up."
; 390  : 
; 391  : 	m_iStart = uExpectedEnd;
; 392  : 
; 393  : 	while( sDeltaTime < 0 )

	cmp	DWORD PTR _sDeltaTime$1$[esp+60], 0
	mov	DWORD PTR _m_iStart, esi
	mov	DWORD PTR _m_iStart+4, edi
	jg	SHORT $LN458@recEventTe
	jl	SHORT $LN454@recEventTe
	test	ebx, ebx
	jae	SHORT $LN458@recEventTe
$LN454@recEventTe:
	mov	ebx, DWORD PTR __imp__Sleep@4
	npad	4
$LL85@recEventTe:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\windows\winthreads.cpp

; 61   : 		Sleep(0);

	push	0
	call	ebx
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\misc.cpp

; 825  :     QueryPerformanceCounter(&count);

	lea	eax, DWORD PTR _count$2[esp+60]
	push	eax
	call	DWORD PTR __imp__QueryPerformanceCounter@4
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp

; 397  : 		sDeltaTime = iEnd - uExpectedEnd;

	mov	ecx, DWORD PTR _count$2[esp+60]
	mov	eax, DWORD PTR _count$2[esp+64]
	sub	ecx, esi
	sbb	eax, edi
	mov	DWORD PTR _sDeltaTime$1[esp+64], eax
	js	SHORT $LL85@recEventTe

; 384  : 	}
; 385  : 
; 386  : 	// use the expected frame completion time as our starting point.
; 387  : 	// improves smoothness by making the framelimiter more adaptive to the
; 388  : 	// imperfect TIMESLICE() wait, and allows it to speed up a wee bit after
; 389  : 	// slow frames to "catch up."
; 390  : 
; 391  : 	m_iStart = uExpectedEnd;
; 392  : 
; 393  : 	while( sDeltaTime < 0 )

	jg	SHORT $LN458@recEventTe
	test	ecx, ecx
	jb	SHORT $LL85@recEventTe
$LN458@recEventTe:

; 507  : 	{
; 508  : 		VSyncEnd(counters[5].sCycle);
; 509  : 
; 510  : 		counters[5].sCycle += vSyncInfo.Blank;

	mov	eax, DWORD PTR _vSyncInfo+8
	add	DWORD PTR ?counters@@3PAUCounter@@A+228, eax

; 511  : 		counters[5].CycleT = vSyncInfo.Render;

	mov	eax, DWORD PTR _vSyncInfo+4

; 512  : 		counters[5].modeval = MODE_VRENDER;
; 513  : 
; 514  : 		return true;

	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	DWORD PTR ?counters@@3PAUCounter@@A+232, eax
	mov	DWORD PTR ?counters@@3PAUCounter@@A+204, 0
	mov	BYTE PTR _vsyncEvent$1$[esp+60], 1
	jmp	$LN54@recEventTe
$LN52@recEventTe:

; 398  : 	}
; 399  : }
; 400  : 
; 401  : static __forceinline void VSyncStart(u32 sCycle)
; 402  : {
; 403  : 	EECNT_LOG( "/////////  EE COUNTER VSYNC START  \\\\\\\\\\\\\\\\\\\\  (frame: %d)\n", iFrame );

	test	DWORD PTR ?varLog@@3IA, 1073741824	; varLog, 40000000H
	je	SHORT $LN103@recEventTe
	push	DWORD PTR _iFrame
	push	OFFSET ??_C@_0DM@NMBMHAFB@?1?1?1?1?1?1?1?1?1?5?5EE?5COUNTER?5VSYNC?5STAR@
	call	?SrcLog_EECNT@@YA_NPBDZZ		; SrcLog_EECNT
	add	esp, 8
$LN103@recEventTe:

; 404  : 	vSyncDebugStuff(); // EE Profiling and Debug code

	call	?vSyncDebugStuff@@YAXXZ			; vSyncDebugStuff

; 405  : 
; 406  : 	if ((CSRw & 0x8)) GSCSRr|= 0x8;

	test	BYTE PTR ?CSRw@@3IA, 8
	je	SHORT $LN100@recEventTe
	mov	eax, DWORD PTR ?g_RealGSMem@@3PAEA+4100
	or	DWORD PTR ?g_RealGSMem@@3PAEA+4096, 8
	mov	DWORD PTR ?g_RealGSMem@@3PAEA+4100, eax
$LN100@recEventTe:

; 407  : 	if (!(GSIMR&0x800)) gsIrq();

	test	DWORD PTR ?g_RealGSMem@@3PAEA+4112, 2048 ; 00000800H
	jne	SHORT $LN106@recEventTe
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp

; 109  : 	psHu32(INTC_STAT)|= 1<<n;

	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
	or	DWORD PTR [eax+61440], edi

; 110  : 	cpuTestINTCInts();

	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
$LN106@recEventTe:

; 109  : 	psHu32(INTC_STAT)|= 1<<n;

	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
	or	DWORD PTR [eax+61440], 4

; 110  : 	cpuTestINTCInts();

	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\iopcounters.cpp

; 349  : 	cdvdVsync();

	call	?cdvdVsync@@YAXXZ			; cdvdVsync

; 350  : 	psxHu32(0x1070) |= 1;

	mov	eax, DWORD PTR ?psxH@@3PAEA		; psxH
	or	DWORD PTR [eax+4208], edi

; 351  : 	if(psxvblankgate & (1 << 1)) psxCheckStartGate16(1);

	mov	al, BYTE PTR ?psxvblankgate@@3EA	; psxvblankgate
	test	al, 2
	je	SHORT $LN111@recEventTe
	mov	ecx, edi
	call	?psxCheckStartGate16@@YAXH@Z		; psxCheckStartGate16
	mov	al, BYTE PTR ?psxvblankgate@@3EA	; psxvblankgate
$LN111@recEventTe:

; 352  : 	if(psxvblankgate & (1 << 3)) psxCheckStartGate32(3);

	test	al, 8
	je	SHORT $LN133@recEventTe

; 331  : }
; 332  : 
; 333  : static void psxCheckStartGate32(int i)
; 334  : {
; 335  : 	// 32 bit gate is called for gate 3 only.  Ever.
; 336  : 	assert(i == 3);
; 337  : 	_psxCheckStartGate( i );

	mov	ecx, 3
	call	?_psxCheckStartGate@@YAXH@Z		; _psxCheckStartGate
$LN133@recEventTe:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp

; 412  : 	if (gates) rcntStartGate(true, sCycle); // Counters Start Gate code

	cmp	DWORD PTR ?gates@@3HA, 0		; gates
	je	SHORT $LN98@recEventTe
	mov	edx, esi
	mov	cl, 1
	call	?rcntStartGate@@YIX_NI@Z		; rcntStartGate
$LN98@recEventTe:

; 413  : 	if (Config.Patch) applypatch(1); // Apply patches (ToDo: clean up patch code)

	cmp	DWORD PTR ?Config@@3UPcsxConfig@@A+3596, 0
	je	SHORT $LN97@recEventTe
	mov	ecx, edi
	call	?applypatch@@YAXH@Z			; applypatch
$LN97@recEventTe:

; 515  : //		SysUpdate();  // check for and handle keyevents
; 516  : 	}
; 517  : 	else	// VSYNC end / VRENDER begin
; 518  : 	{
; 519  : 		VSyncStart(counters[5].sCycle);
; 520  : 
; 521  : 		counters[5].sCycle += vSyncInfo.Render;

	mov	eax, DWORD PTR _vSyncInfo+4
	add	DWORD PTR ?counters@@3PAUCounter@@A+228, eax

; 522  : 		counters[5].CycleT = vSyncInfo.Blank;

	mov	eax, DWORD PTR _vSyncInfo+8

; 523  : 		counters[5].modeval = MODE_VSYNC;
; 524  : 
; 525  : 		// Accumulate hsync rounding errors:
; 526  : 		counters[4].sCycle += vSyncInfo.hSyncError;
; 527  : 
; 528  : #		ifdef VSYNC_DEBUG
; 529  : 		vblankinc++;
; 530  : 		if( vblankinc > 1 )
; 531  : 		{
; 532  : 			if( hsc != vSyncInfo.hScanlinesPerFrame )
; 533  : 				SysPrintf( " ** vSync > Abnormal Scanline Count: %d\n", hsc );
; 534  : 			hsc = 0;
; 535  : 			vblankinc = 0;
; 536  : 		}
; 537  : #		endif
; 538  : 	}
; 539  : 	return false;

	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	DWORD PTR ?counters@@3PAUCounter@@A+232, eax
	mov	eax, DWORD PTR _vSyncInfo+12
	add	DWORD PTR ?counters@@3PAUCounter@@A+188, eax
	mov	DWORD PTR ?counters@@3PAUCounter@@A+204, 3
$LN476@recEventTe:
	mov	BYTE PTR _vsyncEvent$1$[esp+60], 0
$LN54@recEventTe:

; 575  : 
; 576  : 
; 577  : // forceinline note: this method is called from two locations, but one
; 578  : // of them is the interpreter, which doesn't count. ;)  So might as
; 579  : // well forceinline it!
; 580  : __forceinline bool rcntUpdate()
; 581  : {
; 582  : 	bool retval = rcntUpdate_vSync();
; 583  : 
; 584  : 	// Update counters so that we can perform overflow and target tests.
; 585  : 	
; 586  : 	for (int i=0; i<=3; i++) {

	mov	DWORD PTR _i$1$[esp+60], 0
	mov	edi, OFFSET ?counters@@3PAUCounter@@A+4
	npad	8
$LL48@recEventTe:

; 587  : 		
; 588  : 		// We want to count gated counters (except the hblank which exclude below, and are
; 589  : 		// counted by the hblank timer instead)
; 590  : 
; 591  : 		//if ( gates & (1<<i) ) continue;
; 592  : 		
; 593  : 		if (!counters[i].mode.IsCounting ) continue;

	mov	eax, DWORD PTR [edi]
	test	al, al
	jns	$LN47@recEventTe

; 594  : 
; 595  : 		if(counters[i].mode.ClockSource != 0x3)	// don't count hblank sources

	and	eax, 3
	cmp	al, 3
	je	$LN44@recEventTe

; 596  : 		{
; 597  : 			s32 change = cpuRegs.cycle - counters[i].sCycleT;

	mov	esi, ebx

; 540  : }
; 541  : 
; 542  : static __forceinline void __fastcall _cpuTestTarget( int i )
; 543  : {
; 544  : 	if (counters[i].count < counters[i].target) return;

	mov	ecx, DWORD PTR [edi+4]

; 596  : 		{
; 597  : 			s32 change = cpuRegs.cycle - counters[i].sCycleT;

	sub	esi, DWORD PTR [edi+32]

; 598  : 			if( change < 0 ) change = 0;	// sanity check!

	mov	eax, 0
	cmovs	esi, eax

; 599  : 
; 600  : 			counters[i].count += change / counters[i].rate;

	xor	edx, edx
	mov	eax, esi
	div	DWORD PTR [edi+12]
	add	DWORD PTR [edi-4], eax

; 601  : 			change -= (change / counters[i].rate) * counters[i].rate;

	imul	eax, DWORD PTR [edi+12]

; 540  : }
; 541  : 
; 542  : static __forceinline void __fastcall _cpuTestTarget( int i )
; 543  : {
; 544  : 	if (counters[i].count < counters[i].target) return;

	mov	edx, DWORD PTR [edi-4]

; 601  : 			change -= (change / counters[i].rate) * counters[i].rate;

	sub	esi, eax

; 602  : 			counters[i].sCycleT = cpuRegs.cycle - change;

	mov	eax, ebx
	sub	eax, esi
	mov	DWORD PTR [edi+32], eax

; 545  : 
; 546  : 	if(counters[i].mode.TargetInterrupt) {

	mov	eax, DWORD PTR [edi]
	cmp	edx, ecx
	jb	SHORT $LN472@recEventTe
	test	eax, 256				; 00000100H
	je	SHORT $LN138@recEventTe

; 547  : 
; 548  : 		EECNT_LOG("EE Counter[%d] TARGET reached - mode=%x, count=%x, target=%x\n", i, counters[i].mode, counters[i].count, counters[i].target);

	test	DWORD PTR ?varLog@@3IA, 1073741824	; varLog, 40000000H
	mov	esi, DWORD PTR _i$1$[esp+60]
	je	SHORT $LN142@recEventTe
	push	ecx
	push	edx
	push	eax
	push	esi
	push	OFFSET ??_C@_0DO@EGNLMAGK@EE?5Counter?$FL?$CFd?$FN?5TARGET?5reached?5?9?5@
	call	?SrcLog_EECNT@@YA_NPBDZZ		; SrcLog_EECNT
	add	esp, 20					; 00000014H
$LN142@recEventTe:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp

; 109  : 	psHu32(INTC_STAT)|= 1<<n;

	mov	edx, DWORD PTR ?psH@@3PAEA		; psH
	mov	eax, 1
	mov	ecx, DWORD PTR [edi+16]
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp

; 549  : 		counters[i].mode.TargetReached = 1;

	or	DWORD PTR [edi], 1024			; 00000400H
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp

; 109  : 	psHu32(INTC_STAT)|= 1<<n;

	shl	eax, cl
	or	DWORD PTR [edx+61440], eax

; 110  : 	cpuTestINTCInts();

	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp

; 553  : 		if (counters[i].mode.ZeroReturn)

	mov	eax, DWORD PTR [edi]

; 555  : 		else

	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	test	al, 64					; 00000040H
	je	SHORT $LN137@recEventTe

; 554  : 			counters[i].count -= counters[i].target; // Reset on target

	mov	eax, DWORD PTR [edi+4]
	sub	DWORD PTR [edi-4], eax

; 555  : 		else

	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN135@recEventTe
$LN137@recEventTe:

; 556  : 			counters[i].target |= EECNT_FUTURE_TARGET;

	or	DWORD PTR [edi+4], 268435456		; 10000000H
	jmp	SHORT $LN135@recEventTe
$LN138@recEventTe:

; 557  : 	} 
; 558  : 	else counters[i].target |= EECNT_FUTURE_TARGET;

	or	ecx, 268435456				; 10000000H
	mov	DWORD PTR [edi+4], ecx
$LN472@recEventTe:
	mov	esi, DWORD PTR _i$1$[esp+60]
$LN135@recEventTe:

; 559  : }
; 560  : 
; 561  : static __forceinline void _cpuTestOverflow( int i )
; 562  : {
; 563  : 	if (counters[i].count <= 0xffff) return;

	mov	ecx, DWORD PTR [edi-4]
	cmp	ecx, 65535				; 0000ffffH
	jbe	SHORT $LN47@recEventTe

; 564  : 	
; 565  : 	if (counters[i].mode.OverflowInterrupt) {

	test	eax, 512				; 00000200H
	je	SHORT $LN150@recEventTe

; 566  : 		EECNT_LOG("EE Counter[%d] OVERFLOW - mode=%x, count=%x\n", i, counters[i].mode, counters[i].count);

	test	DWORD PTR ?varLog@@3IA, 1073741824	; varLog, 40000000H
	je	SHORT $LN149@recEventTe
	push	ecx
	push	DWORD PTR [edi]
	push	esi
	push	OFFSET ??_C@_0CN@DJCFHOEE@EE?5Counter?$FL?$CFd?$FN?5OVERFLOW?5?9?5mode?$DN?$CF@
	call	?SrcLog_EECNT@@YA_NPBDZZ		; SrcLog_EECNT
	add	esp, 16					; 00000010H
$LN149@recEventTe:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp

; 109  : 	psHu32(INTC_STAT)|= 1<<n;

	mov	edx, DWORD PTR ?psH@@3PAEA		; psH
	mov	eax, 1
	mov	ecx, DWORD PTR [edi+16]
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp

; 567  : 		counters[i].mode.OverflowReached = 1;

	or	DWORD PTR [edi], 2048			; 00000800H
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp

; 109  : 	psHu32(INTC_STAT)|= 1<<n;

	shl	eax, cl
	or	DWORD PTR [edx+61440], eax

; 110  : 	cpuTestINTCInts();

	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
$LN150@recEventTe:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp

; 572  : 	counters[i].count -= 0x10000;

	add	DWORD PTR [edi-4], -65536		; ffff0000H

; 573  : 	counters[i].target &= 0xffff;

	xor	eax, eax
	mov	WORD PTR [edi+6], ax

; 574  : }

	jmp	SHORT $LN47@recEventTe
$LN44@recEventTe:

; 603  : 
; 604  : 			// Check Counter Targets and Overflows:
; 605  : 			_cpuTestTarget( i );
; 606  : 			_cpuTestOverflow( i );
; 607  : 		} 
; 608  : 		else counters[i].sCycleT = cpuRegs.cycle;

	mov	DWORD PTR [edi+32], ebx
$LN47@recEventTe:

; 575  : 
; 576  : 
; 577  : // forceinline note: this method is called from two locations, but one
; 578  : // of them is the interpreter, which doesn't count. ;)  So might as
; 579  : // well forceinline it!
; 580  : __forceinline bool rcntUpdate()
; 581  : {
; 582  : 	bool retval = rcntUpdate_vSync();
; 583  : 
; 584  : 	// Update counters so that we can perform overflow and target tests.
; 585  : 	
; 586  : 	for (int i=0; i<=3; i++) {

	inc	DWORD PTR _i$1$[esp+60]
	add	edi, 40					; 00000028H
	cmp	edi, OFFSET ?counters@@3PAUCounter@@A+124
	jle	$LL48@recEventTe

; 96   : }
; 97   : 
; 98   : 
; 99   : static __forceinline void cpuRcntSet()
; 100  : {
; 101  : 	int i;
; 102  : 
; 103  : 	nextsCounter = cpuRegs.cycle;
; 104  : 	nextCounter = (counters[5].sCycle + counters[5].CycleT) - cpuRegs.cycle;

	mov	edx, DWORD PTR ?counters@@3PAUCounter@@A+232
	mov	esi, OFFSET ?counters@@3PAUCounter@@A+8
	sub	edx, ebx
	mov	DWORD PTR ?nextsCounter@@3IA, ebx	; nextsCounter
	add	edx, DWORD PTR ?counters@@3PAUCounter@@A+228
	npad	2
$LL155@recEventTe:

; 69   : 	if (!counter.mode.IsCounting || (counter.mode.ClockSource == 0x3) ) return;

	mov	eax, DWORD PTR [esi-4]
	test	al, al
	jns	SHORT $LN154@recEventTe
	and	eax, 3
	cmp	al, 3
	je	SHORT $LN154@recEventTe

; 70   : 	
; 71   : 	// check for special cases where the overflow or target has just passed
; 72   : 	// (we probably missed it because we're doing/checking other things)
; 73   : 	if( counter.count > 0x10000 || counter.count > counter.target )

	mov	edi, DWORD PTR [esi-8]
	cmp	edi, 65536				; 00010000H
	ja	SHORT $LN161@recEventTe
	mov	ecx, DWORD PTR [esi]
	cmp	edi, ecx
	ja	SHORT $LN161@recEventTe

; 76   : 		return;
; 77   : 	}
; 78   : 
; 79   : 	// nextCounter is relative to the cpuRegs.cycle when rcntUpdate() was last called.
; 80   : 	// However, the current _rcntSet could be called at any cycle count, so we need to take
; 81   : 	// that into account.  Adding the difference from that cycle count to the current one
; 82   : 	// will do the trick!
; 83   : 
; 84   : 	c = ((0x10000 - counter.count) * counter.rate) - (cpuRegs.cycle - counter.sCycleT);

	mov	eax, 65536				; 00010000H
	sub	eax, edi
	imul	eax, DWORD PTR [esi+8]

; 85   : 	c += cpuRegs.cycle - nextsCounter;		// adjust for time passed since last rcntUpdate();

	sub	eax, ebx
	add	eax, DWORD PTR [esi+28]

; 86   : 	if (c < nextCounter) nextCounter = c;

	cmp	eax, edx
	cmovl	edx, eax

; 87   : 
; 88   : 	// Ignore target diff if target is currently disabled.
; 89   : 	// (the overflow is all we care about since it goes first, and then the 
; 90   : 	// target will be turned on afterward).
; 91   : 
; 92   : 	if( counter.target & EECNT_FUTURE_TARGET ) return;

	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN154@recEventTe

; 93   : 	c = ((counter.target - counter.count) * counter.rate) - (cpuRegs.cycle - counter.sCycleT);

	sub	ecx, edi
	imul	ecx, DWORD PTR [esi+8]

; 94   : 	c += cpuRegs.cycle - nextsCounter;		// adjust for time passed since last rcntUpdate();

	sub	ecx, ebx
	add	ecx, DWORD PTR [esi+28]

; 95   : 	if (c < nextCounter) nextCounter = c;

	cmp	ecx, edx
	jge	SHORT $LN154@recEventTe
	mov	edx, ecx
	jmp	SHORT $LN154@recEventTe
$LN161@recEventTe:

; 74   : 	{
; 75   : 		nextCounter = 4;

	mov	edx, 4
$LN154@recEventTe:

; 105  : 
; 106  : 	for (i = 0; i < 4; i++)

	add	esi, 40					; 00000028H
	cmp	esi, OFFSET ?counters@@3PAUCounter@@A+168
	jl	SHORT $LL155@recEventTe
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 414  : 	if((cpuRegs.PERF.n.pccr & 0x800003E0) == 0x80000020) {

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+688
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp

; 110  : 	if( nextCounter < 0 ) nextCounter = 0;

	xor	eax, eax
	test	edx, edx
	cmovs	edx, eax
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 414  : 	if((cpuRegs.PERF.n.pccr & 0x800003E0) == 0x80000020) {

	mov	eax, ecx
	and	eax, -2147482656			; 800003e0H
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp

; 110  : 	if( nextCounter < 0 ) nextCounter = 0;

	mov	DWORD PTR ?nextCounter@@3HA, edx	; nextCounter
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 414  : 	if((cpuRegs.PERF.n.pccr & 0x800003E0) == 0x80000020) {

	cmp	eax, -2147483616			; 80000020H
	jne	SHORT $LN168@recEventTe

; 415  : 		cpuRegs.PERF.n.pcr0 += cpuRegs.cycle-s_iLastPERFCycle[0];

	mov	eax, ebx
	sub	eax, DWORD PTR ?s_iLastPERFCycle@@3PAIA
	add	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+692, eax

; 416  : 		s_iLastPERFCycle[0] = cpuRegs.cycle;

	mov	DWORD PTR ?s_iLastPERFCycle@@3PAIA, ebx
$LN168@recEventTe:

; 417  : 	}
; 418  : 	if((cpuRegs.PERF.n.pccr & 0x800F8000) == 0x80008000) {

	and	ecx, -2146467840			; 800f8000H
	mov	edi, 1
	cmp	ecx, -2147450880			; 80008000H
	jne	SHORT $LN459@recEventTe

; 419  : 		cpuRegs.PERF.n.pcr1 += cpuRegs.cycle-s_iLastPERFCycle[1];

	mov	eax, ebx
	sub	eax, DWORD PTR ?s_iLastPERFCycle@@3PAIA+4
	add	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+696, eax

; 420  : 		s_iLastPERFCycle[1] = cpuRegs.cycle;

	mov	DWORD PTR ?s_iLastPERFCycle@@3PAIA+4, ebx
$LN459@recEventTe:

; 375  : 	{
; 376  : 		TESTINT(0, vif0Interrupt);
; 377  : #ifndef IPU_INLINE_IRQS
; 378  : 		TESTINT(3, ipu0Interrupt);
; 379  : 		TESTINT(4, ipu1Interrupt);
; 380  : #endif
; 381  : 		TESTINT(8, SPRFROMinterrupt);
; 382  : 		TESTINT(9, SPRTOinterrupt);
; 383  : 
; 384  : 		TESTINT(10, vifMFIFOInterrupt);
; 385  : 		TESTINT(11, gifMFIFOInterrupt);
; 386  : 	}
; 387  : }
; 388  : 
; 389  : static __forceinline void _cpuTestTIMR()
; 390  : {
; 391  : 	cpuRegs.CP0.n.Count += cpuRegs.cycle-s_iLastCOP0Cycle;

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+580
	mov	eax, ebx
	sub	eax, DWORD PTR ?s_iLastCOP0Cycle@@3IA	; s_iLastCOP0Cycle
	add	ecx, eax

; 392  : 	s_iLastCOP0Cycle = cpuRegs.cycle;

	mov	DWORD PTR ?s_iLastCOP0Cycle@@3IA, ebx	; s_iLastCOP0Cycle

; 393  : 
; 394  : 	// fixme: this looks like a hack to make up for the fact that the TIMR
; 395  : 	// doesn't yet have a proper mechanism for setting itself up on a nextBranchCycle.
; 396  : 	// A proper fix would schedule the TIMR to trigger at a specific cycle anytime
; 397  : 	// the Count or Compare registers are modified.
; 398  : 
; 399  : 	if ( (cpuRegs.CP0.n.Status.val & 0x8000) &&
; 400  : 		cpuRegs.CP0.n.Count >= cpuRegs.CP0.n.Compare && cpuRegs.CP0.n.Count < cpuRegs.CP0.n.Compare+1000 )

	test	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+592, 32768 ; 00008000H
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+580, ecx
	je	SHORT $LN171@recEventTe
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+588
	cmp	ecx, edx
	jb	SHORT $LN171@recEventTe
	lea	eax, DWORD PTR [edx+1000]
	cmp	ecx, eax
	jae	SHORT $LN171@recEventTe

; 401  : 	{
; 402  : 		Console::Status("timr intr: %x, %x", params cpuRegs.CP0.n.Count, cpuRegs.CP0.n.Compare);

	push	edx
	push	ecx
	push	0
	push	OFFSET ??_C@_0BC@KKHOMMCD@timr?5intr?3?5?$CFx?0?5?$CFx?$AA@
	call	?Status@Console@@YA_NPBDPBU_VARG_PARAM@@ZZ ; Console::Status

; 403  : 		cpuException(0x808000, cpuRegs.branch);

	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+968
	add	esp, 16					; 00000010H
	mov	ecx, 8421376				; 00808000H
	call	?cpuException@@YAXII@Z			; cpuException
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
$LN171@recEventTe:

; 456  : 	{
; 457  : 		vsyncEvent = rcntUpdate();
; 458  : 		_cpuTestPERF();
; 459  : 	}
; 460  : 
; 461  : 	_cpuTestTIMR();
; 462  : 
; 463  : 	// ---- Interrupts -------------
; 464  : 	// Handles all interrupts except 30 and 31, which are handled later.
; 465  : 
; 466  : 	if( cpuRegs.interrupt & ~(3<<30) )

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
	test	ecx, 1073741823				; 3fffffffH
	je	$LN371@recEventTe

; 345  : }
; 346  : 
; 347  : static __forceinline void TESTINT( u8 n, void (*callback)() )
; 348  : {
; 349  : 	if( !(cpuRegs.interrupt & (1 << n)) ) return;

	test	cl, 2
	je	$LN220@recEventTe

; 332  : 	return (int)(cpuRegs.cycle - startCycle) >= delta;

	mov	esi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+836
	mov	eax, ebx
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+708
	sub	eax, esi
	cmp	eax, edx

; 350  : 
; 351  : 	if( cpuTestCycle( cpuRegs.sCycle[n], cpuRegs.eCycle[n] ) )

	jl	$LN178@recEventTe

; 344  : 	cpuRegs.interrupt &= ~(1 << i);

	and	ecx, -3					; fffffffdH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vifdma.cpp

; 1974 : 	VIF_LOG("vif1Interrupt: %8.8x\n", cpuRegs.cycle);

	test	DWORD PTR ?varLog@@3IA, 1024		; varLog, 00000400H
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 344  : 	cpuRegs.interrupt &= ~(1 << i);

	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, ecx
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vifdma.cpp

; 1974 : 	VIF_LOG("vif1Interrupt: %8.8x\n", cpuRegs.cycle);

	je	SHORT $LN201@recEventTe
	push	ebx
	push	OFFSET ??_C@_0BG@OEMEHKAM@vif1Interrupt?3?5?$CF8?48x?6?$AA@
	call	?SrcLog_VIF@@YA_NPBDZZ			; SrcLog_VIF
	add	esp, 8
$LN201@recEventTe:

; 1975 : 
; 1976 : 	g_vifCycles = 0;
; 1977 :     
; 1978 : 	
; 1979 : 		if(vif1.irq && vif1.tag.size == 0) {

	cmp	DWORD PTR ?vif1@@3UvifStruct@@A+20, 0
	mov	DWORD PTR ?g_vifCycles@@3HA, 0		; g_vifCycles
	je	$LN196@recEventTe
	cmp	DWORD PTR ?vif1@@3UvifStruct@@A+4, 0
	jne	$LN196@recEventTe

; 1980 : 			vif1Regs->stat|= VIF1_STAT_INT;

	mov	esi, DWORD PTR ?psH@@3PAEA		; psH
	or	DWORD PTR [esi+15360], 2048		; 00000800H
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp

; 109  : 	psHu32(INTC_STAT)|= 1<<n;

	or	DWORD PTR [esi+61440], 32		; 00000020H

; 110  : 	cpuTestINTCInts();

	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vifdma.cpp

; 1982 : 			--vif1.irq;

	dec	DWORD PTR ?vif1@@3UvifStruct@@A+20

; 1983 : 			if(vif1Regs->stat & (VIF1_STAT_VSS|VIF1_STAT_VIS|VIF1_STAT_VFS))

	mov	eax, DWORD PTR [esi+15360]
	test	eax, 1792				; 00000700H
	je	SHORT $LN197@recEventTe

; 1984 : 				{
; 1985 : 					vif1Regs->stat&= ~0x1F000000; // FQC=0

	and	eax, -520093697				; e0ffffffH

; 1986 : 					// One game doesnt like vif stalling at end, cant remember what. Spiderman isnt keen on it tho
; 1987 : 					vif1ch->chcr &= ~0x100;

	and	DWORD PTR [esi+36864], -257		; fffffeffH
	mov	DWORD PTR [esi+15360], eax

; 1988 : 					return;

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	jmp	$LN220@recEventTe
$LN197@recEventTe:

; 1989 : 				} 
; 1990 : 			
; 1991 : 			if(vif1ch->qwc > 0 || vif1.irqoffset > 0){

	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
	cmp	WORD PTR [eax+36896], 0
	ja	SHORT $LN195@recEventTe
	cmp	BYTE PTR ?vif1@@3UvifStruct@@A+36, 0
	jbe	SHORT $LN196@recEventTe
$LN195@recEventTe:

; 1992 : 				if(vif1.stallontag == 1) {

	cmp	BYTE PTR ?vif1@@3UvifStruct@@A+35, 1
	jne	SHORT $LN194@recEventTe
$LN190@recEventTe:

; 1993 : 					_chainVIF1();

	call	?_chainVIF1@@YAHXZ			; _chainVIF1
	jmp	SHORT $LN193@recEventTe
$LN194@recEventTe:

; 1994 : 					}
; 1995 : 				else _VIF1chain();//CPU_INT(13, vif1ch->qwc * BIAS);

	call	?_VIF1chain@@YAHXZ			; _VIF1chain
$LN193@recEventTe:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 677  : 	cpuRegs.interrupt|= 1 << n;

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vifdma.cpp

; 1996 : 				CPU_INT(1, g_vifCycles);

	mov	edx, DWORD PTR ?g_vifCycles@@3HA	; g_vifCycles
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 677  : 	cpuRegs.interrupt|= 1 << n;

	or	ecx, 2

; 678  : 	cpuRegs.sCycle[n] = cpuRegs.cycle;

	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960

; 679  : 	cpuRegs.eCycle[n] = ecycle;

	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+708, edx
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+836, ebx
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, ecx

; 680  : 
; 681  : 	// Interrupt is happening soon: make sure both EE and IOP are aware.
; 682  : 
; 683  : 	if( ecycle <= 28 && psxCycleEE > 0 )

	cmp	edx, 28					; 0000001cH
	jg	SHORT $LN204@recEventTe
	mov	eax, DWORD PTR ?psxCycleEE@@3HA		; psxCycleEE
	test	eax, eax
	jle	SHORT $LN204@recEventTe

; 684  : 	{
; 685  : 		// If running in the IOP, force it to break immediately into the EE.
; 686  : 		// the EE's branch test is due to run.
; 687  : 
; 688  : 		psxBreak += psxCycleEE;		// record the number of cycles the IOP didn't run.

	add	DWORD PTR ?psxBreak@@3HA, eax		; psxBreak

; 689  : 		psxCycleEE = 0;

	mov	DWORD PTR ?psxCycleEE@@3HA, 0		; psxCycleEE
$LN204@recEventTe:

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	eax, ebx
	cmp	eax, edx
	jle	$LN220@recEventTe

; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	eax, DWORD PTR [ebx+edx]
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vifdma.cpp

; 1997 : 				return;

	jmp	$LN478@recEventTe
$LN196@recEventTe:

; 1998 : 			}
; 1999 : 		}
; 2000 : 		
; 2001 : 		
; 2002 : 	//}
; 2003 : 	if((vif1ch->chcr & 0x100) == 0) SysPrintf("Vif1 running when CHCR == %x\n", vif1ch->chcr);

	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
	mov	eax, DWORD PTR [eax+36864]
	test	eax, 256				; 00000100H
	jne	SHORT $LN192@recEventTe
	push	eax
	push	OFFSET ??_C@_0BO@KFAMBPHK@Vif1?5running?5when?5CHCR?5?$DN?$DN?5?$CFx?6?$AA@
	call	?SysPrintf@@YAXPBDZZ			; SysPrintf
	add	esp, 8
$LN192@recEventTe:

; 2004 : 
; 2005 : 	
; 2006 : 	if ((vif1ch->chcr & 0x104) == 0x104 && vif1.done == 0) {

	mov	esi, DWORD PTR ?psH@@3PAEA		; psH
	mov	eax, DWORD PTR [esi+36864]
	and	eax, 260				; 00000104H
	cmp	eax, 260				; 00000104H
	jne	SHORT $LN191@recEventTe
	cmp	BYTE PTR ?vif1@@3UvifStruct@@A+33, 0
	jne	SHORT $LN191@recEventTe

; 2007 : 
; 2008 : 		if( !(psHu32(DMAC_CTRL) & 0x1) ) {

	test	BYTE PTR [esi+57344], 1
	jne	$LN190@recEventTe

; 2009 : 			SysPrintf("vif1 dma masked\n");

	push	OFFSET ??_C@_0BB@EELLKNKM@vif1?5dma?5masked?6?$AA@
	call	?SysPrintf@@YAXPBDZZ			; SysPrintf

; 2010 : 			return;

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
	add	esp, 4
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	jmp	$LN220@recEventTe
$LN191@recEventTe:

; 2011 : 		}
; 2012 : 
; 2013 : 		_chainVIF1();
; 2014 : 		CPU_INT(1, g_vifCycles);
; 2015 : 		
; 2016 : 		return;
; 2017 : 	}
; 2018 : #ifdef PCSX2_DEVBUILD
; 2019 : 	if(vif1ch->qwc > 0) SysPrintf("VIF1 Ending with %x QWC left\n");

	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
	cmp	WORD PTR [eax+36896], 0
	jbe	SHORT $LN189@recEventTe
	push	OFFSET ??_C@_0BO@OINNBNMI@VIF1?5Ending?5with?5?$CFx?5QWC?5left?6?$AA@
	call	?SysPrintf@@YAXPBDZZ			; SysPrintf
	add	esp, 4
$LN189@recEventTe:

; 2020 : 	if(vif1.cmd != 0) SysPrintf("vif1.cmd still set %x\n", vif1.cmd);

	mov	eax, DWORD PTR ?vif1@@3UvifStruct@@A+16
	test	eax, eax
	je	SHORT $LN188@recEventTe
	push	eax
	push	OFFSET ??_C@_0BH@OMPPLFGP@vif1?4cmd?5still?5set?5?$CFx?6?$AA@
	call	?SysPrintf@@YAXPBDZZ			; SysPrintf
	add	esp, 8
$LN188@recEventTe:

; 2021 : #endif
; 2022 : 
; 2023 : 	prevviftag = NULL;
; 2024 : 	prevvifcycles = 0;
; 2025 : 	vif1ch->chcr &= ~0x100;

	mov	eax, DWORD PTR ?psH@@3PAEA		; psH

; 2026 : 	hwDmacIrq(DMAC_VIF1);

	mov	ecx, edi
	mov	DWORD PTR _prevviftag, 0
	mov	DWORD PTR _prevvifcycles, 0
	and	DWORD PTR [eax+36864], -257		; fffffeffH
	call	?hwDmacIrq@@YAXH@Z			; hwDmacIrq

; 2027 : 	if(vif1Regs->mskpath3 == 0 || (vif1ch->chcr & 0x1) == 0x1)vif1Regs->stat&= ~0x1F000000; // FQC=0

	mov	esi, DWORD PTR ?psH@@3PAEA		; psH
	cmp	DWORD PTR [esi+15600], 0
	je	SHORT $LN186@recEventTe
	test	BYTE PTR [esi+36864], 1
	jne	SHORT $LN186@recEventTe
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 313  : 		g_nextBranchCycle = startCycle + delta;

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	jmp	SHORT $LN220@recEventTe
$LN186@recEventTe:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vifdma.cpp

; 2027 : 	if(vif1Regs->mskpath3 == 0 || (vif1ch->chcr & 0x1) == 0x1)vif1Regs->stat&= ~0x1F000000; // FQC=0

	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
	and	DWORD PTR [eax+15360], -520093697	; e0ffffffH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 356  : 	else

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	jmp	SHORT $LN220@recEventTe
$LN178@recEventTe:

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	eax, esi
	cmp	eax, edx
	jle	SHORT $LN220@recEventTe

; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	eax, DWORD PTR [esi+edx]
$LN478@recEventTe:
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
$LN220@recEventTe:

; 345  : }
; 346  : 
; 347  : static __forceinline void TESTINT( u8 n, void (*callback)() )
; 348  : {
; 349  : 	if( !(cpuRegs.interrupt & (1 << n)) ) return;

	test	cl, 4
	je	$LN462@recEventTe

; 332  : 	return (int)(cpuRegs.cycle - startCycle) >= delta;

	mov	esi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+840
	mov	eax, ebx
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+712
	sub	eax, esi
	cmp	eax, edx

; 350  : 
; 351  : 	if( cpuTestCycle( cpuRegs.sCycle[n], cpuRegs.eCycle[n] ) )

	jl	$LN224@recEventTe

; 344  : 	cpuRegs.interrupt &= ~(1 << i);

	and	ecx, -5					; fffffffbH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\gif.cpp

; 39   : 	GIF_LOG("gsInterrupt: %8.8x\n", cpuRegs.cycle);

	test	DWORD PTR ?varLog@@3IA, 4096		; varLog, 00001000H
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 344  : 	cpuRegs.interrupt &= ~(1 << i);

	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, ecx
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\gif.cpp

; 39   : 	GIF_LOG("gsInterrupt: %8.8x\n", cpuRegs.cycle);

	je	SHORT $LN239@recEventTe
	push	ebx
	push	OFFSET ??_C@_0BE@FPDFMCPK@gsInterrupt?3?5?$CF8?48x?6?$AA@
	call	?SrcLog_GIF@@YA_NPBDZZ			; SrcLog_GIF
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
	add	esp, 8
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
$LN239@recEventTe:

; 40   : 
; 41   : 	if((gif->chcr & 0x100) == 0){

	mov	esi, DWORD PTR ?psH@@3PAEA		; psH
	test	DWORD PTR [esi+40960], 256		; 00000100H
	je	$LN462@recEventTe

; 42   : 		//SysPrintf("Eh? why are you still interrupting! chcr %x, qwc %x, done = %x\n", gif->chcr, gif->qwc, done);
; 43   : 		return;
; 44   : 	}
; 45   : 	if(gif->qwc > 0 || gspath3done == 0) {

	cmp	WORD PTR [esi+40992], 0
	ja	SHORT $LN234@recEventTe
	cmp	DWORD PTR _gspath3done, 0
	jne	SHORT $LN232@recEventTe
$LN234@recEventTe:

; 46   : 		if( !(psHu32(DMAC_CTRL) & 0x1) ) {

	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
	test	BYTE PTR [eax+57344], 1
	jne	SHORT $LN233@recEventTe

; 47   : 			Console::Notice("gs dma masked, re-scheduling...");

	mov	ecx, OFFSET ??_C@_0CA@OMBBMBNE@gs?5dma?5masked?0?5re?9scheduling?4?4?4?$AA@
	call	?Notice@Console@@YA_NPBD@Z		; Console::Notice
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 677  : 	cpuRegs.interrupt|= 1 << n;

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964

; 678  : 	cpuRegs.sCycle[n] = cpuRegs.cycle;

	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	or	ecx, 4

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	eax, ebx

; 677  : 	cpuRegs.interrupt|= 1 << n;

	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, ecx

; 678  : 	cpuRegs.sCycle[n] = cpuRegs.cycle;

	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+840, ebx
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+712, 64 ; 00000040H

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	cmp	eax, 64					; 00000040H
	jle	$LN462@recEventTe

; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	eax, DWORD PTR [ebx+64]
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\gif.cpp

; 50   : 			return;

	jmp	$LN480@recEventTe
$LN233@recEventTe:

; 51   : 		}
; 52   : 
; 53   : 		GIFdma();

	call	?GIFdma@@YAXXZ				; GIFdma

; 54   : #ifdef GSPATH3FIX
; 55   : 		// re-reaise the IRQ as part of the mysterious Path3fix.
; 56   : 		// fixme - this hack *should* have the gs_irq raised from the VIF, I think.  It would be
; 57   : 		// more efficient and more correct.  (air)
; 58   : 		/*if (!(vif1Regs->mskpath3 && (vif1ch->chcr & 0x100)) || (psHu32(GIF_MODE) & 0x1))
; 59   : 			CPU_INT( 2, 64 );*/
; 60   : #endif
; 61   : 		if(gspath3done == 0) return;

	cmp	DWORD PTR _gspath3done, 0
	je	SHORT $LN463@recEventTe
$LN232@recEventTe:

; 62   : 	}
; 63   : 
; 64   : 	gspath3done = 0;
; 65   : 	gscycles = 0;
; 66   : 	Path3transfer = 0;
; 67   : 	gif->chcr &= ~0x100;

	mov	esi, DWORD PTR ?psH@@3PAEA		; psH
	mov	DWORD PTR _gspath3done, 0
	mov	DWORD PTR _gscycles, 0
	mov	DWORD PTR ?Path3transfer@@3HA, 0	; Path3transfer
	and	DWORD PTR [esi+40960], -257		; fffffeffH

; 68   : 	GSCSRr &= ~0xC000; //Clear FIFO stuff

	mov	ecx, DWORD PTR ?g_RealGSMem@@3PAEA+4096

; 69   : 	GSCSRr |= 0x4000;  //FIFO empty

	mov	eax, DWORD PTR ?g_RealGSMem@@3PAEA+4100
	and	ecx, -32769				; ffff7fffH
	or	ecx, 16384				; 00004000H
	mov	DWORD PTR ?g_RealGSMem@@3PAEA+4100, eax
	mov	DWORD PTR ?g_RealGSMem@@3PAEA+4096, ecx

; 70   : 	//psHu32(GIF_MODE)&= ~0x4;
; 71   : 	psHu32(GIF_STAT)&= ~0xE00; // OPH=0 | APATH=0
; 72   : 	psHu32(GIF_STAT)&= ~0x1F000000; // QFC=0
; 73   : 	hwDmacIrq(DMAC_GIF);

	mov	ecx, 2
	and	DWORD PTR [esi+12320], -520097281	; e0fff1ffH
	call	?hwDmacIrq@@YAXH@Z			; hwDmacIrq
$LN463@recEventTe:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 356  : 	else

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	jmp	SHORT $LN462@recEventTe
$LN224@recEventTe:

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	eax, esi
	cmp	eax, edx
	jle	SHORT $LN462@recEventTe

; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	eax, DWORD PTR [esi+edx]
$LN480@recEventTe:
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
$LN462@recEventTe:

; 345  : }
; 346  : 
; 347  : static __forceinline void TESTINT( u8 n, void (*callback)() )
; 348  : {
; 349  : 	if( !(cpuRegs.interrupt & (1 << n)) ) return;

	test	cl, 32					; 00000020H
	je	SHORT $LN262@recEventTe

; 332  : 	return (int)(cpuRegs.cycle - startCycle) >= delta;

	mov	esi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+852
	mov	eax, ebx
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+724
	sub	eax, esi
	cmp	eax, edx

; 350  : 
; 351  : 	if( cpuTestCycle( cpuRegs.sCycle[n], cpuRegs.eCycle[n] ) )

	jl	SHORT $LN252@recEventTe
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\sif.cpp

; 521  : 	sif0dma->chcr &= ~0x100;

	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 344  : 	cpuRegs.interrupt &= ~(1 << i);

	and	ecx, -33				; ffffffdfH
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, ecx
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\sif.cpp

; 522  : 	hwDmacIrq(DMAC_SIF0);

	mov	ecx, 5
	and	DWORD PTR [eax+49152], -257		; fffffeffH
	call	?hwDmacIrq@@YAXH@Z			; hwDmacIrq
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 356  : 	else

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	jmp	SHORT $LN262@recEventTe
$LN252@recEventTe:

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	eax, esi
	cmp	eax, edx
	jle	SHORT $LN262@recEventTe

; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	eax, DWORD PTR [esi+edx]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
$LN262@recEventTe:

; 345  : }
; 346  : 
; 347  : static __forceinline void TESTINT( u8 n, void (*callback)() )
; 348  : {
; 349  : 	if( !(cpuRegs.interrupt & (1 << n)) ) return;

	test	cl, 64					; 00000040H
	je	SHORT $LN276@recEventTe

; 332  : 	return (int)(cpuRegs.cycle - startCycle) >= delta;

	mov	esi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+856
	mov	eax, ebx
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+728
	sub	eax, esi
	cmp	eax, edx

; 350  : 
; 351  : 	if( cpuTestCycle( cpuRegs.sCycle[n], cpuRegs.eCycle[n] ) )

	jl	SHORT $LN266@recEventTe

; 344  : 	cpuRegs.interrupt &= ~(1 << i);

	and	ecx, -65				; ffffffbfH
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, ecx
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\sif.cpp

; 526  : 	hwDmacIrq(DMAC_SIF1);

	mov	ecx, 6
	call	?hwDmacIrq@@YAXH@Z			; hwDmacIrq

; 527  : 	sif1dma->chcr &= ~0x100;

	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
	and	DWORD PTR [eax+50176], -257		; fffffeffH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 356  : 	else

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	jmp	SHORT $LN276@recEventTe
$LN266@recEventTe:

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	eax, esi
	cmp	eax, edx
	jle	SHORT $LN276@recEventTe

; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	eax, DWORD PTR [esi+edx]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
$LN276@recEventTe:

; 357  : 		cpuSetNextBranch( cpuRegs.sCycle[n], cpuRegs.eCycle[n] );
; 358  : }
; 359  : 
; 360  : static __forceinline void _cpuTestInterrupts()
; 361  : {
; 362  : 	/* These are 'pcsx2 interrupts', they handle asynchronous stuff
; 363  : 	   that depends on the cycle timings */
; 364  : 
; 365  : 	TESTINT(1, vif1Interrupt);
; 366  : 	TESTINT(2, gsInterrupt);
; 367  : 	TESTINT(5, EEsif0Interrupt);
; 368  : 	TESTINT(6, EEsif1Interrupt);
; 369  : 
; 370  : 	// Profile-guided Optimization (sorta)
; 371  : 	// The following ints are rarely called.  Encasing them in a conditional
; 372  : 	// as follows helps speed up most games.
; 373  : 
; 374  : 	if( cpuRegs.interrupt & ( 1 | (3 << 3) | (3<<8) | (3<<10)) )

	test	ecx, 3865				; 00000f19H
	je	$LN371@recEventTe

; 345  : }
; 346  : 
; 347  : static __forceinline void TESTINT( u8 n, void (*callback)() )
; 348  : {
; 349  : 	if( !(cpuRegs.interrupt & (1 << n)) ) return;

	test	cl, 1
	je	SHORT $LN288@recEventTe

; 332  : 	return (int)(cpuRegs.cycle - startCycle) >= delta;

	mov	esi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+832
	mov	eax, ebx
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+704
	sub	eax, esi
	cmp	eax, edx

; 350  : 
; 351  : 	if( cpuTestCycle( cpuRegs.sCycle[n], cpuRegs.eCycle[n] ) )

	jl	SHORT $LN280@recEventTe

; 344  : 	cpuRegs.interrupt &= ~(1 << i);

	and	ecx, -2					; fffffffeH
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, ecx

; 352  : 	{
; 353  : 		cpuClearInt( n );
; 354  : 		callback();

	call	?vif0Interrupt@@YAXXZ			; vif0Interrupt

; 356  : 	else

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	jmp	SHORT $LN288@recEventTe
$LN280@recEventTe:

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	eax, esi
	cmp	eax, edx
	jle	SHORT $LN288@recEventTe

; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	eax, DWORD PTR [esi+edx]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
$LN288@recEventTe:

; 345  : }
; 346  : 
; 347  : static __forceinline void TESTINT( u8 n, void (*callback)() )
; 348  : {
; 349  : 	if( !(cpuRegs.interrupt & (1 << n)) ) return;

	test	cl, 8
	je	SHORT $LN300@recEventTe

; 332  : 	return (int)(cpuRegs.cycle - startCycle) >= delta;

	mov	esi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+844
	mov	eax, ebx
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+716
	sub	eax, esi
	cmp	eax, edx

; 350  : 
; 351  : 	if( cpuTestCycle( cpuRegs.sCycle[n], cpuRegs.eCycle[n] ) )

	jl	SHORT $LN292@recEventTe

; 344  : 	cpuRegs.interrupt &= ~(1 << i);

	and	ecx, -9					; fffffff7H
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, ecx

; 352  : 	{
; 353  : 		cpuClearInt( n );
; 354  : 		callback();

	call	?ipu0Interrupt@@YAXXZ			; ipu0Interrupt

; 356  : 	else

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	jmp	SHORT $LN300@recEventTe
$LN292@recEventTe:

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	eax, esi
	cmp	eax, edx
	jle	SHORT $LN300@recEventTe

; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	eax, DWORD PTR [esi+edx]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
$LN300@recEventTe:

; 345  : }
; 346  : 
; 347  : static __forceinline void TESTINT( u8 n, void (*callback)() )
; 348  : {
; 349  : 	if( !(cpuRegs.interrupt & (1 << n)) ) return;

	test	cl, 16					; 00000010H
	je	$LN320@recEventTe

; 332  : 	return (int)(cpuRegs.cycle - startCycle) >= delta;

	mov	esi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+848
	mov	eax, ebx
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+720
	sub	eax, esi
	cmp	eax, edx

; 350  : 
; 351  : 	if( cpuTestCycle( cpuRegs.sCycle[n], cpuRegs.eCycle[n] ) )

	jl	$LN304@recEventTe

; 344  : 	cpuRegs.interrupt &= ~(1 << i);

	and	ecx, -17				; ffffffefH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\ipu\ipu.cpp

; 1764 : 	IPU_LOG("ipu1Interrupt %x:\n", cpuRegs.cycle);

	test	DWORD PTR ?varLog@@3IA, 16384		; varLog, 00004000H
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 344  : 	cpuRegs.interrupt &= ~(1 << i);

	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, ecx
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\ipu\ipu.cpp

; 1764 : 	IPU_LOG("ipu1Interrupt %x:\n", cpuRegs.cycle);

	je	SHORT $LN317@recEventTe
	push	ebx
	push	OFFSET ??_C@_0BD@IOONBAFN@ipu1Interrupt?5?$CFx?3?6?$AA@
	call	?SrcLog_IPU@@YA_NPBDZZ			; SrcLog_IPU
	add	esp, 8
$LN317@recEventTe:

; 1765 : 
; 1766 : 	if( g_nDMATransfer & IPU_DMA_FIREINT1 ) {

	mov	eax, DWORD PTR _g_nDMATransfer
	test	al, 64					; 00000040H
	je	SHORT $LN314@recEventTe
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp

; 109  : 	psHu32(INTC_STAT)|= 1<<n;

	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
	or	DWORD PTR [eax+61440], 256		; 00000100H

; 110  : 	cpuTestINTCInts();

	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\ipu\ipu.cpp

; 1768 : 		g_nDMATransfer &= ~IPU_DMA_FIREINT1;

	mov	eax, DWORD PTR _g_nDMATransfer
	and	eax, -65				; ffffffbfH
	mov	DWORD PTR _g_nDMATransfer, eax
$LN314@recEventTe:

; 1769 : 	}
; 1770 : 
; 1771 : 	if( g_nDMATransfer & IPU_DMA_TIE1 ) {

	test	al, 4
	je	SHORT $LN313@recEventTe

; 1772 : 		g_nDMATransfer &= ~IPU_DMA_TIE1;

	and	eax, -5					; fffffffbH
	mov	DWORD PTR _g_nDMATransfer, eax

; 1773 : 	}else

	jmp	SHORT $LN312@recEventTe
$LN313@recEventTe:

; 1774 : 		ipu1dma->chcr &= ~0x100;

	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
	and	DWORD PTR [eax+46080], -257		; fffffeffH
$LN312@recEventTe:

; 1775 : 	
; 1776 : 	hwDmacIrq(DMAC_TO_IPU);

	mov	ecx, 4
	call	?hwDmacIrq@@YAXH@Z			; hwDmacIrq
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 356  : 	else

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	jmp	SHORT $LN320@recEventTe
$LN304@recEventTe:

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	eax, esi
	cmp	eax, edx
	jle	SHORT $LN320@recEventTe

; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	eax, DWORD PTR [esi+edx]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
$LN320@recEventTe:

; 345  : }
; 346  : 
; 347  : static __forceinline void TESTINT( u8 n, void (*callback)() )
; 348  : {
; 349  : 	if( !(cpuRegs.interrupt & (1 << n)) ) return;

	test	ecx, 256				; 00000100H
	je	SHORT $LN332@recEventTe

; 332  : 	return (int)(cpuRegs.cycle - startCycle) >= delta;

	mov	esi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+864
	mov	eax, ebx
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+736
	sub	eax, esi
	cmp	eax, edx

; 350  : 
; 351  : 	if( cpuTestCycle( cpuRegs.sCycle[n], cpuRegs.eCycle[n] ) )

	jl	SHORT $LN324@recEventTe

; 344  : 	cpuRegs.interrupt &= ~(1 << i);

	and	ecx, -257				; fffffeffH
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, ecx

; 352  : 	{
; 353  : 		cpuClearInt( n );
; 354  : 		callback();

	call	?SPRFROMinterrupt@@YAXXZ		; SPRFROMinterrupt

; 356  : 	else

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	jmp	SHORT $LN332@recEventTe
$LN324@recEventTe:

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	eax, esi
	cmp	eax, edx
	jle	SHORT $LN332@recEventTe

; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	eax, DWORD PTR [esi+edx]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
$LN332@recEventTe:

; 345  : }
; 346  : 
; 347  : static __forceinline void TESTINT( u8 n, void (*callback)() )
; 348  : {
; 349  : 	if( !(cpuRegs.interrupt & (1 << n)) ) return;

	test	ecx, 512				; 00000200H
	je	SHORT $LN347@recEventTe

; 332  : 	return (int)(cpuRegs.cycle - startCycle) >= delta;

	mov	esi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+868
	mov	eax, ebx
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+740
	sub	eax, esi
	cmp	eax, edx

; 350  : 
; 351  : 	if( cpuTestCycle( cpuRegs.sCycle[n], cpuRegs.eCycle[n] ) )

	jl	SHORT $LN336@recEventTe

; 344  : 	cpuRegs.interrupt &= ~(1 << i);

	and	ecx, -513				; fffffdffH
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, ecx
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\spr.cpp

; 448  : 	_dmaSPR1();

	call	?_dmaSPR1@@YAXXZ			; _dmaSPR1

; 449  : 	if( spr1finished == 0 ) return;

	cmp	DWORD PTR ?spr1finished@@3HA, 0		; spr1finished
	je	SHORT $LN465@recEventTe

; 450  : 	spr1->chcr &= ~0x100;

	mov	eax, DWORD PTR ?psH@@3PAEA		; psH

; 451  : 	hwDmacIrq(9);

	mov	ecx, 9
	and	DWORD PTR [eax+54272], -257		; fffffeffH
	call	?hwDmacIrq@@YAXH@Z			; hwDmacIrq
$LN465@recEventTe:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 356  : 	else

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	jmp	SHORT $LN347@recEventTe
$LN336@recEventTe:

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	eax, esi
	cmp	eax, edx
	jle	SHORT $LN347@recEventTe

; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	eax, DWORD PTR [esi+edx]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
$LN347@recEventTe:

; 345  : }
; 346  : 
; 347  : static __forceinline void TESTINT( u8 n, void (*callback)() )
; 348  : {
; 349  : 	if( !(cpuRegs.interrupt & (1 << n)) ) return;

	test	ecx, 1024				; 00000400H
	je	SHORT $LN359@recEventTe

; 332  : 	return (int)(cpuRegs.cycle - startCycle) >= delta;

	mov	esi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+872
	mov	eax, ebx
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+744
	sub	eax, esi
	cmp	eax, edx

; 350  : 
; 351  : 	if( cpuTestCycle( cpuRegs.sCycle[n], cpuRegs.eCycle[n] ) )

	jl	SHORT $LN351@recEventTe

; 344  : 	cpuRegs.interrupt &= ~(1 << i);

	and	ecx, -1025				; fffffbffH
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, ecx

; 352  : 	{
; 353  : 		cpuClearInt( n );
; 354  : 		callback();

	call	?vifMFIFOInterrupt@@YAXXZ		; vifMFIFOInterrupt

; 356  : 	else

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	jmp	SHORT $LN359@recEventTe
$LN351@recEventTe:

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	eax, esi
	cmp	eax, edx
	jle	SHORT $LN359@recEventTe

; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	eax, DWORD PTR [esi+edx]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
$LN359@recEventTe:

; 345  : }
; 346  : 
; 347  : static __forceinline void TESTINT( u8 n, void (*callback)() )
; 348  : {
; 349  : 	if( !(cpuRegs.interrupt & (1 << n)) ) return;

	test	ecx, 2048				; 00000800H
	je	SHORT $LN371@recEventTe

; 332  : 	return (int)(cpuRegs.cycle - startCycle) >= delta;

	mov	esi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+876
	sub	ebx, esi
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+748
	cmp	ebx, edx

; 350  : 
; 351  : 	if( cpuTestCycle( cpuRegs.sCycle[n], cpuRegs.eCycle[n] ) )

	jl	SHORT $LN363@recEventTe

; 344  : 	cpuRegs.interrupt &= ~(1 << i);

	and	ecx, -2049				; fffff7ffH
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, ecx

; 352  : 	{
; 353  : 		cpuClearInt( n );
; 354  : 		callback();

	call	?gifMFIFOInterrupt@@YAXXZ		; gifMFIFOInterrupt

; 356  : 	else

	jmp	SHORT $LN371@recEventTe
$LN363@recEventTe:

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	eax, esi
	cmp	eax, edx
	jle	SHORT $LN371@recEventTe

; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	eax, DWORD PTR [esi+edx]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
$LN371@recEventTe:

; 467  : 		_cpuTestInterrupts();
; 468  : 
; 469  : 	// ---- IOP -------------
; 470  : 	// * It's important to run a psxBranchTest before calling ExecuteBlock. This
; 471  : 	//   is because the IOP does not always perform branch tests before returning
; 472  : 	//   (during the prev branch) and also so it can act on the state the EE has
; 473  : 	//   given it before executing any code.
; 474  : 	//
; 475  : 	// * The IOP cannot always be run.  If we run IOP code every time through the
; 476  : 	//   cpuBranchTest, the IOP generally starts to run way ahead of the EE.
; 477  : 
; 478  : 	psxBranchTest();

	call	?psxBranchTest@@YAXXZ			; psxBranchTest

; 479  : 
; 480  : 	if( iopBranchAction )

	cmp	BYTE PTR ?iopBranchAction@@3_NA, 0	; iopBranchAction
	je	SHORT $LN466@recEventTe

; 481  : 	{
; 482  : 		//if( EEsCycle < -450 )
; 483  : 		//	Console::WriteLn( " IOP ahead by: %d cycles", params -EEsCycle );
; 484  : 
; 485  : 		// Experimental and Probably Unnecessry Logic -->
; 486  : 		// Check if the EE already has an exception pending, and if so we shouldn't
; 487  : 		// waste too much time updating the IOP.  Theory being that the EE and IOP should
; 488  : 		// run closely in sync during raised exception events.  But in practice it didn't
; 489  : 		// seem to make much of a difference.
; 490  : 
; 491  : 		// Note: The IOP is very good about chaining blocks together so it tends to
; 492  : 		// run lots of cycles, even with only 32 (4 IOP) cycles specified here.  That's
; 493  : 		// probably why it doesn't improve sync much.
; 494  : 
; 495  : 		/*bool eeExceptPending = cpuIntsEnabled() &&
; 496  : 			//( cpuRegs.CP0.n.Status.b.EIE && cpuRegs.CP0.n.Status.b.IE && (cpuRegs.CP0.n.Status.b.ERL == 0) ) &&
; 497  : 			//( (cpuRegs.CP0.n.Status.val & 0x10007) == 0x10001 ) &&
; 498  : 			( (cpuRegs.interrupt & (3<<30)) != 0 );
; 499  : 
; 500  : 		if( eeExceptPending )
; 501  : 		{
; 502  : 			// ExecuteBlock returns a negative value, so subtract it from the cycle count
; 503  : 			// specified to get the total cycles processed! :D
; 504  : 			int cycleCount = std::min( EEsCycle, (s32)(eeWaitCycles>>4) );
; 505  : 			int cyclesRun = cycleCount - psxCpu->ExecuteBlock( cycleCount );
; 506  : 			EEsCycle -= cyclesRun;
; 507  : 			//Console::Notice( "IOP Exception-Pending Execution -- EEsCycle: %d", params EEsCycle );
; 508  : 		}
; 509  : 		else*/
; 510  : 		{
; 511  : 			EEsCycle = psxCpu->ExecuteBlock( EEsCycle );

	mov	eax, DWORD PTR ?psxCpu@@3PAUR3000Acpu@@A ; psxCpu
	push	DWORD PTR ?EEsCycle@@3HA		; EEsCycle
	mov	eax, DWORD PTR [eax+12]
	call	eax
	add	esp, 4
	mov	DWORD PTR ?EEsCycle@@3HA, eax		; EEsCycle

; 512  : 		}
; 513  : 
; 514  : 		iopBranchAction = false;

	mov	BYTE PTR ?iopBranchAction@@3_NA, 0	; iopBranchAction
$LN466@recEventTe:

; 515  : 	}
; 516  : 
; 517  : 	// ---- VU0 -------------
; 518  : 
; 519  : 	if (VU0.VI[REG_VPU_STAT].UL & 0x1)

	test	BYTE PTR ?VU0@@3UVURegs@@A+976, 1
	je	SHORT $LN469@recEventTe

; 520  : 	{
; 521  : 		// We're in a BranchTest.  All dynarec registers are flushed
; 522  : 		// so there is no need to freeze registers here.
; 523  : 		CpuVU0.ExecuteBlock();

	call	DWORD PTR ?CpuVU0@@3UVUmicroCpu@@A+8

; 524  : 
; 525  : 		// This might be needed to keep the EE and VU0 in sync.
; 526  : 		// A better fix will require hefty changes to the VU recs. -_-
; 527  : 		if(VU0.VI[REG_VPU_STAT].UL & 0x1)

	test	BYTE PTR ?VU0@@3UVURegs@@A+976, 1

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	ecx, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960

; 524  : 
; 525  : 		// This might be needed to keep the EE and VU0 in sync.
; 526  : 		// A better fix will require hefty changes to the VU recs. -_-
; 527  : 		if(VU0.VI[REG_VPU_STAT].UL & 0x1)

	je	SHORT $LN376@recEventTe

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, ecx
	sub	eax, edx
	cmp	eax, 768				; 00000300H
	jle	SHORT $LN376@recEventTe

; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	ecx, DWORD PTR [edx+768]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
	jmp	SHORT $LN376@recEventTe
$LN469@recEventTe:
	mov	ecx, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
$LN376@recEventTe:

; 528  : 			cpuSetNextBranchDelta( 768 );
; 529  : 	}
; 530  : 
; 531  : 	// Note:  We don't update the VU1 here because it runs it's micro-programs in
; 532  : 	// one shot always.  That is, when a program is executed the VU1 doesn't even
; 533  : 	// bother to return until the program is completely finished.
; 534  : 
; 535  : 	// ---- Schedule Next Event Test --------------
; 536  : 
; 537  : 	if( EEsCycle > 192 )

	cmp	DWORD PTR ?EEsCycle@@3HA, 192		; EEsCycle, 000000c0H
	jle	SHORT $LN381@recEventTe

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, ecx
	sub	eax, edx
	cmp	eax, 48					; 00000030H
	jle	SHORT $LN381@recEventTe

; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	ecx, DWORD PTR [edx+48]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
$LN381@recEventTe:

; 538  : 	{
; 539  : 		// EE's running way ahead of the IOP still, so we should branch quickly to give the
; 540  : 		// IOP extra timeslices in short order.
; 541  : 
; 542  : 		cpuSetNextBranchDelta( 48 );
; 543  : 		//Console::Notice( "EE ahead of the IOP -- Rapid Branch!  %d", params EEsCycle );
; 544  : 	}
; 545  : 
; 546  : 	// The IOP could be running ahead/behind of us, so adjust the iop's next branch by its
; 547  : 	// relative position to the EE (via EEsCycle)
; 548  : 	cpuSetNextBranchDelta( ((g_psxNextBranchCycle-psxRegs.cycle)*8) - EEsCycle );

	mov	esi, DWORD PTR ?g_psxNextBranchCycle@@3IA ; g_psxNextBranchCycle

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, ecx

; 538  : 	{
; 539  : 		// EE's running way ahead of the IOP still, so we should branch quickly to give the
; 540  : 		// IOP extra timeslices in short order.
; 541  : 
; 542  : 		cpuSetNextBranchDelta( 48 );
; 543  : 		//Console::Notice( "EE ahead of the IOP -- Rapid Branch!  %d", params EEsCycle );
; 544  : 	}
; 545  : 
; 546  : 	// The IOP could be running ahead/behind of us, so adjust the iop's next branch by its
; 547  : 	// relative position to the EE (via EEsCycle)
; 548  : 	cpuSetNextBranchDelta( ((g_psxNextBranchCycle-psxRegs.cycle)*8) - EEsCycle );

	sub	esi, DWORD PTR ?psxRegs@@3UpsxRegisters@@A+528

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	sub	eax, edx

; 538  : 	{
; 539  : 		// EE's running way ahead of the IOP still, so we should branch quickly to give the
; 540  : 		// IOP extra timeslices in short order.
; 541  : 
; 542  : 		cpuSetNextBranchDelta( 48 );
; 543  : 		//Console::Notice( "EE ahead of the IOP -- Rapid Branch!  %d", params EEsCycle );
; 544  : 	}
; 545  : 
; 546  : 	// The IOP could be running ahead/behind of us, so adjust the iop's next branch by its
; 547  : 	// relative position to the EE (via EEsCycle)
; 548  : 	cpuSetNextBranchDelta( ((g_psxNextBranchCycle-psxRegs.cycle)*8) - EEsCycle );

	shl	esi, 3
	sub	esi, DWORD PTR ?EEsCycle@@3HA		; EEsCycle

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	cmp	eax, esi
	jle	SHORT $LN386@recEventTe

; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	ecx, DWORD PTR [edx+esi]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
$LN386@recEventTe:

; 549  : 
; 550  : 	// Apply the hsync counter's nextCycle
; 551  : 	cpuSetNextBranch( counters[4].sCycle, counters[4].CycleT );

	mov	edi, DWORD PTR ?counters@@3PAUCounter@@A+188

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, ecx

; 549  : 
; 550  : 	// Apply the hsync counter's nextCycle
; 551  : 	cpuSetNextBranch( counters[4].sCycle, counters[4].CycleT );

	mov	esi, DWORD PTR ?counters@@3PAUCounter@@A+192

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	sub	eax, edi
	cmp	eax, esi
	jle	SHORT $LN389@recEventTe

; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	ecx, DWORD PTR [edi+esi]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
$LN389@recEventTe:

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	esi, DWORD PTR ?nextsCounter@@3IA	; nextsCounter
	mov	eax, ecx
	mov	edi, DWORD PTR ?nextCounter@@3HA	; nextCounter
	sub	eax, esi
	cmp	eax, edi
	jle	SHORT $LN392@recEventTe

; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	ecx, DWORD PTR [esi+edi]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
$LN392@recEventTe:

; 421  : 	}
; 422  : }
; 423  : 
; 424  : // Checks the COP0.Status for exception enablings.
; 425  : // Exception handling for certain modes is *not* currently supported, this function filters
; 426  : // them out.  Exceptions while the exception handler is active (EIE), or exceptions of any
; 427  : // level other than 0 are ignored here.
; 428  : 
; 429  : static bool cpuIntsEnabled()
; 430  : {
; 431  : 	return cpuRegs.CP0.n.Status.b.EIE && cpuRegs.CP0.n.Status.b.IE && 
; 432  : 		!cpuRegs.CP0.n.Status.b.EXL && (cpuRegs.CP0.n.Status.b.ERL == 0);

	test	BYTE PTR ?cpuRegs@@3UcpuRegisters@@A+594, 1

; 552  : 
; 553  : 	// Apply vsync and other counter nextCycles
; 554  : 	cpuSetNextBranch( nextsCounter, nextCounter );
; 555  : 
; 556  : 	eeEventTestIsActive = false;

	mov	BYTE PTR ?eeEventTestIsActive@@3_NA, 0	; eeEventTestIsActive

; 421  : 	}
; 422  : }
; 423  : 
; 424  : // Checks the COP0.Status for exception enablings.
; 425  : // Exception handling for certain modes is *not* currently supported, this function filters
; 426  : // them out.  Exceptions while the exception handler is active (EIE), or exceptions of any
; 427  : // level other than 0 are ignored here.
; 428  : 
; 429  : static bool cpuIntsEnabled()
; 430  : {
; 431  : 	return cpuRegs.CP0.n.Status.b.EIE && cpuRegs.CP0.n.Status.b.IE && 
; 432  : 		!cpuRegs.CP0.n.Status.b.EXL && (cpuRegs.CP0.n.Status.b.ERL == 0);

	je	$LN435@recEventTe
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+592
	test	bl, 1
	je	$LN435@recEventTe
	test	bl, 6
	jne	$LN435@recEventTe

; 345  : }
; 346  : 
; 347  : static __forceinline void TESTINT( u8 n, void (*callback)() )
; 348  : {
; 349  : 	if( !(cpuRegs.interrupt & (1 << n)) ) return;

	mov	esi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
	test	esi, 1073741824				; 40000000H
	je	$LN470@recEventTe

; 332  : 	return (int)(cpuRegs.cycle - startCycle) >= delta;

	mov	edi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+824
	mov	eax, edx
	sub	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+952
	cmp	eax, edi

; 350  : 
; 351  : 	if( cpuTestCycle( cpuRegs.sCycle[n], cpuRegs.eCycle[n] ) )

	jl	$LN400@recEventTe

; 344  : 	cpuRegs.interrupt &= ~(1 << i);

	and	esi, -1073741825			; bfffffffH
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, esi
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp

; 76   : 	if ((cpuRegs.CP0.n.Status.val & 0x400) != 0x400) return;

	test	ebx, 1024				; 00000400H
	je	$LN470@recEventTe

; 77   : 
; 78   : 	if ((psHu32(INTC_STAT)) == 0) {

	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
	cmp	DWORD PTR [eax+61440], 0
	jne	SHORT $LN410@recEventTe

; 79   : 		DevCon::Notice("*PCSX2*: intcInterrupt already cleared");

	mov	ecx, OFFSET ??_C@_0CH@FCDDAIFJ@?$CKPCSX2?$CK?3?5intcInterrupt?5already?5c@
	call	?Notice@Console@@YA_NPBD@Z		; Console::Notice
$LN481@recEventTe:

; 80   :         return;

	mov	ecx, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	mov	esi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+592
	jmp	SHORT $LN470@recEventTe
$LN410@recEventTe:

; 81   : 	}
; 82   : 	if ((psHu32(INTC_STAT) & psHu32(INTC_MASK)) == 0) return;

	mov	edi, DWORD PTR [eax+61456]
	and	edi, DWORD PTR [eax+61440]
	je	SHORT $LN415@recEventTe

; 83   : 
; 84   : 	HW_LOG("intcInterrupt %x\n", psHu32(INTC_STAT) & psHu32(INTC_MASK));

	test	BYTE PTR ?varLog@@3IA, 4
	je	SHORT $LN414@recEventTe
	push	edi
	push	OFFSET ??_C@_0BC@LCGONOKJ@intcInterrupt?5?$CFx?6?$AA@
	call	?SrcLog_HW@@YA_NPBDZZ			; SrcLog_HW
	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
	add	esp, 8
$LN414@recEventTe:

; 85   : 	if(psHu32(INTC_STAT) & 0x2){

	test	BYTE PTR [eax+61440], 2
	je	SHORT $LN408@recEventTe

; 86   : 		counters[0].hold = rcntRcount(0);

	xor	ecx, ecx
	call	?rcntRcount@@YIIH@Z			; rcntRcount

; 87   : 		counters[1].hold = rcntRcount(1);

	mov	ecx, 1
	mov	DWORD PTR ?counters@@3PAUCounter@@A+12, eax
	call	?rcntRcount@@YIIH@Z			; rcntRcount
	mov	DWORD PTR ?counters@@3PAUCounter@@A+52, eax
$LN408@recEventTe:

; 88   : 	}
; 89   : 
; 90   : 	cpuException(0x400, cpuRegs.branch);

	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+968
	mov	ecx, 1024				; 00000400H
	call	?cpuException@@YAXII@Z			; cpuException
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 356  : 	else

	jmp	SHORT $LN481@recEventTe
$LN400@recEventTe:

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, ecx
	sub	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+952
	cmp	eax, edi
	jle	SHORT $LN470@recEventTe

; 313  : 		g_nextBranchCycle = startCycle + delta;

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+952
	add	ecx, edi
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
$LN470@recEventTe:
	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
$LN415@recEventTe:

; 345  : }
; 346  : 
; 347  : static __forceinline void TESTINT( u8 n, void (*callback)() )
; 348  : {
; 349  : 	if( !(cpuRegs.interrupt & (1 << n)) ) return;

	test	esi, esi
	jns	$LN435@recEventTe

; 332  : 	return (int)(cpuRegs.cycle - startCycle) >= delta;

	sub	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+956
	mov	edi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+828
	cmp	edx, edi

; 350  : 
; 351  : 	if( cpuTestCycle( cpuRegs.sCycle[n], cpuRegs.eCycle[n] ) )

	jl	$LN419@recEventTe

; 344  : 	cpuRegs.interrupt &= ~(1 << i);

	and	esi, 2147483647				; 7fffffffH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp

; 95   :     if ((cpuRegs.CP0.n.Status.val & 0x10807) != 0x10801) return;

	and	ebx, 67591				; 00010807H
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 344  : 	cpuRegs.interrupt &= ~(1 << i);

	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, esi
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp

; 95   :     if ((cpuRegs.CP0.n.Status.val & 0x10807) != 0x10801) return;

	cmp	ebx, 67585				; 00010801H
	jne	$LN435@recEventTe

; 96   : 
; 97   : 	if( ((psHu16(0xe012) & psHu16(0xe010)) == 0 ) && 
; 98   : 		( psHu16(0xe010) & 0x8000) == 0 ) return;

	movzx	ecx, WORD PTR [eax+57360]
	mov	dx, WORD PTR [eax+57362]
	and	dx, cx
	jne	SHORT $LN428@recEventTe
	test	ecx, 32768				; 00008000H
	je	SHORT $LN435@recEventTe
$LN428@recEventTe:

; 99   : 
; 100  : 	if((psHu32(DMAC_CTRL) & 0x1) == 0) return;

	test	BYTE PTR [eax+57344], 1
	je	SHORT $LN435@recEventTe

; 101  : 	
; 102  : 	HW_LOG("dmacInterrupt %x\n", (psHu16(0xe012) & psHu16(0xe010) || 
; 103  : 								  psHu16(0xe010) & 0x8000));

	test	BYTE PTR ?varLog@@3IA, 4
	je	SHORT $LN434@recEventTe
	test	dx, dx
	jne	SHORT $LN432@recEventTe
	test	ecx, 32768				; 00008000H
	jne	SHORT $LN432@recEventTe
	xor	eax, eax
	jmp	SHORT $LN433@recEventTe
$LN432@recEventTe:
	mov	eax, 1
$LN433@recEventTe:
	push	eax
	push	OFFSET ??_C@_0BC@IOCBKJEO@dmacInterrupt?5?$CFx?6?$AA@
	call	?SrcLog_HW@@YA_NPBDZZ			; SrcLog_HW
	add	esp, 8
$LN434@recEventTe:

; 104  : 
; 105  : 	cpuException(0x800, cpuRegs.branch);

	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+968
	mov	ecx, 2048				; 00000800H
	call	?cpuException@@YAXII@Z			; cpuException
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 653  : 	return retval;

	mov	al, BYTE PTR _vsyncEvent$1$[esp+60]

; 654  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 48					; 00000030H
	ret	0
$LN419@recEventTe:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+956
	sub	ecx, eax
	cmp	ecx, edi
	jle	SHORT $LN435@recEventTe

; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	ecx, DWORD PTR [eax+edi]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
$LN435@recEventTe:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 653  : 	return retval;

	mov	al, BYTE PTR _vsyncEvent$1$[esp+60]

; 654  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 48					; 00000030H
	ret	0
?recEventTest@@YA_NXZ ENDP				; recEventTest
_TEXT	ENDS
; Function compile flags: /Odtpy
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
_TEXT	SEGMENT
?Dispatcher@@YAXXZ PROC					; Dispatcher

; 667  : 	// EDX contains the jump addr to modify
; 668  : 	__asm push edx

	push	edx

; 669  : 
; 670  : 	// calc PC_GETBLOCK
; 671  : 	s_pDispatchBlock = PC_GETBLOCK(cpuRegs.pc);

	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+680
	shr	eax, 16					; 00000010H
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+680
	and	ecx, 65535				; 0000ffffH
	mov	edx, DWORD PTR ?recLUT@@3PAIA		; recLUT
	mov	eax, DWORD PTR [edx+eax*4]
	lea	ecx, DWORD PTR [eax+ecx*2]
	mov	DWORD PTR ?s_pDispatchBlock@@3PBUBASEBLOCK@@B, ecx ; s_pDispatchBlock

; 672  : 	
; 673  : 	if( s_pDispatchBlock->startpc != cpuRegs.pc )

	mov	edx, DWORD PTR ?s_pDispatchBlock@@3PBUBASEBLOCK@@B ; s_pDispatchBlock
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+680
	je	SHORT $LN1@Dispatcher

; 674  : 		recRecompile(cpuRegs.pc);

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+680
	push	ecx
	call	?recRecompile@@YAXI@Z			; recRecompile
	add	esp, 4
$LN1@Dispatcher:

; 675  : 
; 676  : 	__asm
; 677  : 	{
; 678  : 		mov eax, s_pDispatchBlock

	mov	eax, DWORD PTR ?s_pDispatchBlock@@3PBUBASEBLOCK@@B ; s_pDispatchBlock

; 679  : 		mov eax, dword ptr [eax]

	mov	eax, DWORD PTR [eax]

; 680  : 	}
; 681  : 
; 682  : #ifdef _DEBUG
; 683  : 	__asm mov g_EEDispatchTemp, eax
; 684  : 	assert( g_EEDispatchTemp );
; 685  : #endif
; 686  : 
; 687  : 	__asm {
; 688  : 		//and eax, 0x0fffffff
; 689  : 		shl eax, 4

	shl	eax, 4

; 690  : 		pop ecx // x86Ptr to mod

	pop	ecx

; 691  : 		mov edx, eax

	mov	edx, eax

; 692  : 		sub edx, ecx

	sub	edx, ecx

; 693  : 		sub edx, 4

	sub	edx, 4

; 694  : 		mov dword ptr [ecx], edx

	mov	DWORD PTR [ecx], edx

; 695  : 
; 696  : 		jmp eax

	jmp	eax
?Dispatcher@@YAXXZ ENDP					; Dispatcher
_TEXT	ENDS
; Function compile flags: /Odtpy
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
_TEXT	SEGMENT
?DispatcherClear@@YAXXZ PROC				; DispatcherClear

; 704  : 	// EDX contains the current pc
; 705  : 	__asm mov cpuRegs.pc, edx

	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+680, edx

; 706  : 	__asm push edx

	push	edx

; 707  : 
; 708  : 	// calc PC_GETBLOCK
; 709  : 	s_pDispatchBlock = PC_GETBLOCK(cpuRegs.pc);

	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+680
	shr	eax, 16					; 00000010H
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+680
	and	ecx, 65535				; 0000ffffH
	mov	edx, DWORD PTR ?recLUT@@3PAIA		; recLUT
	mov	eax, DWORD PTR [edx+eax*4]
	lea	ecx, DWORD PTR [eax+ecx*2]
	mov	DWORD PTR ?s_pDispatchBlock@@3PBUBASEBLOCK@@B, ecx ; s_pDispatchBlock

; 710  : 
; 711  : 	if( s_pDispatchBlock != NULL && s_pDispatchBlock->startpc == cpuRegs.pc )

	cmp	DWORD PTR ?s_pDispatchBlock@@3PBUBASEBLOCK@@B, 0 ; s_pDispatchBlock
	je	SHORT $LN1@Dispatcher
	mov	edx, DWORD PTR ?s_pDispatchBlock@@3PBUBASEBLOCK@@B ; s_pDispatchBlock
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+680
	jne	SHORT $LN1@Dispatcher

; 712  : 	{
; 713  : 		assert( s_pDispatchBlock->GetFnptr() != 0 );
; 714  : 
; 715  : 		// already modded the code, jump to the new place
; 716  : 		__asm {
; 717  : 			pop edx

	pop	edx

; 718  : 			mov eax, s_pDispatchBlock

	mov	eax, DWORD PTR ?s_pDispatchBlock@@3PBUBASEBLOCK@@B ; s_pDispatchBlock

; 719  : 			add esp, 4 // ignore stack

	add	esp, 4

; 720  : 			mov eax, dword ptr [eax]

	mov	eax, DWORD PTR [eax]

; 721  : 			//and eax, 0x0fffffff
; 722  : 			shl eax, 4

	shl	eax, 4

; 723  : 			jmp eax

	jmp	eax
$LN1@Dispatcher:

; 724  : 		}
; 725  : 	}
; 726  : 
; 727  : 	__asm {
; 728  : 		call recRecompile

	call	?recRecompile@@YAXI@Z			; recRecompile

; 729  : 		add esp, 4 // pop old param

	add	esp, 4

; 730  : 		mov eax, s_pDispatchBlock

	mov	eax, DWORD PTR ?s_pDispatchBlock@@3PBUBASEBLOCK@@B ; s_pDispatchBlock

; 731  : 		mov eax, dword ptr [eax]

	mov	eax, DWORD PTR [eax]

; 732  : 
; 733  : 		pop ecx // old fnptr

	pop	ecx

; 734  : 
; 735  : 		//and eax, 0x0fffffff
; 736  : 		shl eax, 4

	shl	eax, 4

; 737  : 		mov byte ptr [ecx], 0xe9 // jmp32

	mov	BYTE PTR [ecx], -23			; ffffffe9H

; 738  : 		mov edx, eax

	mov	edx, eax

; 739  : 		sub edx, ecx

	sub	edx, ecx

; 740  : 		sub edx, 5

	sub	edx, 5

; 741  : 		mov dword ptr [ecx+1], edx

	mov	DWORD PTR [ecx+1], edx

; 742  : 
; 743  : 		jmp eax

	jmp	eax
?DispatcherClear@@YAXXZ ENDP				; DispatcherClear
_TEXT	ENDS
; Function compile flags: /Odtpy
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
_TEXT	SEGMENT
?DispatcherReg@@YAXXZ PROC				; DispatcherReg

; 750  : 	s_pDispatchBlock = PC_GETBLOCK(cpuRegs.pc);

	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+680
	shr	eax, 16					; 00000010H
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+680
	and	ecx, 65535				; 0000ffffH
	mov	edx, DWORD PTR ?recLUT@@3PAIA		; recLUT
	mov	eax, DWORD PTR [edx+eax*4]
	lea	ecx, DWORD PTR [eax+ecx*2]
	mov	DWORD PTR ?s_pDispatchBlock@@3PBUBASEBLOCK@@B, ecx ; s_pDispatchBlock

; 751  : 
; 752  : 	if( s_pDispatchBlock->startpc != cpuRegs.pc )

	mov	edx, DWORD PTR ?s_pDispatchBlock@@3PBUBASEBLOCK@@B ; s_pDispatchBlock
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+680
	je	SHORT $LN1@Dispatcher

; 753  : 		recRecompile(cpuRegs.pc);

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+680
	push	ecx
	call	?recRecompile@@YAXI@Z			; recRecompile
	add	esp, 4
$LN1@Dispatcher:

; 754  : 
; 755  : 	__asm
; 756  : 	{
; 757  : 		mov eax, s_pDispatchBlock

	mov	eax, DWORD PTR ?s_pDispatchBlock@@3PBUBASEBLOCK@@B ; s_pDispatchBlock

; 758  : 		mov eax, dword ptr [eax]

	mov	eax, DWORD PTR [eax]

; 759  : 	}
; 760  : 
; 761  : #ifdef _DEBUG
; 762  : 	__asm mov g_EEDispatchTemp, eax
; 763  : 	assert( g_EEDispatchTemp );
; 764  : #endif
; 765  : 
; 766  : 	__asm {
; 767  : 		//and eax, 0x0fffffff
; 768  : 		shl eax, 4

	shl	eax, 4

; 769  : 		jmp eax

	jmp	eax
?DispatcherReg@@YAXXZ ENDP				; DispatcherReg
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\console.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\windows\winconsole.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\iopcounters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\windows\winthreads.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vumicromem.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vumicromem.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\iopcounters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\misc.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\misc.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\misc.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\windows\winthreads.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\misc.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\iopcounters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vifdma.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vifdma.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vifdma.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vifdma.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vifdma.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\gif.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\gif.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\gif.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\sif.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\sif.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\sif.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\sif.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\ipu\ipu.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\ipu\ipu.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\ipu\ipu.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\spr.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
_TEXT	SEGMENT
_count$1 = -36						; size = 8
_tmp$2 = -28						; size = 4
_count$3 = -24						; size = 8
_uExpectedEnd$1$ = -20					; size = 4
tv3170 = -20						; size = 4
_result$4 = -20						; size = 4
_sDeltaTime$5 = -16					; size = 8
_sDeltaTime$1$ = -12					; size = 4
_sDeltaTime$2$ = -8					; size = 4
tv3157 = -4						; size = 4
_i$1$ = -4						; size = 4
?recExecuteBlock@@YAXXZ PROC				; recExecuteBlock

; 799  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 800  : 	g_EEFreezeRegs = true;

	mov	BYTE PTR ?g_EEFreezeRegs@@3_NA, 1	; g_EEFreezeRegs
	push	ebx
	push	esi
	push	edi

; 801  : 	__asm
; 802  : 	{
; 803  : 		push ebx

	push	ebx

; 804  : 		push esi

	push	esi

; 805  : 		push edi

	push	edi

; 806  : 		push ebp

	push	ebp

; 807  : 
; 808  : 		call DispatcherReg

	call	?DispatcherReg@@YAXXZ			; DispatcherReg

; 809  : 
; 810  : 		pop ebp

	pop	ebp

; 811  : 		pop edi

	pop	edi

; 812  : 		pop esi

	pop	esi

; 813  : 		pop ebx

	pop	ebx

; 642  :     if( g_globalXMMSaved || g_globalMMXSaved)

	cmp	BYTE PTR ?g_globalXMMSaved@@3EA, 0	; g_globalXMMSaved
	mov	edi, 1

; 814  : 	}
; 815  : 	g_EEFreezeRegs = false;

	mov	BYTE PTR ?g_EEFreezeRegs@@3_NA, 0	; g_EEFreezeRegs

; 642  :     if( g_globalXMMSaved || g_globalMMXSaved)

	jne	SHORT $LN3@recExecute
	cmp	BYTE PTR ?g_globalMMXSaved@@3EA, 0	; g_globalMMXSaved
	je	SHORT $LN11@recExecute
$LN3@recExecute:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\console.cpp

; 97   : 		Write( color, fmt );

	mov	edx, OFFSET ??_C@_0DF@HHKJLMIF@Pcsx2?5Foopah?$CB?5?5Frozen?5regs?5have?5@
	mov	ecx, edi
	call	?Write@Console@@YA_NW4Colors@1@PBD@Z	; Console::Write
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\windows\winconsole.cpp

; 90   : 		if (hConsole != NULL)

	mov	eax, DWORD PTR _hConsole
	test	eax, eax
	je	SHORT $LN12@recExecute

; 91   : 		{
; 92   : 			DWORD tmp;
; 93   : 			WriteConsole(hConsole, "\r\n", 2, &tmp, 0);

	push	0
	lea	ecx, DWORD PTR _tmp$2[ebp]
	push	ecx
	push	2
	push	OFFSET ??_C@_02PCIJFNDE@?$AN?6?$AA@
	push	eax
	call	DWORD PTR __imp__WriteConsoleA@20
$LN12@recExecute:

; 94   : 		}
; 95   : 
; 96   : 		if (emuLog != NULL)

	mov	eax, DWORD PTR ?emuLog@@3PAU_iobuf@@A	; emuLog
	test	eax, eax
	je	SHORT $LN11@recExecute

; 97   : 		{
; 98   : 			fputs("\n", emuLog);

	push	eax
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	DWORD PTR __imp__fputs

; 99   : 			fflush( emuLog );

	push	DWORD PTR ?emuLog@@3PAU_iobuf@@A	; emuLog
	call	DWORD PTR __imp__fflush
	add	esp, 12					; 0000000cH
$LN11@recExecute:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 443  : 	g_nextBranchCycle = cpuRegs.cycle + eeWaitCycles;

	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	eax, DWORD PTR _eeWaitCycles

; 444  : 
; 445  : 	EEsCycle += cpuRegs.cycle - EEoCycle;

	mov	ecx, DWORD PTR ?EEsCycle@@3HA		; EEsCycle
	add	eax, edx
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
	mov	eax, edx
	sub	eax, DWORD PTR ?EEoCycle@@3IA		; EEoCycle
	add	ecx, eax
	mov	BYTE PTR ?eeEventTestIsActive@@3_NA, 1	; eeEventTestIsActive

; 447  : 
; 448  : 	if( EEsCycle > 0 )

	movzx	eax, BYTE PTR ?iopBranchAction@@3_NA	; iopBranchAction
	test	ecx, ecx
	mov	DWORD PTR ?EEsCycle@@3HA, ecx		; EEsCycle

; 332  : 	return (int)(cpuRegs.cycle - startCycle) >= delta;

	mov	ecx, DWORD PTR ?counters@@3PAUCounter@@A+188

; 447  : 
; 448  : 	if( EEsCycle > 0 )

	cmovg	eax, edi
	mov	BYTE PTR ?iopBranchAction@@3_NA, al	; iopBranchAction

; 332  : 	return (int)(cpuRegs.cycle - startCycle) >= delta;

	mov	eax, edx
	sub	eax, ecx

; 446  : 	EEoCycle = cpuRegs.cycle;

	mov	DWORD PTR ?EEoCycle@@3IA, edx		; EEoCycle

; 332  : 	return (int)(cpuRegs.cycle - startCycle) >= delta;

	cmp	eax, DWORD PTR ?counters@@3PAUCounter@@A+192
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp

; 471  : 	if( !cpuTestCycle( counters[4].sCycle, counters[4].CycleT ) ) return;

	jl	$LN459@recExecute

; 472  : 
; 473  : 	//iopBranchAction = 1;
; 474  : 	if (counters[4].modeval & MODE_HBLANK) { //HBLANK Start

	test	BYTE PTR ?counters@@3PAUCounter@@A+164, 1
	je	SHORT $LN30@recExecute

; 475  : 		rcntStartGate(false, counters[4].sCycle);

	mov	edx, ecx
	xor	cl, cl
	call	?rcntStartGate@@YIX_NI@Z		; rcntStartGate

; 476  : 		psxCheckStartGate16(0);

	xor	ecx, ecx
	call	?psxCheckStartGate16@@YAXH@Z		; psxCheckStartGate16

; 477  : 		
; 478  : 		// Setup the hRender's start and end cycle information:
; 479  : 		counters[4].sCycle += vSyncInfo.hBlank;		// start  (absolute cycle value)

	mov	eax, DWORD PTR _vSyncInfo+20
	add	DWORD PTR ?counters@@3PAUCounter@@A+188, eax

; 480  : 		counters[4].CycleT = vSyncInfo.hRender;		// endpoint (delta from start value)

	mov	eax, DWORD PTR _vSyncInfo+16

; 481  : 		counters[4].modeval = MODE_HRENDER;
; 482  : 	}
; 483  : 	else { //HBLANK END / HRENDER Begin

	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	DWORD PTR ?counters@@3PAUCounter@@A+164, 0
	jmp	$LN484@recExecute
$LN30@recExecute:

; 484  : 		if (CSRw & 0x4) GSCSRr |= 4; // signal

	test	BYTE PTR ?CSRw@@3IA, 4
	je	SHORT $LN28@recExecute
	mov	eax, DWORD PTR ?g_RealGSMem@@3PAEA+4100
	or	DWORD PTR ?g_RealGSMem@@3PAEA+4096, 4
	mov	DWORD PTR ?g_RealGSMem@@3PAEA+4100, eax
$LN28@recExecute:

; 485  : 		if (!(GSIMR&0x400)) gsIrq();

	test	DWORD PTR ?g_RealGSMem@@3PAEA+4112, 1024 ; 00000400H
	jne	SHORT $LN38@recExecute
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp

; 109  : 	psHu32(INTC_STAT)|= 1<<n;

	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
	or	DWORD PTR [eax+61440], edi

; 110  : 	cpuTestINTCInts();

	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	ecx, DWORD PTR ?counters@@3PAUCounter@@A+188
$LN38@recExecute:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp

; 486  : 		if (gates) rcntEndGate(false, counters[4].sCycle);

	cmp	DWORD PTR ?gates@@3HA, 0		; gates
	je	SHORT $LN26@recExecute
	mov	edx, ecx
	xor	cl, cl
	call	?rcntEndGate@@YIX_NI@Z			; rcntEndGate
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	ecx, DWORD PTR ?counters@@3PAUCounter@@A+188
$LN26@recExecute:

; 487  : 		if (psxhblankgate) psxCheckEndGate16(0);

	cmp	BYTE PTR ?psxhblankgate@@3EA, 0		; psxhblankgate
	je	SHORT $LN40@recExecute
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\iopcounters.cpp

; 330  : 	_psxCheckEndGate( i );

	xor	ecx, ecx
	call	?_psxCheckEndGate@@YAXH@Z		; _psxCheckEndGate
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	ecx, DWORD PTR ?counters@@3PAUCounter@@A+188
$LN40@recExecute:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp

; 490  : 		counters[4].sCycle += vSyncInfo.hRender;	// start (absolute cycle value)

	add	ecx, DWORD PTR _vSyncInfo+16

; 491  : 		counters[4].CycleT = vSyncInfo.hBlank;		// endpoint (delta from start value)

	mov	eax, DWORD PTR _vSyncInfo+20
	mov	DWORD PTR ?counters@@3PAUCounter@@A+188, ecx

; 492  : 		counters[4].modeval = MODE_HBLANK;

	mov	DWORD PTR ?counters@@3PAUCounter@@A+164, edi
$LN484@recExecute:

; 491  : 		counters[4].CycleT = vSyncInfo.hBlank;		// endpoint (delta from start value)

	mov	DWORD PTR ?counters@@3PAUCounter@@A+192, eax
$LN459@recExecute:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 332  : 	return (int)(cpuRegs.cycle - startCycle) >= delta;

	mov	eax, edx
	sub	eax, DWORD PTR ?nextsCounter@@3IA	; nextsCounter
	cmp	eax, DWORD PTR ?nextCounter@@3HA	; nextCounter

; 449  : 		iopBranchAction = true;
; 450  : 
; 451  : 	// ---- Counters -------------
; 452  : 	bool vsyncEvent = false;
; 453  : 	rcntUpdate_hScanline();
; 454  : 
; 455  : 	if( cpuTestCycle( nextsCounter, nextCounter ) )

	jl	$LN461@recExecute
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp

; 502  : 	s32 diff = (cpuRegs.cycle - counters[5].sCycle);

	mov	esi, DWORD PTR ?counters@@3PAUCounter@@A+228
	mov	eax, edx
	sub	eax, esi

; 503  : 	if( diff < counters[5].CycleT ) return false;

	cmp	eax, DWORD PTR ?counters@@3PAUCounter@@A+232
	jl	$LN56@recExecute

; 504  : 
; 505  : 	//iopBranchAction = 1;
; 506  : 	if (counters[5].modeval == MODE_VSYNC)

	cmp	DWORD PTR ?counters@@3PAUCounter@@A+204, 3
	jne	$LN54@recExecute

; 414  : 
; 415  : 	// INTC - VB Blank Start Hack --
; 416  : 	// Hack fix!  This corrects a freezeup in Granda 2 where it decides to spin
; 417  : 	// on the INTC_STAT register after the exception handler has already cleared
; 418  : 	// it.  But be warned!  Set the value to larger than 4 and it breaks Dark
; 419  : 	// Cloud and other games. -_-
; 420  : 
; 421  : 	// How it works: Normally the INTC raises exceptions immediately at the end of the
; 422  : 	// current branch test.  But in the case of Grandia 2, the game's code is spinning
; 423  : 	// on the INTC status, and the exception handler (for some reason?) clears the INTC
; 424  : 	// before returning *and* returns to a location other than EPC.  So the game never
; 425  : 	// gets to the point where it sees the INTC Irq set true.
; 426  : 
; 427  : 	// (I haven't investigated why Dark Cloud freezes on larger values)
; 428  : 	// (all testing done using the recompiler -- dunno how the ints respond yet)
; 429  : 
; 430  : 	//cpuRegs.eCycle[30] = 2;
; 431  : 
; 432  : 	// Should no longer be required (Refraction)
; 433  : }
; 434  : 
; 435  : static __forceinline void VSyncEnd(u32 sCycle)
; 436  : {
; 437  : 	EECNT_LOG( "/////////  EE COUNTER VSYNC END  \\\\\\\\\\\\\\\\\\\\  (frame: %d)\n", iFrame );

	test	DWORD PTR ?varLog@@3IA, 1073741824	; varLog, 40000000H
	je	SHORT $LN63@recExecute
	push	DWORD PTR _iFrame
	push	OFFSET ??_C@_0DK@GPMLIACH@?1?1?1?1?1?1?1?1?1?5?5EE?5COUNTER?5VSYNC?5END?5@
	call	?SrcLog_EECNT@@YA_NPBDZZ		; SrcLog_EECNT
	add	esp, 8
$LN63@recExecute:

; 438  : 
; 439  : 	iFrame++;

	inc	DWORD PTR _iFrame

; 440  : 
; 441  : 	if( g_vu1SkipCount > 0 )

	cmp	DWORD PTR ?g_vu1SkipCount@@3IA, 0	; g_vu1SkipCount
	jbe	SHORT $LN60@recExecute

; 442  : 	{
; 443  : 		gsPostVsyncEnd( false );

	xor	cl, cl
	call	?gsPostVsyncEnd@@YAX_N@Z		; gsPostVsyncEnd
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\windows\winthreads.cpp

; 119  : 				mov          ecx,dword ptr [target]

	mov	ecx, OFFSET ?g_vu1SkipCount@@3IA	; g_vu1SkipCount

; 120  : 				mov          eax,dword ptr [srcval]

	mov	eax, -1

; 121  : 				lock xadd    dword ptr [ecx],eax

	lock	 xadd	 DWORD PTR [ecx], eax

; 122  : 				mov          dword ptr [result], eax

	mov	DWORD PTR _result$4[ebp], eax
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vumicromem.cpp

; 43   : 	CpuVU1.ExecuteBlock = DummyExecuteVU1Block;

	mov	DWORD PTR ?CpuVU1@@3UVUmicroCpu@@A+8, OFFSET ?DummyExecuteVU1Block@@YAXXZ ; DummyExecuteVU1Block
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp

; 447  : 	else

	jmp	SHORT $LN75@recExecute
$LN60@recExecute:

; 448  : 	{
; 449  : 		gsPostVsyncEnd( true );

	mov	cl, 1
	call	?gsPostVsyncEnd@@YAX_N@Z		; gsPostVsyncEnd
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vumicromem.cpp

; 48   : 	CpuVU1.ExecuteBlock = CHECK_VU1REC ? recVU1.ExecuteBlock : intVU1.ExecuteBlock;

	test	BYTE PTR ?g_Session@@3USessionOverrideFlags@@A, 4 ; g_Session
	jne	SHORT $LN74@recExecute
	test	BYTE PTR ?Config@@3UPcsxConfig@@A+3576, 64 ; 00000040H
	mov	eax, DWORD PTR ?recVU1@@3UVUmicroCpu@@B+8
	jne	SHORT $LN485@recExecute
$LN74@recExecute:
	mov	eax, DWORD PTR ?intVU1@@3UVUmicroCpu@@B+8
$LN485@recExecute:
	mov	DWORD PTR ?CpuVU1@@3UVUmicroCpu@@A+8, eax
$LN75@recExecute:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp

; 109  : 	psHu32(INTC_STAT)|= 1<<n;

	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
	or	DWORD PTR [eax+61440], 8

; 110  : 	cpuTestINTCInts();

	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\iopcounters.cpp

; 357  : 	psxHu32(0x1070) |= 0x800;

	mov	eax, DWORD PTR ?psxH@@3PAEA		; psxH
	or	DWORD PTR [eax+4208], 2048		; 00000800H

; 358  : 	if(psxvblankgate & (1 << 1)) psxCheckEndGate16(1);

	mov	al, BYTE PTR ?psxvblankgate@@3EA	; psxvblankgate
	test	al, 2
	je	SHORT $LN82@recExecute

; 330  : 	_psxCheckEndGate( i );

	mov	ecx, edi
	call	?_psxCheckEndGate@@YAXH@Z		; _psxCheckEndGate
	mov	al, BYTE PTR ?psxvblankgate@@3EA	; psxvblankgate
$LN82@recExecute:

; 359  : 	if(psxvblankgate & (1 << 3)) psxCheckEndGate32(3);

	test	al, 8
	je	SHORT $LN84@recExecute

; 338  : }
; 339  : 
; 340  : static void psxCheckEndGate32(int i)
; 341  : {
; 342  : 	assert(i == 3);
; 343  : 	_psxCheckEndGate( i );

	mov	ecx, 3
	call	?_psxCheckEndGate@@YAXH@Z		; _psxCheckEndGate
$LN84@recExecute:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp

; 455  : 	if (gates) rcntEndGate(true, sCycle); // Counters End Gate Code

	cmp	DWORD PTR ?gates@@3HA, 0		; gates
	je	SHORT $LN58@recExecute
	mov	edx, esi
	mov	cl, 1
	call	?rcntEndGate@@YIX_NI@Z			; rcntEndGate
$LN58@recExecute:

; 111  : }
; 112  : 
; 113  : void rcntInit() {
; 114  : 	int i;
; 115  : 
; 116  : 	memzero_obj(counters);
; 117  : 
; 118  : 	for (i=0; i<4; i++) {
; 119  : 		counters[i].rate = 2;
; 120  : 		counters[i].target = 0xffff;
; 121  : 	}
; 122  : 	counters[0].interrupt =  9;
; 123  : 	counters[1].interrupt = 10;
; 124  : 	counters[2].interrupt = 11;
; 125  : 	counters[3].interrupt = 12;
; 126  : 
; 127  : 	counters[4].modeval = MODE_HRENDER;
; 128  : 	counters[4].sCycle = cpuRegs.cycle;
; 129  : 	counters[5].modeval = MODE_VRENDER; 
; 130  : 	counters[5].sCycle = cpuRegs.cycle;
; 131  : 
; 132  : 	UpdateVSyncRate();
; 133  : 
; 134  : 	for (i=0; i<4; i++) rcntReset(i);
; 135  : 	cpuRcntSet();
; 136  : }
; 137  : 
; 138  : // debug code, used for stats
; 139  : int g_nCounters[4];
; 140  : static int iFrame = 0;	
; 141  : 
; 142  : #ifndef _WIN32
; 143  : #include <sys/time.h>
; 144  : #endif
; 145  : 
; 146  : static s64 m_iTicks=0;
; 147  : static u64 m_iStart=0;
; 148  : 
; 149  : struct vSyncTimingInfo
; 150  : {
; 151  : 	u32 Framerate;			// frames per second * 100 (so 2500 for PAL and 2997 for NTSC)
; 152  : 	u32 Render;				// time from vblank end to vblank start (cycles)
; 153  : 	u32 Blank;				// time from vblank start to vblank end (cycles)
; 154  : 
; 155  : 	u32 hSyncError;			// rounding error after the duration of a rendered frame (cycles)
; 156  : 	u32 hRender;			// time from hblank end to hblank start (cycles)
; 157  : 	u32 hBlank;				// time from hblank start to hblank end (cycles)
; 158  : 	u32 hScanlinesPerFrame;	// number of scanlines per frame (525/625 for NTSC/PAL)
; 159  : };
; 160  : 
; 161  : 
; 162  : static vSyncTimingInfo vSyncInfo;
; 163  : 
; 164  : 
; 165  : static __forceinline void vSyncInfoCalc( vSyncTimingInfo* info, u32 framesPerSecond, u32 scansPerFrame )
; 166  : {
; 167  : 	// Important: Cannot use floats or doubles here.  The emulator changes rounding modes
; 168  : 	// depending on user-set speedhack options, and it can break float/double code
; 169  : 	// (as in returning infinities and junk)
; 170  : 
; 171  : 	// NOTE: mgs3 likes a /4 vsync, but many games prefer /2.  This seems to indicate a
; 172  : 	// problem in the counters vsync gates somewhere.
; 173  : 
; 174  : 	u64 Frame = ((u64)PS2CLK * 1000000ULL) / framesPerSecond;
; 175  : 	u64 HalfFrame = Frame / 2;
; 176  : 	u64 Blank = HalfFrame / 2;		// two blanks and renders per frame
; 177  : 	u64 Render = HalfFrame - Blank;	// so use the half-frame value for these...
; 178  : 
; 179  : 	// Important!  The hRender/hBlank timers should be 50/50 for best results.
; 180  : 	// In theory a 70%/30% ratio would be more correct but in practice it runs
; 181  : 	// like crap and totally screws audio synchronization and other things.
; 182  : 	
; 183  : 	u64 Scanline = Frame / scansPerFrame;
; 184  : 	u64 hBlank = Scanline / 2;
; 185  : 	u64 hRender = Scanline - hBlank;
; 186  : 	
; 187  : 	info->Framerate = framesPerSecond;
; 188  : 	info->Render = (u32)(Render/10000);
; 189  : 	info->Blank  = (u32)(Blank/10000);
; 190  : 
; 191  : 	info->hRender = (u32)(hRender/10000);
; 192  : 	info->hBlank  = (u32)(hBlank/10000);
; 193  : 	info->hScanlinesPerFrame = scansPerFrame;
; 194  : 	
; 195  : 	// Apply rounding:
; 196  : 	if( ( Render - info->Render ) >= 5000 ) info->Render++;
; 197  : 	else if( ( Blank - info->Blank ) >= 5000 ) info->Blank++;
; 198  : 
; 199  : 	if( ( hRender - info->hRender ) >= 5000 ) info->hRender++;
; 200  : 	else if( ( hBlank - info->hBlank ) >= 5000 ) info->hBlank++;
; 201  : 	
; 202  : 	// Calculate accumulative hSync rounding error per half-frame:
; 203  : 	{
; 204  : 	u32 hSyncCycles = ((info->hRender + info->hBlank) * scansPerFrame) / 2;
; 205  : 	u32 vSyncCycles = (info->Render + info->Blank);
; 206  : 	info->hSyncError = vSyncCycles - hSyncCycles;
; 207  : 	}
; 208  : 
; 209  : 	// Note: In NTSC modes there is some small rounding error in the vsync too,
; 210  : 	// however it would take thousands of frames for it to amount to anything and
; 211  : 	// is thus not worth the effort at this time.
; 212  : }
; 213  : 
; 214  : 
; 215  : u32 UpdateVSyncRate()
; 216  : {
; 217  : 	const char *limiterMsg = "Framelimiter rate updated (UpdateVSyncRate): %d.%d fps";
; 218  : 
; 219  : 	// fixme - According to some docs, progressive-scan modes actually refresh slower than
; 220  : 	// interlaced modes.  But I can't fathom how, since the refresh rate is a function of
; 221  : 	// the television and all the docs I found on TVs made no indication that they ever
; 222  : 	// run anything except their native refresh rate.
; 223  : 
; 224  : 	//#define VBLANK_NTSC			((Config.PsxType & 2) ? 59.94 : 59.82) //59.94 is more precise
; 225  : 	//#define VBLANK_PAL			((Config.PsxType & 2) ? 50.00 : 49.76)
; 226  : 
; 227  : 	if(Config.PsxType & 1)
; 228  : 	{
; 229  : 		if( vSyncInfo.Framerate != FRAMERATE_PAL )
; 230  : 			vSyncInfoCalc( &vSyncInfo, FRAMERATE_PAL, SCANLINES_TOTAL_PAL );
; 231  : 	}
; 232  : 	else
; 233  : 	{
; 234  : 		if( vSyncInfo.Framerate != FRAMERATE_NTSC )
; 235  : 			vSyncInfoCalc( &vSyncInfo, FRAMERATE_NTSC, SCANLINES_TOTAL_NTSC );
; 236  : 	}
; 237  : 
; 238  : 	counters[4].CycleT = vSyncInfo.hRender; // Amount of cycles before the counter will be updated
; 239  : 	counters[5].CycleT = vSyncInfo.Render; // Amount of cycles before the counter will be updated
; 240  : 
; 241  : 	if (Config.CustomFps > 0)
; 242  : 	{
; 243  : 		s64 ticks = GetTickFrequency() / Config.CustomFps;
; 244  : 		if( m_iTicks != ticks )
; 245  : 		{
; 246  : 			m_iTicks = ticks;
; 247  : 			gsOnModeChanged( vSyncInfo.Framerate, m_iTicks );
; 248  : 			Console::Status( limiterMsg, params Config.CustomFps, 0 );
; 249  : 		}
; 250  : 	}
; 251  : 	else
; 252  : 	{
; 253  : 		s64 ticks = (GetTickFrequency() * 50) / vSyncInfo.Framerate;
; 254  : 		if( m_iTicks != ticks )
; 255  : 		{
; 256  : 			m_iTicks = ticks;
; 257  : 			gsOnModeChanged( vSyncInfo.Framerate, m_iTicks );
; 258  : 			Console::Status( limiterMsg, params vSyncInfo.Framerate/50, (vSyncInfo.Framerate*2)%100 );
; 259  : 		}
; 260  : 	}
; 261  : 
; 262  : 	m_iStart = GetCPUTicks();
; 263  : 	cpuRcntSet();
; 264  : 
; 265  : 	// Initialize VU Skip Stuff...
; 266  : 	g_vu1SkipCount = 0;
; 267  : 
; 268  : 	return (u32)m_iTicks;
; 269  : }
; 270  : 
; 271  : extern u32 vu0time;
; 272  : 
; 273  : 
; 274  : void vSyncDebugStuff() {
; 275  : 
; 276  : #ifdef PCSX2_DEVBUILD
; 277  : 		if( g_TestRun.enabled && g_TestRun.frame > 0 ) {
; 278  : 			if( iFrame > g_TestRun.frame ) {
; 279  : 				// take a snapshot
; 280  : 				if( g_TestRun.pimagename != NULL && GSmakeSnapshot2 != NULL ) {
; 281  : 					if( g_TestRun.snapdone ) {
; 282  : 						g_TestRun.curimage++;
; 283  : 						g_TestRun.snapdone = 0;
; 284  : 						g_TestRun.frame += 20;
; 285  : 						if( g_TestRun.curimage >= g_TestRun.numimages ) {
; 286  : 							// exit
; 287  : 							SysClose();
; 288  : 							exit(0);
; 289  : 						}
; 290  : 					}
; 291  : 					else {
; 292  : 						// query for the image
; 293  : 						GSmakeSnapshot2(g_TestRun.pimagename, &g_TestRun.snapdone, g_TestRun.jpgcapture);
; 294  : 					}
; 295  : 				}
; 296  : 				else {
; 297  : 					// exit
; 298  : 					SysClose();
; 299  : 					exit(0);
; 300  : 				}
; 301  : 			}
; 302  : 		}
; 303  : 
; 304  : 		GSVSYNC();
; 305  : 
; 306  : 		if( g_SaveGSStream == 1 ) {
; 307  : 			freezeData fP;
; 308  : 
; 309  : 			g_SaveGSStream = 2;
; 310  : 			g_fGSSave->gsFreeze();
; 311  : 			
; 312  : 			if (GSfreeze(FREEZE_SIZE, &fP) == -1) {
; 313  : 				safe_delete( g_fGSSave );
; 314  : 				g_SaveGSStream = 0;
; 315  : 			}
; 316  : 			else {
; 317  : 				fP.data = (s8*)malloc(fP.size);
; 318  : 				if (fP.data == NULL) {
; 319  : 					safe_delete( g_fGSSave );
; 320  : 					g_SaveGSStream = 0;
; 321  : 				}
; 322  : 				else {
; 323  : 					if (GSfreeze(FREEZE_SAVE, &fP) == -1) {
; 324  : 						safe_delete( g_fGSSave );
; 325  : 						g_SaveGSStream = 0;
; 326  : 					}
; 327  : 					else {
; 328  : 						g_fGSSave->Freeze( fP.size );
; 329  : 						if (fP.size) {
; 330  : 							g_fGSSave->FreezeMem( fP.data, fP.size );
; 331  : 							free(fP.data);
; 332  : 						}
; 333  : 					}
; 334  : 				}
; 335  : 			}
; 336  : 		}
; 337  : 		else if( g_SaveGSStream == 2 ) {
; 338  : 			
; 339  : 			if( --g_nLeftGSFrames <= 0 ) {
; 340  : 				safe_delete( g_fGSSave );
; 341  : 				g_SaveGSStream = 0;
; 342  : 				Console::WriteLn("Done saving GS stream");
; 343  : 			}
; 344  : 		}
; 345  : #endif
; 346  : }
; 347  : 
; 348  : void frameLimitReset()
; 349  : {
; 350  : 	m_iStart = GetCPUTicks();
; 351  : }
; 352  : 
; 353  : // Framelimiter - Measures the delta time between calls and stalls until a
; 354  : // certain amount of time passes if such time hasn't passed yet.
; 355  : // See the GS FrameSkip function for details on why this is here and not in the GS.
; 356  : static __forceinline void frameLimit()
; 357  : {
; 358  : 	s64 sDeltaTime;
; 359  : 	u64 uExpectedEnd;
; 360  : 	u64 iEnd;
; 361  : 
; 362  : 	if( CHECK_FRAMELIMIT == PCSX2_FRAMELIMIT_NORMAL ) return;

	test	DWORD PTR ?Config@@3UPcsxConfig@@A+3576, 3072 ; 00000c00H
	je	$LN460@recExecute

; 363  : 	if( Config.CustomFps >= 999 ) return;	// means the user would rather just have framelimiting turned off...

	cmp	DWORD PTR ?Config@@3UPcsxConfig@@A+3604, 999 ; 000003e7H
	jge	$LN460@recExecute

; 365  : 	uExpectedEnd = m_iStart + m_iTicks;

	mov	esi, DWORD PTR _m_iTicks
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\misc.cpp

; 825  :     QueryPerformanceCounter(&count);

	lea	eax, DWORD PTR _count$1[ebp]
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp

; 365  : 	uExpectedEnd = m_iStart + m_iTicks;

	add	esi, DWORD PTR _m_iStart
	mov	edi, DWORD PTR _m_iTicks+4
	adc	edi, DWORD PTR _m_iStart+4
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\misc.cpp

; 825  :     QueryPerformanceCounter(&count);

	push	eax
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp

; 365  : 	uExpectedEnd = m_iStart + m_iTicks;

	mov	DWORD PTR _uExpectedEnd$1$[ebp], esi
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\misc.cpp

; 825  :     QueryPerformanceCounter(&count);

	call	DWORD PTR __imp__QueryPerformanceCounter@4
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp

; 368  : 	sDeltaTime = iEnd - uExpectedEnd;

	mov	ecx, DWORD PTR _count$1[ebp]
	mov	eax, ecx
	mov	edx, DWORD PTR _count$1[ebp+4]
	sub	eax, esi

; 369  : 
; 370  : 	// If the framerate drops too low, reset the expected value.  This avoids
; 371  : 	// excessive amounts of "fast forward" syndrome which would occur if we
; 372  : 	// tried to catch up too much.
; 373  : 	
; 374  : 	if( sDeltaTime > m_iTicks*8 )

	mov	esi, DWORD PTR _m_iTicks
	mov	DWORD PTR _sDeltaTime$2$[ebp], eax
	mov	eax, edx
	sbb	eax, edi
	mov	DWORD PTR _sDeltaTime$1$[ebp], eax
	mov	eax, DWORD PTR _m_iTicks+4
	shld	eax, esi, 3
	shl	esi, 3
	mov	DWORD PTR tv3157[ebp], esi
	mov	esi, DWORD PTR _uExpectedEnd$1$[ebp]
	cmp	DWORD PTR _sDeltaTime$1$[ebp], eax
	jl	SHORT $LN483@recExecute
	jg	SHORT $LN453@recExecute
	mov	eax, DWORD PTR _sDeltaTime$2$[ebp]
	cmp	eax, DWORD PTR tv3157[ebp]
	jbe	SHORT $LN88@recExecute
$LN453@recExecute:

; 375  : 	{
; 376  : 		m_iStart = iEnd - m_iTicks;

	sub	ecx, DWORD PTR _m_iTicks
	mov	DWORD PTR _m_iStart, ecx
	sbb	edx, DWORD PTR _m_iTicks+4

; 377  : 
; 378  : 		// Let the GS Skipper know we lost time.
; 379  : 		// Keeps the GS skipper from trying to catch up to a framerate
; 380  : 		// that the limiter already gave up on.
; 381  : 
; 382  : 		gsSyncLimiterLostTime( (s32)(m_iStart - uExpectedEnd) );

	sub	ecx, esi
	mov	DWORD PTR _m_iStart+4, edx
	call	?gsSyncLimiterLostTime@@YAXH@Z		; gsSyncLimiterLostTime

; 383  : 		return;

	jmp	SHORT $LN460@recExecute
$LN483@recExecute:
	mov	eax, DWORD PTR _sDeltaTime$2$[ebp]
$LN88@recExecute:

; 384  : 	}
; 385  : 
; 386  : 	// use the expected frame completion time as our starting point.
; 387  : 	// improves smoothness by making the framelimiter more adaptive to the
; 388  : 	// imperfect TIMESLICE() wait, and allows it to speed up a wee bit after
; 389  : 	// slow frames to "catch up."
; 390  : 
; 391  : 	m_iStart = uExpectedEnd;
; 392  : 
; 393  : 	while( sDeltaTime < 0 )

	cmp	DWORD PTR _sDeltaTime$1$[ebp], 0
	mov	DWORD PTR _m_iStart, esi
	mov	DWORD PTR _m_iStart+4, edi
	jg	SHORT $LN460@recExecute
	jl	SHORT $LL87@recExecute
	test	eax, eax
	jae	SHORT $LN460@recExecute
	npad	4
$LL87@recExecute:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\windows\winthreads.cpp

; 61   : 		Sleep(0);

	push	0
	call	DWORD PTR __imp__Sleep@4
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\misc.cpp

; 825  :     QueryPerformanceCounter(&count);

	lea	eax, DWORD PTR _count$3[ebp]
	push	eax
	call	DWORD PTR __imp__QueryPerformanceCounter@4
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp

; 397  : 		sDeltaTime = iEnd - uExpectedEnd;

	mov	ecx, DWORD PTR _count$3[ebp]
	mov	eax, DWORD PTR _count$3[ebp+4]
	sub	ecx, esi
	sbb	eax, edi
	mov	DWORD PTR _sDeltaTime$5[ebp+4], eax
	js	SHORT $LL87@recExecute

; 384  : 	}
; 385  : 
; 386  : 	// use the expected frame completion time as our starting point.
; 387  : 	// improves smoothness by making the framelimiter more adaptive to the
; 388  : 	// imperfect TIMESLICE() wait, and allows it to speed up a wee bit after
; 389  : 	// slow frames to "catch up."
; 390  : 
; 391  : 	m_iStart = uExpectedEnd;
; 392  : 
; 393  : 	while( sDeltaTime < 0 )

	jg	SHORT $LN460@recExecute
	test	ecx, ecx
	jb	SHORT $LL87@recExecute
$LN460@recExecute:

; 507  : 	{
; 508  : 		VSyncEnd(counters[5].sCycle);
; 509  : 
; 510  : 		counters[5].sCycle += vSyncInfo.Blank;

	mov	eax, DWORD PTR _vSyncInfo+8
	add	DWORD PTR ?counters@@3PAUCounter@@A+228, eax

; 511  : 		counters[5].CycleT = vSyncInfo.Render;

	mov	eax, DWORD PTR _vSyncInfo+4
	mov	DWORD PTR ?counters@@3PAUCounter@@A+232, eax

; 512  : 		counters[5].modeval = MODE_VRENDER;

	mov	DWORD PTR ?counters@@3PAUCounter@@A+204, 0

; 513  : 
; 514  : 		return true;

	jmp	$LN486@recExecute
$LN54@recExecute:

; 398  : 	}
; 399  : }
; 400  : 
; 401  : static __forceinline void VSyncStart(u32 sCycle)
; 402  : {
; 403  : 	EECNT_LOG( "/////////  EE COUNTER VSYNC START  \\\\\\\\\\\\\\\\\\\\  (frame: %d)\n", iFrame );

	test	DWORD PTR ?varLog@@3IA, 1073741824	; varLog, 40000000H
	je	SHORT $LN105@recExecute
	push	DWORD PTR _iFrame
	push	OFFSET ??_C@_0DM@NMBMHAFB@?1?1?1?1?1?1?1?1?1?5?5EE?5COUNTER?5VSYNC?5STAR@
	call	?SrcLog_EECNT@@YA_NPBDZZ		; SrcLog_EECNT
	add	esp, 8
$LN105@recExecute:

; 404  : 	vSyncDebugStuff(); // EE Profiling and Debug code

	call	?vSyncDebugStuff@@YAXXZ			; vSyncDebugStuff

; 405  : 
; 406  : 	if ((CSRw & 0x8)) GSCSRr|= 0x8;

	test	BYTE PTR ?CSRw@@3IA, 8
	je	SHORT $LN102@recExecute
	mov	eax, DWORD PTR ?g_RealGSMem@@3PAEA+4100
	or	DWORD PTR ?g_RealGSMem@@3PAEA+4096, 8
	mov	DWORD PTR ?g_RealGSMem@@3PAEA+4100, eax
$LN102@recExecute:

; 407  : 	if (!(GSIMR&0x800)) gsIrq();

	test	DWORD PTR ?g_RealGSMem@@3PAEA+4112, 2048 ; 00000800H
	jne	SHORT $LN108@recExecute
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp

; 109  : 	psHu32(INTC_STAT)|= 1<<n;

	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
	or	DWORD PTR [eax+61440], edi

; 110  : 	cpuTestINTCInts();

	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
$LN108@recExecute:

; 109  : 	psHu32(INTC_STAT)|= 1<<n;

	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
	or	DWORD PTR [eax+61440], 4

; 110  : 	cpuTestINTCInts();

	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\iopcounters.cpp

; 349  : 	cdvdVsync();

	call	?cdvdVsync@@YAXXZ			; cdvdVsync

; 350  : 	psxHu32(0x1070) |= 1;

	mov	eax, DWORD PTR ?psxH@@3PAEA		; psxH
	or	DWORD PTR [eax+4208], edi

; 351  : 	if(psxvblankgate & (1 << 1)) psxCheckStartGate16(1);

	mov	al, BYTE PTR ?psxvblankgate@@3EA	; psxvblankgate
	test	al, 2
	je	SHORT $LN113@recExecute
	mov	ecx, edi
	call	?psxCheckStartGate16@@YAXH@Z		; psxCheckStartGate16
	mov	al, BYTE PTR ?psxvblankgate@@3EA	; psxvblankgate
$LN113@recExecute:

; 352  : 	if(psxvblankgate & (1 << 3)) psxCheckStartGate32(3);

	test	al, 8
	je	SHORT $LN135@recExecute

; 331  : }
; 332  : 
; 333  : static void psxCheckStartGate32(int i)
; 334  : {
; 335  : 	// 32 bit gate is called for gate 3 only.  Ever.
; 336  : 	assert(i == 3);
; 337  : 	_psxCheckStartGate( i );

	mov	ecx, 3
	call	?_psxCheckStartGate@@YAXH@Z		; _psxCheckStartGate
$LN135@recExecute:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp

; 412  : 	if (gates) rcntStartGate(true, sCycle); // Counters Start Gate code

	cmp	DWORD PTR ?gates@@3HA, 0		; gates
	je	SHORT $LN100@recExecute
	mov	edx, esi
	mov	cl, 1
	call	?rcntStartGate@@YIX_NI@Z		; rcntStartGate
$LN100@recExecute:

; 413  : 	if (Config.Patch) applypatch(1); // Apply patches (ToDo: clean up patch code)

	cmp	DWORD PTR ?Config@@3UPcsxConfig@@A+3596, 0
	je	SHORT $LN99@recExecute
	mov	ecx, edi
	call	?applypatch@@YAXH@Z			; applypatch
$LN99@recExecute:

; 515  : //		SysUpdate();  // check for and handle keyevents
; 516  : 	}
; 517  : 	else	// VSYNC end / VRENDER begin
; 518  : 	{
; 519  : 		VSyncStart(counters[5].sCycle);
; 520  : 
; 521  : 		counters[5].sCycle += vSyncInfo.Render;

	mov	eax, DWORD PTR _vSyncInfo+4
	add	DWORD PTR ?counters@@3PAUCounter@@A+228, eax

; 522  : 		counters[5].CycleT = vSyncInfo.Blank;

	mov	eax, DWORD PTR _vSyncInfo+8
	mov	DWORD PTR ?counters@@3PAUCounter@@A+232, eax

; 523  : 		counters[5].modeval = MODE_VSYNC;
; 524  : 
; 525  : 		// Accumulate hsync rounding errors:
; 526  : 		counters[4].sCycle += vSyncInfo.hSyncError;

	mov	eax, DWORD PTR _vSyncInfo+12
	add	DWORD PTR ?counters@@3PAUCounter@@A+188, eax
	mov	DWORD PTR ?counters@@3PAUCounter@@A+204, 3
$LN486@recExecute:
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
$LN56@recExecute:

; 575  : 
; 576  : 
; 577  : // forceinline note: this method is called from two locations, but one
; 578  : // of them is the interpreter, which doesn't count. ;)  So might as
; 579  : // well forceinline it!
; 580  : __forceinline bool rcntUpdate()
; 581  : {
; 582  : 	bool retval = rcntUpdate_vSync();
; 583  : 
; 584  : 	// Update counters so that we can perform overflow and target tests.
; 585  : 	
; 586  : 	for (int i=0; i<=3; i++) {

	mov	DWORD PTR _i$1$[ebp], 0
	mov	edi, OFFSET ?counters@@3PAUCounter@@A+4
	npad	9
$LL50@recExecute:

; 587  : 		
; 588  : 		// We want to count gated counters (except the hblank which exclude below, and are
; 589  : 		// counted by the hblank timer instead)
; 590  : 
; 591  : 		//if ( gates & (1<<i) ) continue;
; 592  : 		
; 593  : 		if (!counters[i].mode.IsCounting ) continue;

	mov	eax, DWORD PTR [edi]
	test	al, al
	jns	$LN49@recExecute

; 594  : 
; 595  : 		if(counters[i].mode.ClockSource != 0x3)	// don't count hblank sources

	and	eax, 3
	cmp	al, 3
	je	$LN46@recExecute

; 596  : 		{
; 597  : 			s32 change = cpuRegs.cycle - counters[i].sCycleT;

	mov	esi, edx

; 527  : 
; 528  : #		ifdef VSYNC_DEBUG
; 529  : 		vblankinc++;
; 530  : 		if( vblankinc > 1 )
; 531  : 		{
; 532  : 			if( hsc != vSyncInfo.hScanlinesPerFrame )
; 533  : 				SysPrintf( " ** vSync > Abnormal Scanline Count: %d\n", hsc );
; 534  : 			hsc = 0;
; 535  : 			vblankinc = 0;
; 536  : 		}
; 537  : #		endif
; 538  : 	}
; 539  : 	return false;
; 540  : }
; 541  : 
; 542  : static __forceinline void __fastcall _cpuTestTarget( int i )
; 543  : {
; 544  : 	if (counters[i].count < counters[i].target) return;

	mov	ecx, DWORD PTR [edi+4]

; 596  : 		{
; 597  : 			s32 change = cpuRegs.cycle - counters[i].sCycleT;

	sub	esi, DWORD PTR [edi+32]

; 598  : 			if( change < 0 ) change = 0;	// sanity check!

	mov	eax, 0
	cmovs	esi, eax

; 599  : 
; 600  : 			counters[i].count += change / counters[i].rate;

	xor	edx, edx
	mov	eax, esi
	div	DWORD PTR [edi+12]
	add	DWORD PTR [edi-4], eax

; 601  : 			change -= (change / counters[i].rate) * counters[i].rate;

	imul	eax, DWORD PTR [edi+12]

; 527  : 
; 528  : #		ifdef VSYNC_DEBUG
; 529  : 		vblankinc++;
; 530  : 		if( vblankinc > 1 )
; 531  : 		{
; 532  : 			if( hsc != vSyncInfo.hScanlinesPerFrame )
; 533  : 				SysPrintf( " ** vSync > Abnormal Scanline Count: %d\n", hsc );
; 534  : 			hsc = 0;
; 535  : 			vblankinc = 0;
; 536  : 		}
; 537  : #		endif
; 538  : 	}
; 539  : 	return false;
; 540  : }
; 541  : 
; 542  : static __forceinline void __fastcall _cpuTestTarget( int i )
; 543  : {
; 544  : 	if (counters[i].count < counters[i].target) return;

	mov	edx, DWORD PTR [edi-4]

; 601  : 			change -= (change / counters[i].rate) * counters[i].rate;

	sub	esi, eax

; 602  : 			counters[i].sCycleT = cpuRegs.cycle - change;

	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	sub	eax, esi
	mov	DWORD PTR [edi+32], eax

; 545  : 
; 546  : 	if(counters[i].mode.TargetInterrupt) {

	mov	eax, DWORD PTR [edi]
	cmp	edx, ecx
	jb	SHORT $LN479@recExecute
	test	eax, 256				; 00000100H
	je	SHORT $LN140@recExecute

; 547  : 
; 548  : 		EECNT_LOG("EE Counter[%d] TARGET reached - mode=%x, count=%x, target=%x\n", i, counters[i].mode, counters[i].count, counters[i].target);

	test	DWORD PTR ?varLog@@3IA, 1073741824	; varLog, 40000000H
	mov	esi, DWORD PTR _i$1$[ebp]
	je	SHORT $LN144@recExecute
	push	ecx
	push	edx
	push	eax
	push	esi
	push	OFFSET ??_C@_0DO@EGNLMAGK@EE?5Counter?$FL?$CFd?$FN?5TARGET?5reached?5?9?5@
	call	?SrcLog_EECNT@@YA_NPBDZZ		; SrcLog_EECNT
	add	esp, 20					; 00000014H
$LN144@recExecute:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp

; 109  : 	psHu32(INTC_STAT)|= 1<<n;

	mov	edx, DWORD PTR ?psH@@3PAEA		; psH
	mov	eax, 1
	mov	ecx, DWORD PTR [edi+16]
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp

; 549  : 		counters[i].mode.TargetReached = 1;

	or	DWORD PTR [edi], 1024			; 00000400H
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp

; 109  : 	psHu32(INTC_STAT)|= 1<<n;

	shl	eax, cl
	or	DWORD PTR [edx+61440], eax

; 110  : 	cpuTestINTCInts();

	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp

; 553  : 		if (counters[i].mode.ZeroReturn)

	mov	eax, DWORD PTR [edi]
	test	al, 64					; 00000040H
	je	SHORT $LN139@recExecute

; 554  : 			counters[i].count -= counters[i].target; // Reset on target

	mov	eax, DWORD PTR [edi+4]
	sub	DWORD PTR [edi-4], eax

; 555  : 		else

	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN137@recExecute
$LN139@recExecute:

; 556  : 			counters[i].target |= EECNT_FUTURE_TARGET;

	or	DWORD PTR [edi+4], 268435456		; 10000000H
	jmp	SHORT $LN137@recExecute
$LN140@recExecute:

; 557  : 	} 
; 558  : 	else counters[i].target |= EECNT_FUTURE_TARGET;

	or	ecx, 268435456				; 10000000H
	mov	DWORD PTR [edi+4], ecx
$LN479@recExecute:
	mov	esi, DWORD PTR _i$1$[ebp]
$LN137@recExecute:

; 559  : }
; 560  : 
; 561  : static __forceinline void _cpuTestOverflow( int i )
; 562  : {
; 563  : 	if (counters[i].count <= 0xffff) return;

	mov	ecx, DWORD PTR [edi-4]
	cmp	ecx, 65535				; 0000ffffH
	jbe	SHORT $LN49@recExecute

; 564  : 	
; 565  : 	if (counters[i].mode.OverflowInterrupt) {

	test	eax, 512				; 00000200H
	je	SHORT $LN152@recExecute

; 566  : 		EECNT_LOG("EE Counter[%d] OVERFLOW - mode=%x, count=%x\n", i, counters[i].mode, counters[i].count);

	test	DWORD PTR ?varLog@@3IA, 1073741824	; varLog, 40000000H
	je	SHORT $LN151@recExecute
	push	ecx
	push	DWORD PTR [edi]
	push	esi
	push	OFFSET ??_C@_0CN@DJCFHOEE@EE?5Counter?$FL?$CFd?$FN?5OVERFLOW?5?9?5mode?$DN?$CF@
	call	?SrcLog_EECNT@@YA_NPBDZZ		; SrcLog_EECNT
	add	esp, 16					; 00000010H
$LN151@recExecute:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp

; 109  : 	psHu32(INTC_STAT)|= 1<<n;

	mov	edx, DWORD PTR ?psH@@3PAEA		; psH
	mov	eax, 1
	mov	ecx, DWORD PTR [edi+16]
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp

; 567  : 		counters[i].mode.OverflowReached = 1;

	or	DWORD PTR [edi], 2048			; 00000800H
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp

; 109  : 	psHu32(INTC_STAT)|= 1<<n;

	shl	eax, cl
	or	DWORD PTR [edx+61440], eax

; 110  : 	cpuTestINTCInts();

	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
$LN152@recExecute:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp

; 572  : 	counters[i].count -= 0x10000;

	add	DWORD PTR [edi-4], -65536		; ffff0000H

; 573  : 	counters[i].target &= 0xffff;

	xor	eax, eax
	mov	WORD PTR [edi+6], ax

; 574  : }

	jmp	SHORT $LN49@recExecute
$LN46@recExecute:

; 603  : 
; 604  : 			// Check Counter Targets and Overflows:
; 605  : 			_cpuTestTarget( i );
; 606  : 			_cpuTestOverflow( i );
; 607  : 		} 
; 608  : 		else counters[i].sCycleT = cpuRegs.cycle;

	mov	DWORD PTR [edi+32], edx
$LN49@recExecute:

; 575  : 
; 576  : 
; 577  : // forceinline note: this method is called from two locations, but one
; 578  : // of them is the interpreter, which doesn't count. ;)  So might as
; 579  : // well forceinline it!
; 580  : __forceinline bool rcntUpdate()
; 581  : {
; 582  : 	bool retval = rcntUpdate_vSync();
; 583  : 
; 584  : 	// Update counters so that we can perform overflow and target tests.
; 585  : 	
; 586  : 	for (int i=0; i<=3; i++) {

	inc	DWORD PTR _i$1$[ebp]
	add	edi, 40					; 00000028H
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	cmp	edi, OFFSET ?counters@@3PAUCounter@@A+124
	jle	$LL50@recExecute

; 96   : }
; 97   : 
; 98   : 
; 99   : static __forceinline void cpuRcntSet()
; 100  : {
; 101  : 	int i;
; 102  : 
; 103  : 	nextsCounter = cpuRegs.cycle;
; 104  : 	nextCounter = (counters[5].sCycle + counters[5].CycleT) - cpuRegs.cycle;

	mov	esi, DWORD PTR ?counters@@3PAUCounter@@A+232
	mov	edi, OFFSET ?counters@@3PAUCounter@@A+8
	sub	esi, edx
	mov	DWORD PTR ?nextsCounter@@3IA, edx	; nextsCounter
	add	esi, DWORD PTR ?counters@@3PAUCounter@@A+228
$LL157@recExecute:

; 69   : 	if (!counter.mode.IsCounting || (counter.mode.ClockSource == 0x3) ) return;

	mov	eax, DWORD PTR [edi-4]
	test	al, al
	jns	SHORT $LN156@recExecute
	and	eax, 3
	cmp	al, 3
	je	SHORT $LN156@recExecute

; 70   : 	
; 71   : 	// check for special cases where the overflow or target has just passed
; 72   : 	// (we probably missed it because we're doing/checking other things)
; 73   : 	if( counter.count > 0x10000 || counter.count > counter.target )

	mov	eax, DWORD PTR [edi-8]
	cmp	eax, 65536				; 00010000H
	ja	SHORT $LN163@recExecute
	mov	ecx, DWORD PTR [edi]
	cmp	eax, ecx
	ja	SHORT $LN163@recExecute

; 76   : 		return;
; 77   : 	}
; 78   : 
; 79   : 	// nextCounter is relative to the cpuRegs.cycle when rcntUpdate() was last called.
; 80   : 	// However, the current _rcntSet could be called at any cycle count, so we need to take
; 81   : 	// that into account.  Adding the difference from that cycle count to the current one
; 82   : 	// will do the trick!
; 83   : 
; 84   : 	c = ((0x10000 - counter.count) * counter.rate) - (cpuRegs.cycle - counter.sCycleT);

	mov	eax, 65536				; 00010000H
	sub	eax, DWORD PTR [edi-8]
	imul	eax, DWORD PTR [edi+8]

; 85   : 	c += cpuRegs.cycle - nextsCounter;		// adjust for time passed since last rcntUpdate();

	sub	eax, edx
	add	eax, DWORD PTR [edi+28]

; 86   : 	if (c < nextCounter) nextCounter = c;

	cmp	eax, esi
	cmovl	esi, eax

; 87   : 
; 88   : 	// Ignore target diff if target is currently disabled.
; 89   : 	// (the overflow is all we care about since it goes first, and then the 
; 90   : 	// target will be turned on afterward).
; 91   : 
; 92   : 	if( counter.target & EECNT_FUTURE_TARGET ) return;

	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN156@recExecute

; 93   : 	c = ((counter.target - counter.count) * counter.rate) - (cpuRegs.cycle - counter.sCycleT);

	sub	ecx, DWORD PTR [edi-8]
	imul	ecx, DWORD PTR [edi+8]

; 94   : 	c += cpuRegs.cycle - nextsCounter;		// adjust for time passed since last rcntUpdate();

	sub	ecx, edx
	add	ecx, DWORD PTR [edi+28]

; 95   : 	if (c < nextCounter) nextCounter = c;

	cmp	ecx, esi
	jge	SHORT $LN156@recExecute
	mov	esi, ecx
	jmp	SHORT $LN156@recExecute
$LN163@recExecute:

; 74   : 	{
; 75   : 		nextCounter = 4;

	mov	esi, 4
$LN156@recExecute:

; 105  : 
; 106  : 	for (i = 0; i < 4; i++)

	add	edi, 40					; 00000028H
	cmp	edi, OFFSET ?counters@@3PAUCounter@@A+168
	jl	SHORT $LL157@recExecute
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 414  : 	if((cpuRegs.PERF.n.pccr & 0x800003E0) == 0x80000020) {

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+688
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp

; 110  : 	if( nextCounter < 0 ) nextCounter = 0;

	xor	eax, eax
	test	esi, esi
	cmovs	esi, eax
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 414  : 	if((cpuRegs.PERF.n.pccr & 0x800003E0) == 0x80000020) {

	mov	eax, ecx
	and	eax, -2147482656			; 800003e0H
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\counters.cpp

; 110  : 	if( nextCounter < 0 ) nextCounter = 0;

	mov	DWORD PTR ?nextCounter@@3HA, esi	; nextCounter
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 414  : 	if((cpuRegs.PERF.n.pccr & 0x800003E0) == 0x80000020) {

	cmp	eax, -2147483616			; 80000020H
	jne	SHORT $LN170@recExecute

; 415  : 		cpuRegs.PERF.n.pcr0 += cpuRegs.cycle-s_iLastPERFCycle[0];

	mov	eax, edx
	sub	eax, DWORD PTR ?s_iLastPERFCycle@@3PAIA
	add	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+692, eax

; 416  : 		s_iLastPERFCycle[0] = cpuRegs.cycle;

	mov	DWORD PTR ?s_iLastPERFCycle@@3PAIA, edx
$LN170@recExecute:

; 417  : 	}
; 418  : 	if((cpuRegs.PERF.n.pccr & 0x800F8000) == 0x80008000) {

	and	ecx, -2146467840			; 800f8000H
	cmp	ecx, -2147450880			; 80008000H
	jne	SHORT $LN461@recExecute

; 419  : 		cpuRegs.PERF.n.pcr1 += cpuRegs.cycle-s_iLastPERFCycle[1];

	mov	eax, edx
	sub	eax, DWORD PTR ?s_iLastPERFCycle@@3PAIA+4
	add	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+696, eax

; 420  : 		s_iLastPERFCycle[1] = cpuRegs.cycle;

	mov	DWORD PTR ?s_iLastPERFCycle@@3PAIA+4, edx
$LN461@recExecute:

; 375  : 	{
; 376  : 		TESTINT(0, vif0Interrupt);
; 377  : #ifndef IPU_INLINE_IRQS
; 378  : 		TESTINT(3, ipu0Interrupt);
; 379  : 		TESTINT(4, ipu1Interrupt);
; 380  : #endif
; 381  : 		TESTINT(8, SPRFROMinterrupt);
; 382  : 		TESTINT(9, SPRTOinterrupt);
; 383  : 
; 384  : 		TESTINT(10, vifMFIFOInterrupt);
; 385  : 		TESTINT(11, gifMFIFOInterrupt);
; 386  : 	}
; 387  : }
; 388  : 
; 389  : static __forceinline void _cpuTestTIMR()
; 390  : {
; 391  : 	cpuRegs.CP0.n.Count += cpuRegs.cycle-s_iLastCOP0Cycle;

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+580
	mov	eax, edx
	sub	eax, DWORD PTR ?s_iLastCOP0Cycle@@3IA	; s_iLastCOP0Cycle
	add	ecx, eax

; 392  : 	s_iLastCOP0Cycle = cpuRegs.cycle;

	mov	DWORD PTR ?s_iLastCOP0Cycle@@3IA, edx	; s_iLastCOP0Cycle

; 393  : 
; 394  : 	// fixme: this looks like a hack to make up for the fact that the TIMR
; 395  : 	// doesn't yet have a proper mechanism for setting itself up on a nextBranchCycle.
; 396  : 	// A proper fix would schedule the TIMR to trigger at a specific cycle anytime
; 397  : 	// the Count or Compare registers are modified.
; 398  : 
; 399  : 	if ( (cpuRegs.CP0.n.Status.val & 0x8000) &&
; 400  : 		cpuRegs.CP0.n.Count >= cpuRegs.CP0.n.Compare && cpuRegs.CP0.n.Count < cpuRegs.CP0.n.Compare+1000 )

	test	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+592, 32768 ; 00008000H
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+580, ecx
	je	SHORT $LN173@recExecute
	mov	esi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+588
	cmp	ecx, esi
	jb	SHORT $LN173@recExecute
	lea	eax, DWORD PTR [esi+1000]
	cmp	ecx, eax
	jae	SHORT $LN173@recExecute

; 401  : 	{
; 402  : 		Console::Status("timr intr: %x, %x", params cpuRegs.CP0.n.Count, cpuRegs.CP0.n.Compare);

	push	esi
	push	ecx
	push	0
	push	OFFSET ??_C@_0BC@KKHOMMCD@timr?5intr?3?5?$CFx?0?5?$CFx?$AA@
	call	?Status@Console@@YA_NPBDPBU_VARG_PARAM@@ZZ ; Console::Status

; 403  : 		cpuException(0x808000, cpuRegs.branch);

	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+968
	add	esp, 16					; 00000010H
	mov	ecx, 8421376				; 00808000H
	call	?cpuException@@YAXII@Z			; cpuException
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
$LN173@recExecute:

; 456  : 	{
; 457  : 		vsyncEvent = rcntUpdate();
; 458  : 		_cpuTestPERF();
; 459  : 	}
; 460  : 
; 461  : 	_cpuTestTIMR();
; 462  : 
; 463  : 	// ---- Interrupts -------------
; 464  : 	// Handles all interrupts except 30 and 31, which are handled later.
; 465  : 
; 466  : 	if( cpuRegs.interrupt & ~(3<<30) )

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
	test	ecx, 1073741823				; 3fffffffH
	je	$LN373@recExecute

; 345  : }
; 346  : 
; 347  : static __forceinline void TESTINT( u8 n, void (*callback)() )
; 348  : {
; 349  : 	if( !(cpuRegs.interrupt & (1 << n)) ) return;

	test	cl, 2
	je	$LN475@recExecute

; 332  : 	return (int)(cpuRegs.cycle - startCycle) >= delta;

	mov	edi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+836
	mov	eax, edx
	mov	esi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+708
	sub	eax, edi
	cmp	eax, esi

; 350  : 
; 351  : 	if( cpuTestCycle( cpuRegs.sCycle[n], cpuRegs.eCycle[n] ) )

	jl	$LN180@recExecute

; 344  : 	cpuRegs.interrupt &= ~(1 << i);

	and	ecx, -3					; fffffffdH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vifdma.cpp

; 1974 : 	VIF_LOG("vif1Interrupt: %8.8x\n", cpuRegs.cycle);

	test	DWORD PTR ?varLog@@3IA, 1024		; varLog, 00000400H
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 344  : 	cpuRegs.interrupt &= ~(1 << i);

	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, ecx
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vifdma.cpp

; 1974 : 	VIF_LOG("vif1Interrupt: %8.8x\n", cpuRegs.cycle);

	je	SHORT $LN203@recExecute
	push	edx
	push	OFFSET ??_C@_0BG@OEMEHKAM@vif1Interrupt?3?5?$CF8?48x?6?$AA@
	call	?SrcLog_VIF@@YA_NPBDZZ			; SrcLog_VIF
	add	esp, 8
$LN203@recExecute:

; 1975 : 
; 1976 : 	g_vifCycles = 0;
; 1977 :     
; 1978 : 	
; 1979 : 		if(vif1.irq && vif1.tag.size == 0) {

	cmp	DWORD PTR ?vif1@@3UvifStruct@@A+20, 0
	mov	DWORD PTR ?g_vifCycles@@3HA, 0		; g_vifCycles
	je	$LN198@recExecute
	cmp	DWORD PTR ?vif1@@3UvifStruct@@A+4, 0
	jne	$LN198@recExecute

; 1980 : 			vif1Regs->stat|= VIF1_STAT_INT;

	mov	esi, DWORD PTR ?psH@@3PAEA		; psH
	or	DWORD PTR [esi+15360], 2048		; 00000800H
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp

; 109  : 	psHu32(INTC_STAT)|= 1<<n;

	or	DWORD PTR [esi+61440], 32		; 00000020H

; 110  : 	cpuTestINTCInts();

	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vifdma.cpp

; 1982 : 			--vif1.irq;

	dec	DWORD PTR ?vif1@@3UvifStruct@@A+20

; 1983 : 			if(vif1Regs->stat & (VIF1_STAT_VSS|VIF1_STAT_VIS|VIF1_STAT_VFS))

	mov	eax, DWORD PTR [esi+15360]
	test	eax, 1792				; 00000700H
	je	SHORT $LN199@recExecute

; 1984 : 				{
; 1985 : 					vif1Regs->stat&= ~0x1F000000; // FQC=0

	and	eax, -520093697				; e0ffffffH

; 1986 : 					// One game doesnt like vif stalling at end, cant remember what. Spiderman isnt keen on it tho
; 1987 : 					vif1ch->chcr &= ~0x100;

	and	DWORD PTR [esi+36864], -257		; fffffeffH
	mov	DWORD PTR [esi+15360], eax

; 1988 : 					return;

	jmp	$LN475@recExecute
$LN199@recExecute:

; 1989 : 				} 
; 1990 : 			
; 1991 : 			if(vif1ch->qwc > 0 || vif1.irqoffset > 0){

	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
	cmp	WORD PTR [eax+36896], 0
	ja	SHORT $LN197@recExecute
	cmp	BYTE PTR ?vif1@@3UvifStruct@@A+36, 0
	jbe	SHORT $LN198@recExecute
$LN197@recExecute:

; 1992 : 				if(vif1.stallontag == 1) {

	cmp	BYTE PTR ?vif1@@3UvifStruct@@A+35, 1
	jne	SHORT $LN196@recExecute
$LN192@recExecute:

; 1993 : 					_chainVIF1();

	call	?_chainVIF1@@YAHXZ			; _chainVIF1
	jmp	SHORT $LN195@recExecute
$LN196@recExecute:

; 1994 : 					}
; 1995 : 				else _VIF1chain();//CPU_INT(13, vif1ch->qwc * BIAS);

	call	?_VIF1chain@@YAHXZ			; _VIF1chain
$LN195@recExecute:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 677  : 	cpuRegs.interrupt|= 1 << n;

	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vifdma.cpp

; 1996 : 				CPU_INT(1, g_vifCycles);

	mov	esi, DWORD PTR ?g_vifCycles@@3HA	; g_vifCycles
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 677  : 	cpuRegs.interrupt|= 1 << n;

	or	edx, 2

; 678  : 	cpuRegs.sCycle[n] = cpuRegs.cycle;

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960

; 679  : 	cpuRegs.eCycle[n] = ecycle;

	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+708, esi
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+836, ecx
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, edx

; 680  : 
; 681  : 	// Interrupt is happening soon: make sure both EE and IOP are aware.
; 682  : 
; 683  : 	if( ecycle <= 28 && psxCycleEE > 0 )

	cmp	esi, 28					; 0000001cH
	jg	SHORT $LN206@recExecute
	mov	eax, DWORD PTR ?psxCycleEE@@3HA		; psxCycleEE
	test	eax, eax
	jle	SHORT $LN206@recExecute

; 684  : 	{
; 685  : 		// If running in the IOP, force it to break immediately into the EE.
; 686  : 		// the EE's branch test is due to run.
; 687  : 
; 688  : 		psxBreak += psxCycleEE;		// record the number of cycles the IOP didn't run.

	add	DWORD PTR ?psxBreak@@3HA, eax		; psxBreak

; 689  : 		psxCycleEE = 0;

	mov	DWORD PTR ?psxCycleEE@@3HA, 0		; psxCycleEE
$LN206@recExecute:

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	eax, ecx
	cmp	eax, esi
	jle	$LN222@recExecute

; 312  : 	{
; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	eax, DWORD PTR [ecx+esi]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vifdma.cpp

; 1997 : 				return;

	jmp	$LN222@recExecute
$LN198@recExecute:

; 1998 : 			}
; 1999 : 		}
; 2000 : 		
; 2001 : 		
; 2002 : 	//}
; 2003 : 	if((vif1ch->chcr & 0x100) == 0) SysPrintf("Vif1 running when CHCR == %x\n", vif1ch->chcr);

	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
	mov	eax, DWORD PTR [eax+36864]
	test	eax, 256				; 00000100H
	jne	SHORT $LN194@recExecute
	push	eax
	push	OFFSET ??_C@_0BO@KFAMBPHK@Vif1?5running?5when?5CHCR?5?$DN?$DN?5?$CFx?6?$AA@
	call	?SysPrintf@@YAXPBDZZ			; SysPrintf
	add	esp, 8
$LN194@recExecute:

; 2004 : 
; 2005 : 	
; 2006 : 	if ((vif1ch->chcr & 0x104) == 0x104 && vif1.done == 0) {

	mov	esi, DWORD PTR ?psH@@3PAEA		; psH
	mov	eax, DWORD PTR [esi+36864]
	and	eax, 260				; 00000104H
	cmp	eax, 260				; 00000104H
	jne	SHORT $LN193@recExecute
	cmp	BYTE PTR ?vif1@@3UvifStruct@@A+33, 0
	jne	SHORT $LN193@recExecute

; 2007 : 
; 2008 : 		if( !(psHu32(DMAC_CTRL) & 0x1) ) {

	test	BYTE PTR [esi+57344], 1
	jne	$LN192@recExecute

; 2009 : 			SysPrintf("vif1 dma masked\n");

	push	OFFSET ??_C@_0BB@EELLKNKM@vif1?5dma?5masked?6?$AA@
	call	?SysPrintf@@YAXPBDZZ			; SysPrintf
	add	esp, 4

; 2010 : 			return;

	jmp	$LN475@recExecute
$LN193@recExecute:

; 2011 : 		}
; 2012 : 
; 2013 : 		_chainVIF1();
; 2014 : 		CPU_INT(1, g_vifCycles);
; 2015 : 		
; 2016 : 		return;
; 2017 : 	}
; 2018 : #ifdef PCSX2_DEVBUILD
; 2019 : 	if(vif1ch->qwc > 0) SysPrintf("VIF1 Ending with %x QWC left\n");

	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
	cmp	WORD PTR [eax+36896], 0
	jbe	SHORT $LN191@recExecute
	push	OFFSET ??_C@_0BO@OINNBNMI@VIF1?5Ending?5with?5?$CFx?5QWC?5left?6?$AA@
	call	?SysPrintf@@YAXPBDZZ			; SysPrintf
	add	esp, 4
$LN191@recExecute:

; 2020 : 	if(vif1.cmd != 0) SysPrintf("vif1.cmd still set %x\n", vif1.cmd);

	mov	eax, DWORD PTR ?vif1@@3UvifStruct@@A+16
	test	eax, eax
	je	SHORT $LN190@recExecute
	push	eax
	push	OFFSET ??_C@_0BH@OMPPLFGP@vif1?4cmd?5still?5set?5?$CFx?6?$AA@
	call	?SysPrintf@@YAXPBDZZ			; SysPrintf
	add	esp, 8
$LN190@recExecute:

; 2021 : #endif
; 2022 : 
; 2023 : 	prevviftag = NULL;
; 2024 : 	prevvifcycles = 0;
; 2025 : 	vif1ch->chcr &= ~0x100;

	mov	eax, DWORD PTR ?psH@@3PAEA		; psH

; 2026 : 	hwDmacIrq(DMAC_VIF1);

	mov	ecx, 1
	mov	DWORD PTR _prevviftag, 0
	mov	DWORD PTR _prevvifcycles, 0
	and	DWORD PTR [eax+36864], -257		; fffffeffH
	call	?hwDmacIrq@@YAXH@Z			; hwDmacIrq

; 2027 : 	if(vif1Regs->mskpath3 == 0 || (vif1ch->chcr & 0x1) == 0x1)vif1Regs->stat&= ~0x1F000000; // FQC=0

	mov	esi, DWORD PTR ?psH@@3PAEA		; psH
	cmp	DWORD PTR [esi+15600], 0
	je	SHORT $LN188@recExecute
	test	BYTE PTR [esi+36864], 1
	je	SHORT $LN475@recExecute
$LN188@recExecute:
	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
	and	DWORD PTR [eax+15360], -520093697	; e0ffffffH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 356  : 	else

	jmp	SHORT $LN475@recExecute
$LN180@recExecute:

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	eax, edi
	cmp	eax, esi
	jle	SHORT $LN475@recExecute

; 312  : 	{
; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	eax, DWORD PTR [edi+esi]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
$LN475@recExecute:
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
$LN222@recExecute:

; 345  : }
; 346  : 
; 347  : static __forceinline void TESTINT( u8 n, void (*callback)() )
; 348  : {
; 349  : 	if( !(cpuRegs.interrupt & (1 << n)) ) return;

	test	dl, 4
	je	$LN478@recExecute

; 332  : 	return (int)(cpuRegs.cycle - startCycle) >= delta;

	mov	edi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+840
	mov	eax, ecx
	mov	esi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+712
	sub	eax, edi
	cmp	eax, esi

; 350  : 
; 351  : 	if( cpuTestCycle( cpuRegs.sCycle[n], cpuRegs.eCycle[n] ) )

	jl	$LN226@recExecute

; 344  : 	cpuRegs.interrupt &= ~(1 << i);

	and	edx, -5					; fffffffbH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\gif.cpp

; 39   : 	GIF_LOG("gsInterrupt: %8.8x\n", cpuRegs.cycle);

	test	DWORD PTR ?varLog@@3IA, 4096		; varLog, 00001000H
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 344  : 	cpuRegs.interrupt &= ~(1 << i);

	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, edx
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\gif.cpp

; 39   : 	GIF_LOG("gsInterrupt: %8.8x\n", cpuRegs.cycle);

	je	SHORT $LN241@recExecute
	push	ecx
	push	OFFSET ??_C@_0BE@FPDFMCPK@gsInterrupt?3?5?$CF8?48x?6?$AA@
	call	?SrcLog_GIF@@YA_NPBDZZ			; SrcLog_GIF
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	add	esp, 8
$LN241@recExecute:

; 40   : 
; 41   : 	if((gif->chcr & 0x100) == 0){

	mov	esi, DWORD PTR ?psH@@3PAEA		; psH
	test	DWORD PTR [esi+40960], 256		; 00000100H
	je	$LN478@recExecute

; 42   : 		//SysPrintf("Eh? why are you still interrupting! chcr %x, qwc %x, done = %x\n", gif->chcr, gif->qwc, done);
; 43   : 		return;
; 44   : 	}
; 45   : 	if(gif->qwc > 0 || gspath3done == 0) {

	cmp	WORD PTR [esi+40992], 0
	ja	SHORT $LN236@recExecute
	cmp	DWORD PTR _gspath3done, 0
	jne	SHORT $LN234@recExecute
$LN236@recExecute:

; 46   : 		if( !(psHu32(DMAC_CTRL) & 0x1) ) {

	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
	test	BYTE PTR [eax+57344], 1
	jne	SHORT $LN235@recExecute

; 47   : 			Console::Notice("gs dma masked, re-scheduling...");

	mov	ecx, OFFSET ??_C@_0CA@OMBBMBNE@gs?5dma?5masked?0?5re?9scheduling?4?4?4?$AA@
	call	?Notice@Console@@YA_NPBD@Z		; Console::Notice
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 677  : 	cpuRegs.interrupt|= 1 << n;

	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964

; 678  : 	cpuRegs.sCycle[n] = cpuRegs.cycle;

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	or	edx, 4

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	eax, ecx

; 677  : 	cpuRegs.interrupt|= 1 << n;

	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, edx

; 678  : 	cpuRegs.sCycle[n] = cpuRegs.cycle;

	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+840, ecx
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+712, 64 ; 00000040H

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	cmp	eax, 64					; 00000040H
	jle	$LN464@recExecute

; 312  : 	{
; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	eax, DWORD PTR [ecx+64]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\gif.cpp

; 50   : 			return;

	jmp	SHORT $LN464@recExecute
$LN235@recExecute:

; 51   : 		}
; 52   : 
; 53   : 		GIFdma();

	call	?GIFdma@@YAXXZ				; GIFdma

; 54   : #ifdef GSPATH3FIX
; 55   : 		// re-reaise the IRQ as part of the mysterious Path3fix.
; 56   : 		// fixme - this hack *should* have the gs_irq raised from the VIF, I think.  It would be
; 57   : 		// more efficient and more correct.  (air)
; 58   : 		/*if (!(vif1Regs->mskpath3 && (vif1ch->chcr & 0x100)) || (psHu32(GIF_MODE) & 0x1))
; 59   : 			CPU_INT( 2, 64 );*/
; 60   : #endif
; 61   : 		if(gspath3done == 0) return;

	cmp	DWORD PTR _gspath3done, 0
	je	SHORT $LN465@recExecute
$LN234@recExecute:

; 62   : 	}
; 63   : 
; 64   : 	gspath3done = 0;
; 65   : 	gscycles = 0;
; 66   : 	Path3transfer = 0;
; 67   : 	gif->chcr &= ~0x100;

	mov	esi, DWORD PTR ?psH@@3PAEA		; psH
	mov	DWORD PTR _gspath3done, 0
	mov	DWORD PTR _gscycles, 0
	mov	DWORD PTR ?Path3transfer@@3HA, 0	; Path3transfer
	and	DWORD PTR [esi+40960], -257		; fffffeffH

; 68   : 	GSCSRr &= ~0xC000; //Clear FIFO stuff

	mov	ecx, DWORD PTR ?g_RealGSMem@@3PAEA+4096

; 69   : 	GSCSRr |= 0x4000;  //FIFO empty

	mov	eax, DWORD PTR ?g_RealGSMem@@3PAEA+4100
	and	ecx, -32769				; ffff7fffH
	or	ecx, 16384				; 00004000H
	mov	DWORD PTR ?g_RealGSMem@@3PAEA+4100, eax
	mov	DWORD PTR ?g_RealGSMem@@3PAEA+4096, ecx

; 70   : 	//psHu32(GIF_MODE)&= ~0x4;
; 71   : 	psHu32(GIF_STAT)&= ~0xE00; // OPH=0 | APATH=0
; 72   : 	psHu32(GIF_STAT)&= ~0x1F000000; // QFC=0
; 73   : 	hwDmacIrq(DMAC_GIF);

	mov	ecx, 2
	and	DWORD PTR [esi+12320], -520097281	; e0fff1ffH
	call	?hwDmacIrq@@YAXH@Z			; hwDmacIrq
$LN465@recExecute:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 356  : 	else

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
$LN478@recExecute:
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
$LN464@recExecute:

; 345  : }
; 346  : 
; 347  : static __forceinline void TESTINT( u8 n, void (*callback)() )
; 348  : {
; 349  : 	if( !(cpuRegs.interrupt & (1 << n)) ) return;

	test	dl, 32					; 00000020H
	je	SHORT $LN264@recExecute

; 332  : 	return (int)(cpuRegs.cycle - startCycle) >= delta;

	mov	edi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+852
	mov	eax, ecx
	mov	esi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+724
	sub	eax, edi
	cmp	eax, esi

; 350  : 
; 351  : 	if( cpuTestCycle( cpuRegs.sCycle[n], cpuRegs.eCycle[n] ) )

	jl	SHORT $LN254@recExecute
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\sif.cpp

; 521  : 	sif0dma->chcr &= ~0x100;

	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 344  : 	cpuRegs.interrupt &= ~(1 << i);

	and	edx, -33				; ffffffdfH
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, edx
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\sif.cpp

; 522  : 	hwDmacIrq(DMAC_SIF0);

	mov	ecx, 5
	and	DWORD PTR [eax+49152], -257		; fffffeffH
	call	?hwDmacIrq@@YAXH@Z			; hwDmacIrq
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 356  : 	else

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
	jmp	SHORT $LN264@recExecute
$LN226@recExecute:

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
	sub	eax, edi
	cmp	eax, esi
	jle	SHORT $LN464@recExecute

; 312  : 	{
; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	eax, DWORD PTR [edi+esi]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
	jmp	SHORT $LN464@recExecute
$LN254@recExecute:

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	eax, edi
	cmp	eax, esi
	jle	SHORT $LN264@recExecute

; 312  : 	{
; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	eax, DWORD PTR [edi+esi]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
$LN264@recExecute:

; 345  : }
; 346  : 
; 347  : static __forceinline void TESTINT( u8 n, void (*callback)() )
; 348  : {
; 349  : 	if( !(cpuRegs.interrupt & (1 << n)) ) return;

	test	dl, 64					; 00000040H
	je	SHORT $LN278@recExecute

; 332  : 	return (int)(cpuRegs.cycle - startCycle) >= delta;

	mov	edi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+856
	mov	eax, ecx
	mov	esi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+728
	sub	eax, edi
	cmp	eax, esi

; 350  : 
; 351  : 	if( cpuTestCycle( cpuRegs.sCycle[n], cpuRegs.eCycle[n] ) )

	jl	SHORT $LN268@recExecute

; 344  : 	cpuRegs.interrupt &= ~(1 << i);

	and	edx, -65				; ffffffbfH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\sif.cpp

; 526  : 	hwDmacIrq(DMAC_SIF1);

	mov	ecx, 6
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 344  : 	cpuRegs.interrupt &= ~(1 << i);

	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, edx
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\sif.cpp

; 526  : 	hwDmacIrq(DMAC_SIF1);

	call	?hwDmacIrq@@YAXH@Z			; hwDmacIrq

; 527  : 	sif1dma->chcr &= ~0x100;

	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
	and	DWORD PTR [eax+50176], -257		; fffffeffH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 356  : 	else

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
	jmp	SHORT $LN278@recExecute
$LN268@recExecute:

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	eax, edi
	cmp	eax, esi
	jle	SHORT $LN278@recExecute

; 312  : 	{
; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	eax, DWORD PTR [edi+esi]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
$LN278@recExecute:

; 357  : 		cpuSetNextBranch( cpuRegs.sCycle[n], cpuRegs.eCycle[n] );
; 358  : }
; 359  : 
; 360  : static __forceinline void _cpuTestInterrupts()
; 361  : {
; 362  : 	/* These are 'pcsx2 interrupts', they handle asynchronous stuff
; 363  : 	   that depends on the cycle timings */
; 364  : 
; 365  : 	TESTINT(1, vif1Interrupt);
; 366  : 	TESTINT(2, gsInterrupt);
; 367  : 	TESTINT(5, EEsif0Interrupt);
; 368  : 	TESTINT(6, EEsif1Interrupt);
; 369  : 
; 370  : 	// Profile-guided Optimization (sorta)
; 371  : 	// The following ints are rarely called.  Encasing them in a conditional
; 372  : 	// as follows helps speed up most games.
; 373  : 
; 374  : 	if( cpuRegs.interrupt & ( 1 | (3 << 3) | (3<<8) | (3<<10)) )

	test	edx, 3865				; 00000f19H
	je	$LN373@recExecute

; 345  : }
; 346  : 
; 347  : static __forceinline void TESTINT( u8 n, void (*callback)() )
; 348  : {
; 349  : 	if( !(cpuRegs.interrupt & (1 << n)) ) return;

	test	dl, 1
	je	SHORT $LN290@recExecute

; 332  : 	return (int)(cpuRegs.cycle - startCycle) >= delta;

	mov	edi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+832
	mov	eax, ecx
	mov	esi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+704
	sub	eax, edi
	cmp	eax, esi

; 350  : 
; 351  : 	if( cpuTestCycle( cpuRegs.sCycle[n], cpuRegs.eCycle[n] ) )

	jl	SHORT $LN282@recExecute

; 344  : 	cpuRegs.interrupt &= ~(1 << i);

	and	edx, -2					; fffffffeH
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, edx

; 352  : 	{
; 353  : 		cpuClearInt( n );
; 354  : 		callback();

	call	?vif0Interrupt@@YAXXZ			; vif0Interrupt

; 356  : 	else

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
	jmp	SHORT $LN290@recExecute
$LN282@recExecute:

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	eax, edi
	cmp	eax, esi
	jle	SHORT $LN290@recExecute

; 312  : 	{
; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	eax, DWORD PTR [edi+esi]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
$LN290@recExecute:

; 345  : }
; 346  : 
; 347  : static __forceinline void TESTINT( u8 n, void (*callback)() )
; 348  : {
; 349  : 	if( !(cpuRegs.interrupt & (1 << n)) ) return;

	test	dl, 8
	je	SHORT $LN302@recExecute

; 332  : 	return (int)(cpuRegs.cycle - startCycle) >= delta;

	mov	edi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+844
	mov	eax, ecx
	mov	esi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+716
	sub	eax, edi
	cmp	eax, esi

; 350  : 
; 351  : 	if( cpuTestCycle( cpuRegs.sCycle[n], cpuRegs.eCycle[n] ) )

	jl	SHORT $LN294@recExecute

; 344  : 	cpuRegs.interrupt &= ~(1 << i);

	and	edx, -9					; fffffff7H
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, edx

; 352  : 	{
; 353  : 		cpuClearInt( n );
; 354  : 		callback();

	call	?ipu0Interrupt@@YAXXZ			; ipu0Interrupt

; 356  : 	else

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
	jmp	SHORT $LN302@recExecute
$LN294@recExecute:

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	eax, edi
	cmp	eax, esi
	jle	SHORT $LN302@recExecute

; 312  : 	{
; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	eax, DWORD PTR [edi+esi]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
$LN302@recExecute:

; 345  : }
; 346  : 
; 347  : static __forceinline void TESTINT( u8 n, void (*callback)() )
; 348  : {
; 349  : 	if( !(cpuRegs.interrupt & (1 << n)) ) return;

	test	dl, 16					; 00000010H
	je	$LN322@recExecute

; 332  : 	return (int)(cpuRegs.cycle - startCycle) >= delta;

	mov	edi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+848
	mov	eax, ecx
	mov	esi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+720
	sub	eax, edi
	cmp	eax, esi

; 350  : 
; 351  : 	if( cpuTestCycle( cpuRegs.sCycle[n], cpuRegs.eCycle[n] ) )

	jl	$LN306@recExecute

; 344  : 	cpuRegs.interrupt &= ~(1 << i);

	and	edx, -17				; ffffffefH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\ipu\ipu.cpp

; 1764 : 	IPU_LOG("ipu1Interrupt %x:\n", cpuRegs.cycle);

	test	DWORD PTR ?varLog@@3IA, 16384		; varLog, 00004000H
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 344  : 	cpuRegs.interrupt &= ~(1 << i);

	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, edx
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\ipu\ipu.cpp

; 1764 : 	IPU_LOG("ipu1Interrupt %x:\n", cpuRegs.cycle);

	je	SHORT $LN319@recExecute
	push	ecx
	push	OFFSET ??_C@_0BD@IOONBAFN@ipu1Interrupt?5?$CFx?3?6?$AA@
	call	?SrcLog_IPU@@YA_NPBDZZ			; SrcLog_IPU
	add	esp, 8
$LN319@recExecute:

; 1765 : 
; 1766 : 	if( g_nDMATransfer & IPU_DMA_FIREINT1 ) {

	mov	eax, DWORD PTR _g_nDMATransfer
	test	al, 64					; 00000040H
	je	SHORT $LN316@recExecute
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp

; 109  : 	psHu32(INTC_STAT)|= 1<<n;

	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
	or	DWORD PTR [eax+61440], 256		; 00000100H

; 110  : 	cpuTestINTCInts();

	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\ipu\ipu.cpp

; 1768 : 		g_nDMATransfer &= ~IPU_DMA_FIREINT1;

	mov	eax, DWORD PTR _g_nDMATransfer
	and	eax, -65				; ffffffbfH
	mov	DWORD PTR _g_nDMATransfer, eax
$LN316@recExecute:

; 1769 : 	}
; 1770 : 
; 1771 : 	if( g_nDMATransfer & IPU_DMA_TIE1 ) {

	test	al, 4
	je	SHORT $LN315@recExecute

; 1772 : 		g_nDMATransfer &= ~IPU_DMA_TIE1;

	and	eax, -5					; fffffffbH
	mov	DWORD PTR _g_nDMATransfer, eax

; 1773 : 	}else

	jmp	SHORT $LN314@recExecute
$LN315@recExecute:

; 1774 : 		ipu1dma->chcr &= ~0x100;

	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
	and	DWORD PTR [eax+46080], -257		; fffffeffH
$LN314@recExecute:

; 1775 : 	
; 1776 : 	hwDmacIrq(DMAC_TO_IPU);

	mov	ecx, 4
	call	?hwDmacIrq@@YAXH@Z			; hwDmacIrq
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 356  : 	else

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
	jmp	SHORT $LN322@recExecute
$LN306@recExecute:

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	eax, edi
	cmp	eax, esi
	jle	SHORT $LN322@recExecute

; 312  : 	{
; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	eax, DWORD PTR [edi+esi]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
$LN322@recExecute:

; 345  : }
; 346  : 
; 347  : static __forceinline void TESTINT( u8 n, void (*callback)() )
; 348  : {
; 349  : 	if( !(cpuRegs.interrupt & (1 << n)) ) return;

	test	edx, 256				; 00000100H
	je	SHORT $LN334@recExecute

; 332  : 	return (int)(cpuRegs.cycle - startCycle) >= delta;

	mov	edi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+864
	mov	eax, ecx
	mov	esi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+736
	sub	eax, edi
	cmp	eax, esi

; 350  : 
; 351  : 	if( cpuTestCycle( cpuRegs.sCycle[n], cpuRegs.eCycle[n] ) )

	jl	SHORT $LN326@recExecute

; 344  : 	cpuRegs.interrupt &= ~(1 << i);

	and	edx, -257				; fffffeffH
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, edx

; 352  : 	{
; 353  : 		cpuClearInt( n );
; 354  : 		callback();

	call	?SPRFROMinterrupt@@YAXXZ		; SPRFROMinterrupt

; 356  : 	else

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
	jmp	SHORT $LN334@recExecute
$LN326@recExecute:

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	eax, edi
	cmp	eax, esi
	jle	SHORT $LN334@recExecute

; 312  : 	{
; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	eax, DWORD PTR [edi+esi]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
$LN334@recExecute:

; 345  : }
; 346  : 
; 347  : static __forceinline void TESTINT( u8 n, void (*callback)() )
; 348  : {
; 349  : 	if( !(cpuRegs.interrupt & (1 << n)) ) return;

	test	edx, 512				; 00000200H
	je	SHORT $LN349@recExecute

; 332  : 	return (int)(cpuRegs.cycle - startCycle) >= delta;

	mov	edi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+868
	mov	eax, ecx
	mov	esi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+740
	sub	eax, edi
	cmp	eax, esi

; 350  : 
; 351  : 	if( cpuTestCycle( cpuRegs.sCycle[n], cpuRegs.eCycle[n] ) )

	jl	SHORT $LN338@recExecute

; 344  : 	cpuRegs.interrupt &= ~(1 << i);

	and	edx, -513				; fffffdffH
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, edx
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\spr.cpp

; 448  : 	_dmaSPR1();

	call	?_dmaSPR1@@YAXXZ			; _dmaSPR1

; 449  : 	if( spr1finished == 0 ) return;

	cmp	DWORD PTR ?spr1finished@@3HA, 0		; spr1finished
	je	SHORT $LN467@recExecute

; 450  : 	spr1->chcr &= ~0x100;

	mov	eax, DWORD PTR ?psH@@3PAEA		; psH

; 451  : 	hwDmacIrq(9);

	mov	ecx, 9
	and	DWORD PTR [eax+54272], -257		; fffffeffH
	call	?hwDmacIrq@@YAXH@Z			; hwDmacIrq
$LN467@recExecute:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 356  : 	else

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
	jmp	SHORT $LN349@recExecute
$LN338@recExecute:

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	eax, edi
	cmp	eax, esi
	jle	SHORT $LN349@recExecute

; 312  : 	{
; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	eax, DWORD PTR [edi+esi]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
$LN349@recExecute:

; 345  : }
; 346  : 
; 347  : static __forceinline void TESTINT( u8 n, void (*callback)() )
; 348  : {
; 349  : 	if( !(cpuRegs.interrupt & (1 << n)) ) return;

	test	edx, 1024				; 00000400H
	je	SHORT $LN361@recExecute

; 332  : 	return (int)(cpuRegs.cycle - startCycle) >= delta;

	mov	edi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+872
	mov	eax, ecx
	mov	esi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+744
	sub	eax, edi
	cmp	eax, esi

; 350  : 
; 351  : 	if( cpuTestCycle( cpuRegs.sCycle[n], cpuRegs.eCycle[n] ) )

	jl	SHORT $LN353@recExecute

; 344  : 	cpuRegs.interrupt &= ~(1 << i);

	and	edx, -1025				; fffffbffH
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, edx

; 352  : 	{
; 353  : 		cpuClearInt( n );
; 354  : 		callback();

	call	?vifMFIFOInterrupt@@YAXXZ		; vifMFIFOInterrupt

; 356  : 	else

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
	jmp	SHORT $LN361@recExecute
$LN353@recExecute:

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	eax, edi
	cmp	eax, esi
	jle	SHORT $LN361@recExecute

; 312  : 	{
; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	eax, DWORD PTR [edi+esi]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
$LN361@recExecute:

; 345  : }
; 346  : 
; 347  : static __forceinline void TESTINT( u8 n, void (*callback)() )
; 348  : {
; 349  : 	if( !(cpuRegs.interrupt & (1 << n)) ) return;

	test	edx, 2048				; 00000800H
	je	SHORT $LN373@recExecute

; 332  : 	return (int)(cpuRegs.cycle - startCycle) >= delta;

	mov	edi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+876
	sub	ecx, edi
	mov	esi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+748
	cmp	ecx, esi

; 350  : 
; 351  : 	if( cpuTestCycle( cpuRegs.sCycle[n], cpuRegs.eCycle[n] ) )

	jl	SHORT $LN365@recExecute

; 344  : 	cpuRegs.interrupt &= ~(1 << i);

	and	edx, -2049				; fffff7ffH
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, edx

; 352  : 	{
; 353  : 		cpuClearInt( n );
; 354  : 		callback();

	call	?gifMFIFOInterrupt@@YAXXZ		; gifMFIFOInterrupt

; 356  : 	else

	jmp	SHORT $LN373@recExecute
$LN365@recExecute:

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	eax, edi
	cmp	eax, esi
	jle	SHORT $LN373@recExecute

; 312  : 	{
; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	eax, DWORD PTR [edi+esi]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
$LN373@recExecute:

; 467  : 		_cpuTestInterrupts();
; 468  : 
; 469  : 	// ---- IOP -------------
; 470  : 	// * It's important to run a psxBranchTest before calling ExecuteBlock. This
; 471  : 	//   is because the IOP does not always perform branch tests before returning
; 472  : 	//   (during the prev branch) and also so it can act on the state the EE has
; 473  : 	//   given it before executing any code.
; 474  : 	//
; 475  : 	// * The IOP cannot always be run.  If we run IOP code every time through the
; 476  : 	//   cpuBranchTest, the IOP generally starts to run way ahead of the EE.
; 477  : 
; 478  : 	psxBranchTest();

	call	?psxBranchTest@@YAXXZ			; psxBranchTest

; 479  : 
; 480  : 	if( iopBranchAction )

	cmp	BYTE PTR ?iopBranchAction@@3_NA, 0	; iopBranchAction
	je	SHORT $LN468@recExecute

; 481  : 	{
; 482  : 		//if( EEsCycle < -450 )
; 483  : 		//	Console::WriteLn( " IOP ahead by: %d cycles", params -EEsCycle );
; 484  : 
; 485  : 		// Experimental and Probably Unnecessry Logic -->
; 486  : 		// Check if the EE already has an exception pending, and if so we shouldn't
; 487  : 		// waste too much time updating the IOP.  Theory being that the EE and IOP should
; 488  : 		// run closely in sync during raised exception events.  But in practice it didn't
; 489  : 		// seem to make much of a difference.
; 490  : 
; 491  : 		// Note: The IOP is very good about chaining blocks together so it tends to
; 492  : 		// run lots of cycles, even with only 32 (4 IOP) cycles specified here.  That's
; 493  : 		// probably why it doesn't improve sync much.
; 494  : 
; 495  : 		/*bool eeExceptPending = cpuIntsEnabled() &&
; 496  : 			//( cpuRegs.CP0.n.Status.b.EIE && cpuRegs.CP0.n.Status.b.IE && (cpuRegs.CP0.n.Status.b.ERL == 0) ) &&
; 497  : 			//( (cpuRegs.CP0.n.Status.val & 0x10007) == 0x10001 ) &&
; 498  : 			( (cpuRegs.interrupt & (3<<30)) != 0 );
; 499  : 
; 500  : 		if( eeExceptPending )
; 501  : 		{
; 502  : 			// ExecuteBlock returns a negative value, so subtract it from the cycle count
; 503  : 			// specified to get the total cycles processed! :D
; 504  : 			int cycleCount = std::min( EEsCycle, (s32)(eeWaitCycles>>4) );
; 505  : 			int cyclesRun = cycleCount - psxCpu->ExecuteBlock( cycleCount );
; 506  : 			EEsCycle -= cyclesRun;
; 507  : 			//Console::Notice( "IOP Exception-Pending Execution -- EEsCycle: %d", params EEsCycle );
; 508  : 		}
; 509  : 		else*/
; 510  : 		{
; 511  : 			EEsCycle = psxCpu->ExecuteBlock( EEsCycle );

	mov	eax, DWORD PTR ?psxCpu@@3PAUR3000Acpu@@A ; psxCpu
	push	DWORD PTR ?EEsCycle@@3HA		; EEsCycle
	mov	eax, DWORD PTR [eax+12]
	call	eax
	add	esp, 4
	mov	DWORD PTR ?EEsCycle@@3HA, eax		; EEsCycle

; 512  : 		}
; 513  : 
; 514  : 		iopBranchAction = false;

	mov	BYTE PTR ?iopBranchAction@@3_NA, 0	; iopBranchAction
$LN468@recExecute:

; 515  : 	}
; 516  : 
; 517  : 	// ---- VU0 -------------
; 518  : 
; 519  : 	if (VU0.VI[REG_VPU_STAT].UL & 0x1)

	test	BYTE PTR ?VU0@@3UVURegs@@A+976, 1
	je	SHORT $LN471@recExecute

; 520  : 	{
; 521  : 		// We're in a BranchTest.  All dynarec registers are flushed
; 522  : 		// so there is no need to freeze registers here.
; 523  : 		CpuVU0.ExecuteBlock();

	call	DWORD PTR ?CpuVU0@@3UVUmicroCpu@@A+8

; 524  : 
; 525  : 		// This might be needed to keep the EE and VU0 in sync.
; 526  : 		// A better fix will require hefty changes to the VU recs. -_-
; 527  : 		if(VU0.VI[REG_VPU_STAT].UL & 0x1)

	test	BYTE PTR ?VU0@@3UVURegs@@A+976, 1

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	ecx, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960

; 524  : 
; 525  : 		// This might be needed to keep the EE and VU0 in sync.
; 526  : 		// A better fix will require hefty changes to the VU recs. -_-
; 527  : 		if(VU0.VI[REG_VPU_STAT].UL & 0x1)

	je	SHORT $LN378@recExecute

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, ecx
	sub	eax, edx
	cmp	eax, 768				; 00000300H
	jle	SHORT $LN378@recExecute

; 312  : 	{
; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	ecx, DWORD PTR [edx+768]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
	jmp	SHORT $LN378@recExecute
$LN471@recExecute:
	mov	ecx, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
$LN378@recExecute:

; 528  : 			cpuSetNextBranchDelta( 768 );
; 529  : 	}
; 530  : 
; 531  : 	// Note:  We don't update the VU1 here because it runs it's micro-programs in
; 532  : 	// one shot always.  That is, when a program is executed the VU1 doesn't even
; 533  : 	// bother to return until the program is completely finished.
; 534  : 
; 535  : 	// ---- Schedule Next Event Test --------------
; 536  : 
; 537  : 	if( EEsCycle > 192 )

	cmp	DWORD PTR ?EEsCycle@@3HA, 192		; EEsCycle, 000000c0H
	jle	SHORT $LN383@recExecute

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, ecx
	sub	eax, edx
	cmp	eax, 48					; 00000030H
	jle	SHORT $LN383@recExecute

; 312  : 	{
; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	ecx, DWORD PTR [edx+48]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
$LN383@recExecute:

; 538  : 	{
; 539  : 		// EE's running way ahead of the IOP still, so we should branch quickly to give the
; 540  : 		// IOP extra timeslices in short order.
; 541  : 
; 542  : 		cpuSetNextBranchDelta( 48 );
; 543  : 		//Console::Notice( "EE ahead of the IOP -- Rapid Branch!  %d", params EEsCycle );
; 544  : 	}
; 545  : 
; 546  : 	// The IOP could be running ahead/behind of us, so adjust the iop's next branch by its
; 547  : 	// relative position to the EE (via EEsCycle)
; 548  : 	cpuSetNextBranchDelta( ((g_psxNextBranchCycle-psxRegs.cycle)*8) - EEsCycle );

	mov	esi, DWORD PTR ?g_psxNextBranchCycle@@3IA ; g_psxNextBranchCycle

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, ecx

; 538  : 	{
; 539  : 		// EE's running way ahead of the IOP still, so we should branch quickly to give the
; 540  : 		// IOP extra timeslices in short order.
; 541  : 
; 542  : 		cpuSetNextBranchDelta( 48 );
; 543  : 		//Console::Notice( "EE ahead of the IOP -- Rapid Branch!  %d", params EEsCycle );
; 544  : 	}
; 545  : 
; 546  : 	// The IOP could be running ahead/behind of us, so adjust the iop's next branch by its
; 547  : 	// relative position to the EE (via EEsCycle)
; 548  : 	cpuSetNextBranchDelta( ((g_psxNextBranchCycle-psxRegs.cycle)*8) - EEsCycle );

	sub	esi, DWORD PTR ?psxRegs@@3UpsxRegisters@@A+528

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	sub	eax, edx

; 538  : 	{
; 539  : 		// EE's running way ahead of the IOP still, so we should branch quickly to give the
; 540  : 		// IOP extra timeslices in short order.
; 541  : 
; 542  : 		cpuSetNextBranchDelta( 48 );
; 543  : 		//Console::Notice( "EE ahead of the IOP -- Rapid Branch!  %d", params EEsCycle );
; 544  : 	}
; 545  : 
; 546  : 	// The IOP could be running ahead/behind of us, so adjust the iop's next branch by its
; 547  : 	// relative position to the EE (via EEsCycle)
; 548  : 	cpuSetNextBranchDelta( ((g_psxNextBranchCycle-psxRegs.cycle)*8) - EEsCycle );

	shl	esi, 3
	sub	esi, DWORD PTR ?EEsCycle@@3HA		; EEsCycle

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	cmp	eax, esi
	jle	SHORT $LN388@recExecute

; 312  : 	{
; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	ecx, DWORD PTR [edx+esi]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
$LN388@recExecute:

; 549  : 
; 550  : 	// Apply the hsync counter's nextCycle
; 551  : 	cpuSetNextBranch( counters[4].sCycle, counters[4].CycleT );

	mov	edi, DWORD PTR ?counters@@3PAUCounter@@A+188

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, ecx

; 549  : 
; 550  : 	// Apply the hsync counter's nextCycle
; 551  : 	cpuSetNextBranch( counters[4].sCycle, counters[4].CycleT );

	mov	esi, DWORD PTR ?counters@@3PAUCounter@@A+192

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	sub	eax, edi
	cmp	eax, esi
	jle	SHORT $LN391@recExecute

; 312  : 	{
; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	ecx, DWORD PTR [edi+esi]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
$LN391@recExecute:

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	esi, DWORD PTR ?nextsCounter@@3IA	; nextsCounter
	mov	eax, ecx
	mov	edi, DWORD PTR ?nextCounter@@3HA	; nextCounter
	sub	eax, esi
	cmp	eax, edi
	jle	SHORT $LN394@recExecute

; 312  : 	{
; 313  : 		g_nextBranchCycle = startCycle + delta;

	lea	ecx, DWORD PTR [esi+edi]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
$LN394@recExecute:

; 421  : 	}
; 422  : }
; 423  : 
; 424  : // Checks the COP0.Status for exception enablings.
; 425  : // Exception handling for certain modes is *not* currently supported, this function filters
; 426  : // them out.  Exceptions while the exception handler is active (EIE), or exceptions of any
; 427  : // level other than 0 are ignored here.
; 428  : 
; 429  : static bool cpuIntsEnabled()
; 430  : {
; 431  : 	return cpuRegs.CP0.n.Status.b.EIE && cpuRegs.CP0.n.Status.b.IE && 
; 432  : 		!cpuRegs.CP0.n.Status.b.EXL && (cpuRegs.CP0.n.Status.b.ERL == 0);

	test	BYTE PTR ?cpuRegs@@3UcpuRegisters@@A+594, 1

; 552  : 
; 553  : 	// Apply vsync and other counter nextCycles
; 554  : 	cpuSetNextBranch( nextsCounter, nextCounter );
; 555  : 
; 556  : 	eeEventTestIsActive = false;

	mov	BYTE PTR ?eeEventTestIsActive@@3_NA, 0	; eeEventTestIsActive

; 421  : 	}
; 422  : }
; 423  : 
; 424  : // Checks the COP0.Status for exception enablings.
; 425  : // Exception handling for certain modes is *not* currently supported, this function filters
; 426  : // them out.  Exceptions while the exception handler is active (EIE), or exceptions of any
; 427  : // level other than 0 are ignored here.
; 428  : 
; 429  : static bool cpuIntsEnabled()
; 430  : {
; 431  : 	return cpuRegs.CP0.n.Status.b.EIE && cpuRegs.CP0.n.Status.b.IE && 
; 432  : 		!cpuRegs.CP0.n.Status.b.EXL && (cpuRegs.CP0.n.Status.b.ERL == 0);

	je	$LN437@recExecute
	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+592
	test	al, 1
	je	$LN437@recExecute
	test	al, 6
	jne	$LN437@recExecute

; 345  : }
; 346  : 
; 347  : static __forceinline void TESTINT( u8 n, void (*callback)() )
; 348  : {
; 349  : 	if( !(cpuRegs.interrupt & (1 << n)) ) return;

	mov	esi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
	test	esi, 1073741824				; 40000000H
	je	$LN482@recExecute

; 332  : 	return (int)(cpuRegs.cycle - startCycle) >= delta;

	mov	edi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+824
	mov	eax, edx
	sub	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+952
	cmp	eax, edi

; 350  : 
; 351  : 	if( cpuTestCycle( cpuRegs.sCycle[n], cpuRegs.eCycle[n] ) )

	jl	$LN402@recExecute
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp

; 76   : 	if ((cpuRegs.CP0.n.Status.val & 0x400) != 0x400) return;

	mov	edi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+592
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 344  : 	cpuRegs.interrupt &= ~(1 << i);

	and	esi, -1073741825			; bfffffffH
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, esi
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp

; 76   : 	if ((cpuRegs.CP0.n.Status.val & 0x400) != 0x400) return;

	test	edi, 1024				; 00000400H
	je	$LN472@recExecute

; 77   : 
; 78   : 	if ((psHu32(INTC_STAT)) == 0) {

	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
	cmp	DWORD PTR [eax+61440], 0
	jne	SHORT $LN412@recExecute

; 79   : 		DevCon::Notice("*PCSX2*: intcInterrupt already cleared");

	mov	ecx, OFFSET ??_C@_0CH@FCDDAIFJ@?$CKPCSX2?$CK?3?5intcInterrupt?5already?5c@
	call	?Notice@Console@@YA_NPBD@Z		; Console::Notice
$LN488@recExecute:

; 80   :         return;

	mov	ecx, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	mov	esi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	jmp	$LN482@recExecute
$LN412@recExecute:

; 81   : 	}
; 82   : 	if ((psHu32(INTC_STAT) & psHu32(INTC_MASK)) == 0) return;

	mov	esi, DWORD PTR [eax+61456]
	and	esi, DWORD PTR [eax+61440]
	mov	DWORD PTR tv3170[ebp], esi
	mov	esi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
	je	SHORT $LN417@recExecute

; 83   : 
; 84   : 	HW_LOG("intcInterrupt %x\n", psHu32(INTC_STAT) & psHu32(INTC_MASK));

	test	BYTE PTR ?varLog@@3IA, 4
	je	SHORT $LN416@recExecute
	push	DWORD PTR tv3170[ebp]
	push	OFFSET ??_C@_0BC@LCGONOKJ@intcInterrupt?5?$CFx?6?$AA@
	call	?SrcLog_HW@@YA_NPBDZZ			; SrcLog_HW
	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
	add	esp, 8
$LN416@recExecute:

; 85   : 	if(psHu32(INTC_STAT) & 0x2){

	test	BYTE PTR [eax+61440], 2
	je	SHORT $LN410@recExecute

; 86   : 		counters[0].hold = rcntRcount(0);

	xor	ecx, ecx
	call	?rcntRcount@@YIIH@Z			; rcntRcount

; 87   : 		counters[1].hold = rcntRcount(1);

	mov	ecx, 1
	mov	DWORD PTR ?counters@@3PAUCounter@@A+12, eax
	call	?rcntRcount@@YIIH@Z			; rcntRcount
	mov	DWORD PTR ?counters@@3PAUCounter@@A+52, eax
$LN410@recExecute:

; 88   : 	}
; 89   : 
; 90   : 	cpuException(0x400, cpuRegs.branch);

	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+968
	mov	ecx, 1024				; 00000400H
	call	?cpuException@@YAXII@Z			; cpuException
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 356  : 	else

	jmp	$LN488@recExecute
$LN402@recExecute:

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	eax, ecx
	sub	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+952
	cmp	eax, edi
	jle	SHORT $LN482@recExecute

; 312  : 	{
; 313  : 		g_nextBranchCycle = startCycle + delta;

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+952
	add	ecx, edi
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
$LN482@recExecute:
	mov	edi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+592
$LN472@recExecute:
	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
$LN417@recExecute:

; 345  : }
; 346  : 
; 347  : static __forceinline void TESTINT( u8 n, void (*callback)() )
; 348  : {
; 349  : 	if( !(cpuRegs.interrupt & (1 << n)) ) return;

	test	esi, esi
	jns	$LN437@recExecute

; 332  : 	return (int)(cpuRegs.cycle - startCycle) >= delta;

	sub	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+956
	cmp	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+828

; 350  : 
; 351  : 	if( cpuTestCycle( cpuRegs.sCycle[n], cpuRegs.eCycle[n] ) )

	jl	$LN421@recExecute

; 344  : 	cpuRegs.interrupt &= ~(1 << i);

	and	esi, 2147483647				; 7fffffffH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp

; 95   :     if ((cpuRegs.CP0.n.Status.val & 0x10807) != 0x10801) return;

	and	edi, 67591				; 00010807H
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 344  : 	cpuRegs.interrupt &= ~(1 << i);

	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, esi
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\hw.cpp

; 95   :     if ((cpuRegs.CP0.n.Status.val & 0x10807) != 0x10801) return;

	cmp	edi, 67585				; 00010801H
	jne	$LN437@recExecute

; 96   : 
; 97   : 	if( ((psHu16(0xe012) & psHu16(0xe010)) == 0 ) && 
; 98   : 		( psHu16(0xe010) & 0x8000) == 0 ) return;

	movzx	ecx, WORD PTR [eax+57360]
	mov	dx, WORD PTR [eax+57362]
	and	dx, cx
	jne	SHORT $LN430@recExecute
	test	ecx, 32768				; 00008000H
	je	SHORT $LN437@recExecute
$LN430@recExecute:

; 99   : 
; 100  : 	if((psHu32(DMAC_CTRL) & 0x1) == 0) return;

	test	BYTE PTR [eax+57344], 1
	je	SHORT $LN437@recExecute

; 101  : 	
; 102  : 	HW_LOG("dmacInterrupt %x\n", (psHu16(0xe012) & psHu16(0xe010) || 
; 103  : 								  psHu16(0xe010) & 0x8000));

	test	BYTE PTR ?varLog@@3IA, 4
	je	SHORT $LN436@recExecute
	test	dx, dx
	jne	SHORT $LN434@recExecute
	test	ecx, 32768				; 00008000H
	jne	SHORT $LN434@recExecute
	xor	eax, eax
	jmp	SHORT $LN435@recExecute
$LN434@recExecute:
	mov	eax, 1
$LN435@recExecute:
	push	eax
	push	OFFSET ??_C@_0BC@IOCBKJEO@dmacInterrupt?5?$CFx?6?$AA@
	call	?SrcLog_HW@@YA_NPBDZZ			; SrcLog_HW
	add	esp, 8
$LN436@recExecute:

; 104  : 
; 105  : 	cpuException(0x800, cpuRegs.branch);

	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+968
	mov	ecx, 2048				; 00000800H
	call	?cpuException@@YAXII@Z			; cpuException
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 817  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN421@recExecute:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\r5900.cpp

; 311  : 	if( (int)(g_nextBranchCycle - startCycle) > delta )

	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+956
	sub	ecx, edx
	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+828
	cmp	ecx, eax
	jle	SHORT $LN437@recExecute

; 312  : 	{
; 313  : 		g_nextBranchCycle = startCycle + delta;

	add	eax, edx
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
$LN437@recExecute:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 817  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?recExecuteBlock@@YAXXZ ENDP				; recExecuteBlock
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
_TEXT	SEGMENT
_Addr$ = 8						; size = 4
_Size$ = 12						; size = 4
?recClear@@YAXII@Z PROC					; recClear

; 915  : {

	push	edi

; 916  : 	u32 i;
; 917  : 	for(i = 0; i < Size; ++i, Addr+=4) {

	mov	edi, DWORD PTR _Size$[esp]
	test	edi, edi
	je	SHORT $LN1@recClear
	push	esi
	mov	esi, DWORD PTR _Addr$[esp+4]
	npad	2
$LL3@recClear:

; 921  : 
; 922  : static const int EE_MIN_BLOCK_BYTES = 15;
; 923  : 
; 924  : void recClearMem(BASEBLOCK* p)
; 925  : {
; 926  : 	BASEBLOCKEX* pexblock;
; 927  : 	BASEBLOCK* pstart;
; 928  : 	int lastdelay;
; 929  : 
; 930  : 	// necessary since recompiler doesn't call femms/emms
; 931  : #ifdef _MSC_VER
; 932  : 	if (cpucaps.has3DNOWInstructionExtensions) __asm femms;
; 933  : 	else __asm emms;
; 934  : #else
; 935  :     if( cpucaps.has3DNOWInstructionExtensions )__asm__("femms");
; 936  :     else __asm__("emms");
; 937  : #endif
; 938  : 		
; 939  : 	assert( p != NULL );
; 940  : 
; 941  : 	if( p->uType & BLOCKTYPE_DELAYSLOT ) {
; 942  : 		recClearMem(p-1);
; 943  : 		if( p->GetFnptr() == 0 )
; 944  : 			return;
; 945  : 	}
; 946  : 
; 947  : 	assert( p->GetFnptr() != 0 );
; 948  : 	assert( p->startpc );
; 949  : 
; 950  : 	x86Ptr = (u8*)p->GetFnptr();
; 951  : 
; 952  : 	// there is a small problem: mem can be ored with 0xa<<28 or 0x8<<28, and don't know which
; 953  : 	MOV32ItoR(EDX, p->startpc);
; 954  : 	PUSH32I((u32)x86Ptr); // will be replaced by JMP32
; 955  : 	JMP32((u32)DispatcherClear - ( (u32)x86Ptr + 5 ));
; 956  : 	assert( x86Ptr == (u8*)p->GetFnptr() + EE_MIN_BLOCK_BYTES );
; 957  : 
; 958  : 	pstart = PC_GETBLOCK(p->startpc);
; 959  : 	pexblock = PC_GETBLOCKEX(pstart);
; 960  : 	assert( pexblock->startpc == pstart->startpc );
; 961  : 
; 962  :     if( pexblock->startpc != pstart->startpc ) {
; 963  :         // some bug with ffx after beating a big snake in sewers
; 964  :         RemoveBaseBlockEx(pexblock, 0);
; 965  : 	    pexblock->size = 0;
; 966  : 	    pexblock->startpc = 0;
; 967  :         return;
; 968  :     }
; 969  : 
; 970  : 	// don't delete if last is delay
; 971  : 	lastdelay = pexblock->size;
; 972  : 	if( pstart[pexblock->size-1].uType & BLOCKTYPE_DELAYSLOT ) {
; 973  : 		assert( pstart[pexblock->size-1].GetFnptr() != pstart->GetFnptr() );
; 974  : 		if( pstart[pexblock->size-1].GetFnptr() != 0 ) {
; 975  : 			pstart[pexblock->size-1].uType = 0;
; 976  : 			--lastdelay;
; 977  : 		}
; 978  : 	}
; 979  : 
; 980  : 	memset(pstart, 0, lastdelay*sizeof(BASEBLOCK));
; 981  : 
; 982  : 	RemoveBaseBlockEx(pexblock, 0);
; 983  : 	pexblock->size = 0;
; 984  : 	pexblock->startpc = 0;
; 985  : }
; 986  : 
; 987  : void REC_CLEARM( u32 mem )
; 988  : {
; 989  : 	if ((mem) < maxrecmem && recLUT[(mem) >> 16]) {

	cmp	esi, DWORD PTR ?maxrecmem@@3IA		; maxrecmem
	jae	SHORT $LN2@recClear
	mov	eax, DWORD PTR ?recLUT@@3PAIA		; recLUT
	mov	ecx, esi
	shr	ecx, 16					; 00000010H
	mov	ecx, DWORD PTR [eax+ecx*4]
	test	ecx, ecx
	je	SHORT $LN2@recClear

; 990  : 		BASEBLOCK* p = PC_GETBLOCK(mem);

	movzx	eax, si

; 991  : 		if( *(u32*)p ) recClearMem(p);

	cmp	DWORD PTR [ecx+eax*2], 0
	lea	ecx, DWORD PTR [ecx+eax*2]
	je	SHORT $LN2@recClear
	call	?recClearMem@@YAXPAUBASEBLOCK@@@Z	; recClearMem
$LN2@recClear:

; 916  : 	u32 i;
; 917  : 	for(i = 0; i < Size; ++i, Addr+=4) {

	add	esi, 4
	dec	edi
	jne	SHORT $LL3@recClear
	pop	esi
$LN1@recClear:
	pop	edi

; 918  : 		REC_CLEARM(Addr);
; 919  : 	}
; 920  : }

	ret	0
?recClear@@YAXII@Z ENDP					; recClear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\baseblockex.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\baseblockex.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\baseblockex.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\baseblockex.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\baseblockex.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\baseblockex.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
_TEXT	SEGMENT
?recClearMem@@YAXPAUBASEBLOCK@@@Z PROC			; recClearMem
; _p$ = ecx

; 926  : 	BASEBLOCKEX* pexblock;
; 927  : 	BASEBLOCK* pstart;
; 928  : 	int lastdelay;
; 929  : 
; 930  : 	// necessary since recompiler doesn't call femms/emms
; 931  : #ifdef _MSC_VER
; 932  : 	if (cpucaps.has3DNOWInstructionExtensions) __asm femms;

	cmp	DWORD PTR ?cpucaps@@3UCAPABILITIES@@A+136, 0
	push	esi
	mov	esi, ecx
	je	SHORT $LN7@recClearMe
	femms
	jmp	SHORT $LN6@recClearMe
$LN7@recClearMe:

; 933  : 	else __asm emms;

	emms
$LN6@recClearMe:

; 934  : #else
; 935  :     if( cpucaps.has3DNOWInstructionExtensions )__asm__("femms");
; 936  :     else __asm__("emms");
; 937  : #endif
; 938  : 		
; 939  : 	assert( p != NULL );
; 940  : 
; 941  : 	if( p->uType & BLOCKTYPE_DELAYSLOT ) {

	mov	ecx, DWORD PTR [esi]
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN4@recClearMe

; 942  : 		recClearMem(p-1);

	lea	ecx, DWORD PTR [esi-8]
	call	?recClearMem@@YAXPAUBASEBLOCK@@@Z	; recClearMem
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\baseblockex.h

; 35   : 	const uptr GetFnptr() const { return ((u32)m_pFnptr)<<4; }

	mov	ecx, DWORD PTR [esi]
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 943  : 		if( p->GetFnptr() == 0 )

	test	ecx, 268435455				; 0fffffffH
	je	$LN8@recClearMe
$LN4@recClearMe:

; 944  : 			return;
; 945  : 	}
; 946  : 
; 947  : 	assert( p->GetFnptr() != 0 );
; 948  : 	assert( p->startpc );
; 949  : 
; 950  : 	x86Ptr = (u8*)p->GetFnptr();
; 951  : 
; 952  : 	// there is a small problem: mem can be ored with 0xa<<28 or 0x8<<28, and don't know which
; 953  : 	MOV32ItoR(EDX, p->startpc);

	mov	eax, DWORD PTR [esi+4]
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\baseblockex.h

; 35   : 	const uptr GetFnptr() const { return ((u32)m_pFnptr)<<4; }

	shl	ecx, 4
	push	ebx
	push	ebp
	push	edi
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	BYTE PTR [ecx], 186			; 000000baH

; 1740 : 	x86Ptr++; 
; 1741 : } 
; 1742 : 
; 1743 : __forceinline void write16(u16 val ) 
; 1744 : { 
; 1745 : 	*(u16*)x86Ptr = (u16)val; 
; 1746 : 	x86Ptr += 2;  
; 1747 : } 
; 1748 : 
; 1749 : __forceinline void write24(u32 val ) 
; 1750 : { 
; 1751 : 	*(u8*)x86Ptr = (u8)(val & 0xff); 
; 1752 : 	x86Ptr++;  
; 1753 : 	*(u8*)x86Ptr = (u8)((val >> 8) & 0xff); 
; 1754 : 	x86Ptr++;  
; 1755 : 	*(u8*)x86Ptr = (u8)((val >> 16) & 0xff); 
; 1756 : 	x86Ptr++;  
; 1757 : } 
; 1758 : 
; 1759 : __forceinline void write32(u32 val ) 
; 1760 : { 
; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [ecx+1], eax
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 954  : 	PUSH32I((u32)x86Ptr); // will be replaced by JMP32

	lea	eax, DWORD PTR [ecx+5]
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	BYTE PTR [ecx+5], 104			; 00000068H

; 1740 : 	x86Ptr++; 
; 1741 : } 
; 1742 : 
; 1743 : __forceinline void write16(u16 val ) 
; 1744 : { 
; 1745 : 	*(u16*)x86Ptr = (u16)val; 
; 1746 : 	x86Ptr += 2;  
; 1747 : } 
; 1748 : 
; 1749 : __forceinline void write24(u32 val ) 
; 1750 : { 
; 1751 : 	*(u8*)x86Ptr = (u8)(val & 0xff); 
; 1752 : 	x86Ptr++;  
; 1753 : 	*(u8*)x86Ptr = (u8)((val >> 8) & 0xff); 
; 1754 : 	x86Ptr++;  
; 1755 : 	*(u8*)x86Ptr = (u8)((val >> 16) & 0xff); 
; 1756 : 	x86Ptr++;  
; 1757 : } 
; 1758 : 
; 1759 : __forceinline void write32(u32 val ) 
; 1760 : { 
; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [ecx+6], eax

; 1762 : 	x86Ptr += 4; 

	add	ecx, 10					; 0000000aH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 955  : 	JMP32((u32)DispatcherClear - ( (u32)x86Ptr + 5 ));

	mov	eax, OFFSET ?DispatcherClear@@YAXXZ	; DispatcherClear
	sub	eax, ecx
	sub	eax, 5
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	BYTE PTR [ecx], 233			; 000000e9H

; 1740 : 	x86Ptr++; 
; 1741 : } 
; 1742 : 
; 1743 : __forceinline void write16(u16 val ) 
; 1744 : { 
; 1745 : 	*(u16*)x86Ptr = (u16)val; 
; 1746 : 	x86Ptr += 2;  
; 1747 : } 
; 1748 : 
; 1749 : __forceinline void write24(u32 val ) 
; 1750 : { 
; 1751 : 	*(u8*)x86Ptr = (u8)(val & 0xff); 
; 1752 : 	x86Ptr++;  
; 1753 : 	*(u8*)x86Ptr = (u8)((val >> 8) & 0xff); 
; 1754 : 	x86Ptr++;  
; 1755 : 	*(u8*)x86Ptr = (u8)((val >> 16) & 0xff); 
; 1756 : 	x86Ptr++;  
; 1757 : } 
; 1758 : 
; 1759 : __forceinline void write32(u32 val ) 
; 1760 : { 
; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [ecx+1], eax

; 1762 : 	x86Ptr += 4; 

	add	ecx, 5
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 958  : 	pstart = PC_GETBLOCK(p->startpc);

	mov	eax, DWORD PTR [esi+4]
	mov	edx, eax
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1762 : 	x86Ptr += 4; 

	mov	DWORD PTR ?x86Ptr@@3PAEA, ecx		; x86Ptr
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 958  : 	pstart = PC_GETBLOCK(p->startpc);

	movzx	ecx, ax
	mov	eax, DWORD PTR ?recLUT@@3PAIA		; recLUT
	shr	edx, 16					; 00000010H
	mov	eax, DWORD PTR [eax+edx*4]
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\baseblockex.cpp

; 133  : 	return s_vecBaseBlocksEx[cpu].blocks[s_vecBaseBlocksEx[cpu].Get(startpc)];

	mov	esi, DWORD PTR [eax+ecx*2+4]
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 958  : 	pstart = PC_GETBLOCK(p->startpc);

	lea	ebx, DWORD PTR [eax+ecx*2]
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\baseblockex.cpp

; 133  : 	return s_vecBaseBlocksEx[cpu].blocks[s_vecBaseBlocksEx[cpu].Get(startpc)];

	push	esi
	mov	ecx, OFFSET _s_vecBaseBlocksEx
	call	?Get@BASEBLOCKS@@QAEHI@Z		; BASEBLOCKS::Get
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 959  : 	pexblock = PC_GETBLOCKEX(pstart);

	mov	ebp, DWORD PTR _s_vecBaseBlocksEx
	mov	edi, DWORD PTR [ebp+eax*4]

; 960  : 	assert( pexblock->startpc == pstart->startpc );
; 961  : 
; 962  :     if( pexblock->startpc != pstart->startpc ) {

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, esi
	je	SHORT $LN3@recClearMe
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\baseblockex.cpp

; 106  : 	int i = Get(pex->startpc);

	push	eax
	mov	ecx, OFFSET _s_vecBaseBlocksEx
	call	?Get@BASEBLOCKS@@QAEHI@Z		; BASEBLOCKS::Get
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 170  : 		_Ptr += _Off;

	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 967  :         return;

	jmp	SHORT $LN113@recClearMe
$LN3@recClearMe:

; 968  :     }
; 969  : 
; 970  : 	// don't delete if last is delay
; 971  : 	lastdelay = pexblock->size;

	movzx	ecx, WORD PTR [edi]

; 972  : 	if( pstart[pexblock->size-1].uType & BLOCKTYPE_DELAYSLOT ) {

	mov	eax, DWORD PTR [ebx+ecx*8-8]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN1@recClearMe

; 973  : 		assert( pstart[pexblock->size-1].GetFnptr() != pstart->GetFnptr() );
; 974  : 		if( pstart[pexblock->size-1].GetFnptr() != 0 ) {

	test	eax, 268435455				; 0fffffffH
	je	SHORT $LN1@recClearMe

; 975  : 			pstart[pexblock->size-1].uType = 0;

	and	eax, 268435455				; 0fffffffH
	mov	DWORD PTR [ebx+ecx*8-8], eax

; 976  : 			--lastdelay;

	dec	ecx
$LN1@recClearMe:

; 977  : 		}
; 978  : 	}
; 979  : 
; 980  : 	memset(pstart, 0, lastdelay*sizeof(BASEBLOCK));

	lea	eax, DWORD PTR [ecx*8]
	push	eax
	push	0
	push	ebx
	call	_memset
	add	esp, 12					; 0000000cH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\baseblockex.cpp

; 106  : 	int i = Get(pex->startpc);

	mov	ecx, OFFSET _s_vecBaseBlocksEx
	push	DWORD PTR [edi+4]
	call	?Get@BASEBLOCKS@@QAEHI@Z		; BASEBLOCKS::Get
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 170  : 		_Ptr += _Off;

	mov	ecx, DWORD PTR _s_vecBaseBlocksEx
	lea	eax, DWORD PTR [ecx+eax*4]
$LN113@recClearMe:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2429 : 	ptrdiff_t _Count = _Last - _First;

	mov	ecx, DWORD PTR _s_vecBaseBlocksEx+4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1454 : 			_VIPTR(_Where));

	lea	edx, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2429 : 	ptrdiff_t _Count = _Last - _First;

	sub	ecx, edx

; 2431 : 		_Count * sizeof (*_First));

	and	ecx, -4					; fffffffcH
	push	ecx
	push	edx
	push	eax
	call	DWORD PTR __imp__memmove
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1456 : 		--this->_Mylast;

	sub	DWORD PTR _s_vecBaseBlocksEx+4, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2431 : 		_Count * sizeof (*_First));

	add	esp, 12					; 0000000cH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 983  : 	pexblock->size = 0;

	xor	eax, eax

; 984  : 	pexblock->startpc = 0;

	mov	DWORD PTR [edi+4], eax
	mov	WORD PTR [edi], ax
	pop	edi
	pop	ebp
	pop	ebx
$LN8@recClearMe:
	pop	esi

; 985  : }

	ret	0
?recClearMem@@YAXPAUBASEBLOCK@@@Z ENDP			; recClearMem
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
_TEXT	SEGMENT
?REC_CLEARM@@YAXI@Z PROC				; REC_CLEARM
; _mem$ = ecx

; 989  : 	if ((mem) < maxrecmem && recLUT[(mem) >> 16]) {

	cmp	ecx, DWORD PTR ?maxrecmem@@3IA		; maxrecmem
	jae	SHORT $LN1@REC_CLEARM
	mov	eax, DWORD PTR ?recLUT@@3PAIA		; recLUT
	mov	edx, ecx
	shr	edx, 16					; 00000010H
	mov	edx, DWORD PTR [eax+edx*4]
	test	edx, edx
	je	SHORT $LN1@REC_CLEARM

; 990  : 		BASEBLOCK* p = PC_GETBLOCK(mem);

	movzx	eax, cx

; 991  : 		if( *(u32*)p ) recClearMem(p);

	cmp	DWORD PTR [edx+eax*2], 0
	lea	ecx, DWORD PTR [edx+eax*2]
	jne	?recClearMem@@YAXPAUBASEBLOCK@@@Z	; recClearMem
$LN1@REC_CLEARM:

; 992  : 	}
; 993  : }

	ret	0
?REC_CLEARM@@YAXI@Z ENDP				; REC_CLEARM
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
_TEXT	SEGMENT
_jump$1$ = -4						; size = 4
_jump$1$ = -4						; size = 4
?CheckForBIOSEnd@@YAXXZ PROC				; CheckForBIOSEnd

; 997  : {

	push	ecx
	push	ebx
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	ebx, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
	push	esi
	push	edi
	mov	WORD PTR [ebx], 1419			; 0000058bH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp

; 142  : 	return (u8*)(x86Ptr - 1);

	lea	edi, DWORD PTR [ebx+12]
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [ebx+2], OFFSET ?cpuRegs@@3UcpuRegisters@@A+680
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp

; 142  : 	return (u8*)(x86Ptr - 1);

	lea	esi, DWORD PTR [ebx+19]
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	BYTE PTR [ebx+6], 61			; 0000003dH

; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [ebx+7], 2097160		; 00200008H

; 1739 : 	*x86Ptr = (u8)val; 

	mov	WORD PTR [ebx+11], 116			; 00000074H
	mov	BYTE PTR [ebx+13], 61			; 0000003dH

; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [ebx+14], 1048584		; 00100008H

; 1739 : 	*x86Ptr = (u8)val; 

	mov	DWORD PTR [ebx+18], 15401076		; 00eb0074H

; 1740 : 	x86Ptr++; 

	add	ebx, 22					; 00000016H
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1001 : 	j8Ptr[0] = JE8(0);

	mov	DWORD PTR ?j8Ptr@@3PAPAEA, edi

; 1002 : 
; 1003 : 	CMP32ItoR(EAX, 0x00100008);
; 1004 : 	j8Ptr[1] = JE8(0);

	mov	DWORD PTR ?j8Ptr@@3PAPAEA+4, esi
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1740 : 	x86Ptr++; 

	mov	DWORD PTR ?x86Ptr@@3PAEA, ebx		; x86Ptr
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp

; 2556 : 	return x86Ptr - 1;

	lea	eax, DWORD PTR [ebx-1]
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1007 : 	j8Ptr[2] = JMP8(0);

	mov	DWORD PTR ?j8Ptr@@3PAPAEA+8, eax
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp

; 192  : 	u32 jump = ( x86Ptr - j8 ) - 1;

	mov	eax, ebx
	sub	eax, edi
	dec	eax
	mov	DWORD PTR _jump$1$[esp+16], eax

; 193  : 
; 194  : 	if ( jump > 0x7f ) {

	cmp	eax, 127				; 0000007fH
	jbe	SHORT $LN69@CheckForBI

; 195  : 		Console::Error( "j8 greater than 0x7f!!" );

	mov	ecx, OFFSET ??_C@_0BH@PGICDMIF@j8?5greater?5than?50x7f?$CB?$CB?$AA@
	call	?Error@Console@@YA_NPBD@Z		; Console::Error
	mov	esi, DWORD PTR ?j8Ptr@@3PAPAEA+4
	mov	ebx, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
	mov	eax, DWORD PTR _jump$1$[esp+16]
$LN69@CheckForBI:

; 196  : 		assert(0);
; 197  : 	}
; 198  : 	*j8 = (u8)jump;

	mov	BYTE PTR [edi], al

; 192  : 	u32 jump = ( x86Ptr - j8 ) - 1;

	mov	eax, ebx
	sub	eax, esi
	dec	eax
	mov	DWORD PTR _jump$1$[esp+16], eax

; 193  : 
; 194  : 	if ( jump > 0x7f ) {

	cmp	eax, 127				; 0000007fH
	jbe	SHORT $LN72@CheckForBI

; 195  : 		Console::Error( "j8 greater than 0x7f!!" );

	mov	ecx, OFFSET ??_C@_0BH@PGICDMIF@j8?5greater?5than?50x7f?$CB?$CB?$AA@
	call	?Error@Console@@YA_NPBD@Z		; Console::Error
	mov	ebx, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
	mov	eax, DWORD PTR _jump$1$[esp+16]
$LN72@CheckForBI:

; 196  : 		assert(0);
; 197  : 	}
; 198  : 	*j8 = (u8)jump;

	mov	BYTE PTR [esi], al
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1745 : 	*(u16*)x86Ptr = (u16)val; 

	mov	eax, 50163				; 0000c3f3H
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1015 : 	x86SetJ8( j8Ptr[2] );

	mov	esi, DWORD PTR ?j8Ptr@@3PAPAEA+8
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1745 : 	*(u16*)x86Ptr = (u16)val; 

	mov	WORD PTR [ebx], ax

; 1746 : 	x86Ptr += 2;  

	add	ebx, 2
	mov	DWORD PTR ?x86Ptr@@3PAEA, ebx		; x86Ptr
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp

; 192  : 	u32 jump = ( x86Ptr - j8 ) - 1;

	sub	ebx, esi
	dec	ebx

; 193  : 
; 194  : 	if ( jump > 0x7f ) {

	cmp	ebx, 127				; 0000007fH
	jbe	SHORT $LN82@CheckForBI

; 195  : 		Console::Error( "j8 greater than 0x7f!!" );

	mov	ecx, OFFSET ??_C@_0BH@PGICDMIF@j8?5greater?5than?50x7f?$CB?$CB?$AA@
	call	?Error@Console@@YA_NPBD@Z		; Console::Error
$LN82@CheckForBI:
	pop	edi

; 196  : 		assert(0);
; 197  : 	}
; 198  : 	*j8 = (u8)jump;

	mov	BYTE PTR [esi], bl
	pop	esi
	pop	ebx
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1016 : }

	pop	ecx
	ret	0
?CheckForBIOSEnd@@YAXXZ ENDP				; CheckForBIOSEnd
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\icore.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ifpu.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ifpu.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ifpu.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
_TEXT	SEGMENT
?SetBranchReg@@YAXI@Z PROC				; SetBranchReg
; _reg$ = ecx

; 1021 : {

	push	esi
	mov	esi, ecx

; 1022 : 	branch = 1;

	mov	DWORD PTR ?branch@@3HA, 1		; branch

; 1023 : 
; 1024 : 	if( reg != 0xffffffff ) {

	cmp	esi, -1
	je	SHORT $LN40@SetBranchR

; 1025 : //		if( GPR_IS_CONST1(reg) )
; 1026 : //			MOV32ItoM( (uptr)&cpuRegs.pc, g_cpuConstRegs[reg].UL[0] );
; 1027 : //		else {
; 1028 : //			int mmreg;
; 1029 : //			
; 1030 : //			if( (mmreg = _checkXMMreg(XMMTYPE_GPRREG, reg, MODE_READ)) >= 0 ) {
; 1031 : //				SSE_MOVSS_XMM_to_M32((u32)&cpuRegs.pc, mmreg);
; 1032 : //			}
; 1033 : //			else if( (mmreg = _checkMMXreg(MMX_GPR+reg, MODE_READ)) >= 0 ) {
; 1034 : //				MOVDMMXtoM((u32)&cpuRegs.pc, mmreg);
; 1035 : //				SetMMXstate();
; 1036 : //			}
; 1037 : //			else {
; 1038 : //				MOV32MtoR(EAX, (int)&cpuRegs.GPR.r[ reg ].UL[ 0 ] );
; 1039 : //				MOV32RtoM((u32)&cpuRegs.pc, EAX);
; 1040 : //			}
; 1041 : //		}
; 1042 : 		_allocX86reg(ESI, X86TYPE_PCWRITEBACK, 0, MODE_WRITE);

	mov	edx, 10					; 0000000aH
	push	2
	push	0
	lea	ecx, DWORD PTR [edx-4]
	call	?_allocX86reg@@YAHHHHH@Z		; _allocX86reg
	add	esp, 8

; 1043 : 		_eeMoveGPRtoR(ESI, reg);

	mov	edx, esi
	mov	ecx, 6
	call	?_eeMoveGPRtoR@@YAXHH@Z			; _eeMoveGPRtoR

; 1044 : 
; 1045 : 		recompileNextInstruction(1);

	mov	ecx, 1
	call	?recompileNextInstruction@@YAXH@Z	; recompileNextInstruction

; 1047 : 		if( x86regs[ESI].inuse ) {

	cmp	BYTE PTR ?x86regs@@3PAU_x86regs@@A+72, 0
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	eax, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1047 : 		if( x86regs[ESI].inuse ) {

	je	SHORT $LN2@SetBranchR
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	WORD PTR [eax], 13705			; 00003589H

; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [eax+2], OFFSET ?cpuRegs@@3UcpuRegisters@@A+680

; 1762 : 	x86Ptr += 4; 

	add	eax, 6
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1050 : 			x86regs[ESI].inuse = 0;

	mov	BYTE PTR ?x86regs@@3PAU_x86regs@@A+72, 0

; 1051 : 		}
; 1052 : 		else {

	jmp	SHORT $LN194@SetBranchR
$LN2@SetBranchR:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	WORD PTR [eax], 1419			; 0000058bH

; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [eax+2], OFFSET ?g_recWriteback@@3IA ; g_recWriteback

; 1739 : 	*x86Ptr = (u8)val; 

	mov	WORD PTR [eax+6], 1417			; 00000589H

; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [eax+8], OFFSET ?cpuRegs@@3UcpuRegisters@@A+680

; 1762 : 	x86Ptr += 4; 

	add	eax, 12					; 0000000cH
$LN194@SetBranchR:
	mov	DWORD PTR ?x86Ptr@@3PAEA, eax		; x86Ptr
$LN40@SetBranchR:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1130 : 	_freeX86regs();

	call	?_freeX86regs@@YAXXZ			; _freeX86regs
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\icore.cpp

; 992  : 	for (i=0; i<XMMREGS; i++) {

	xor	esi, esi
	npad	6
$LL57@SetBranchR:

; 993  : 		if (xmmregs[i].inuse == 0) continue;

	cmp	BYTE PTR ?xmmregs@@3PAU_xmmregs@@A[esi*8], 0
	je	SHORT $LN56@SetBranchR

; 994  : 
; 995  : 		assert( xmmregs[i].type != XMMTYPE_TEMP );
; 996  : 		//assert( xmmregs[i].mode & (MODE_READ|MODE_WRITE) );
; 997  : 
; 998  : 		_freeXMMreg(i);

	mov	ecx, esi
	call	?_freeXMMreg@@YAXH@Z			; _freeXMMreg
$LN56@SetBranchR:

; 992  : 	for (i=0; i<XMMREGS; i++) {

	inc	esi
	cmp	esi, 8
	jl	SHORT $LL57@SetBranchR
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1143 : 		_flushConstRegs();

	call	?_freeMMXregs@@YAXXZ			; _freeMMXregs
	call	?_flushConstRegs@@YAXXZ			; _flushConstRegs
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ifpu.cpp

; 52   : 	if (iCWstate == 0) return;

	mov	ax, WORD PTR ?iCWstate@@3GA		; iCWstate
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	esi, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ifpu.cpp

; 52   : 	if (iCWstate == 0) return;

	test	ax, ax
	je	SHORT $LN63@SetBranchR

; 53   : 
; 54   : 	if (iCWstate & 2) {
; 55   : 		//SSE_LDMXCSR((uptr)&_mxcsrs);
; 56   : 	}
; 57   : 	if (iCWstate & 1) {

	test	al, 1
	je	SHORT $LN73@SetBranchR
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	WORD PTR [esi], 11737			; 00002dd9H

; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [esi+2], OFFSET _fpucws

; 1762 : 	x86Ptr += 4; 

	add	esi, 6
	mov	DWORD PTR ?x86Ptr@@3PAEA, esi		; x86Ptr
$LN73@SetBranchR:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ifpu.cpp

; 60   : 	iCWstate = 0;

	xor	eax, eax
	mov	WORD PTR ?iCWstate@@3GA, ax		; iCWstate
$LN63@SetBranchR:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1147 : 	if (x86FpuState==MMX_STATE) {

	cmp	WORD PTR ?x86FpuState@@3GA, 1		; x86FpuState
	jne	SHORT $LN44@SetBranchR

; 1148 : 		if (cpucaps.has3DNOWInstructionExtensions) FEMMS();

	cmp	DWORD PTR ?cpucaps@@3UCAPABILITIES@@A+136, 0
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1745 : 	*(u16*)x86Ptr = (u16)val; 

	mov	eax, 3599				; 00000e0fH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1148 : 		if (cpucaps.has3DNOWInstructionExtensions) FEMMS();

	jne	SHORT $LN195@SetBranchR
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1745 : 	*(u16*)x86Ptr = (u16)val; 

	mov	eax, 30479				; 0000770fH
$LN195@SetBranchR:
	mov	WORD PTR [esi], ax

; 1746 : 	x86Ptr += 2;  

	add	esi, 2
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1150 : 		x86FpuState=FPU_STATE;

	xor	eax, eax
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1746 : 	x86Ptr += 2;  

	mov	DWORD PTR ?x86Ptr@@3PAEA, esi		; x86Ptr
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1150 : 		x86FpuState=FPU_STATE;

	mov	WORD PTR ?x86FpuState@@3GA, ax		; x86FpuState
$LN44@SetBranchR:

; 1151 : 	}
; 1152 : }
; 1153 : 
; 1154 : //void testfpu()
; 1155 : //{
; 1156 : //	int i;
; 1157 : //	for(i = 0; i < 32; ++i ) {
; 1158 : //		if( fpuRegs.fpr[i].UL== 0x7f800000 || fpuRegs.fpr[i].UL == 0xffc00000) {
; 1159 : //			SysPrintf("bad fpu: %x %x %x\n", i, cpuRegs.cycle, g_lastpc);
; 1160 : //		}
; 1161 : //
; 1162 : //		if( VU0.VF[i].UL[0] == 0xffc00000 || //(VU0.VF[i].UL[1]&0xffc00000) == 0xffc00000 ||
; 1163 : //			VU0.VF[i].UL[0] == 0x7f800000) {
; 1164 : //			SysPrintf("bad vu0: %x %x %x\n", i, cpuRegs.cycle, g_lastpc);
; 1165 : //		}
; 1166 : //	}
; 1167 : //}
; 1168 : 
; 1169 : 
; 1170 : u32 eeScaleBlockCycles()
; 1171 : {
; 1172 : 	// Note: s_nBlockCycles is 3 bit fixed point.  Divide by 8 when done!
; 1173 : 
; 1174 : 	// Let's not scale blocks under 5-ish cycles.  This fixes countless "problems"
; 1175 : 	// caused by sync hacks and such, since games seem to care a lot more about
; 1176 : 	// these small blocks having accurate cycle counts.
; 1177 : 
; 1178 : 	if( s_nBlockCycles <= (5<<3) || (CHECK_EE_CYCLERATE == 0) )
; 1179 : 		return s_nBlockCycles >> 3;
; 1180 : 
; 1181 : 	uint scalarLow, scalarMid, scalarHigh;
; 1182 : 
; 1183 : 	// Note: larger blocks get a smaller scalar, to help keep
; 1184 : 	// them from becoming "too fat" and delaying branch tests.
; 1185 : 
; 1186 : 	switch( CHECK_EE_CYCLERATE )
; 1187 : 	{
; 1188 : 		case 0:	return s_nBlockCycles >> 3;
; 1189 : 
; 1190 : 		case 1:		// Sync hack x1.5!
; 1191 : 			scalarLow = 5;
; 1192 : 			scalarMid = 7;
; 1193 : 			scalarHigh = 5;
; 1194 : 		break;
; 1195 : 
; 1196 : 		case 2:		// Sync hack x2
; 1197 : 			scalarLow = 7;
; 1198 : 			scalarMid = 9;
; 1199 : 			scalarHigh = 7;
; 1200 : 		break;
; 1201 : 
; 1202 : 		case 3:		// Sync hack x3
; 1203 : 			scalarLow = 10;
; 1204 : 			scalarMid = 19;
; 1205 : 			scalarHigh = 10;
; 1206 : 		break;
; 1207 : 
; 1208 : 		jNO_DEFAULT
; 1209 : 	}
; 1210 : 
; 1211 : 	s_nBlockCycles *= 
; 1212 : 		(s_nBlockCycles <= (10<<3)) ? scalarLow :
; 1213 : 		((s_nBlockCycles > (21<<3)) ? scalarHigh : scalarMid );
; 1214 : 
; 1215 : 	return s_nBlockCycles >> (3+2);
; 1216 : }
; 1217 : 
; 1218 : // Generates dynarec code for Event tests followed by a block dispatch (branch).
; 1219 : // Parameters:
; 1220 : //   newpc - address to jump to at the end of the block.  If newpc == 0xffffffff then
; 1221 : //   the jump is assumed to be to a register (dynamic).  For any other value the
; 1222 : //   jump is assumed to be static, in which case the block will be "hardlinked" after
; 1223 : //   the first time it's dispatched.
; 1224 : // 
; 1225 : //   noDispatch - When set true, the jump to Dispatcher.  Used by the recs
; 1226 : //   for blocks which perform exception checks without branching (it's enabled by
; 1227 : //   setting "branch = 2";
; 1228 : static void iBranchTest(u32 newpc, bool noDispatch)
; 1229 : {
; 1230 : #ifdef _DEBUG
; 1231 : 	//CALLFunc((uptr)testfpu);
; 1232 : #endif
; 1233 : 	u32* ptr;
; 1234 : 
; 1235 : 	if( bExecBIOS ) CheckForBIOSEnd();

	cmp	DWORD PTR ?bExecBIOS@@3IA, 0		; bExecBIOS
	je	SHORT $LN87@SetBranchR
	call	?CheckForBIOSEnd@@YAXXZ			; CheckForBIOSEnd
	mov	esi, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
$LN87@SetBranchR:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	WORD PTR [esi], 1419			; 0000058bH

; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [esi+2], OFFSET ?cpuRegs@@3UcpuRegisters@@A+960
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1255 : 	ADD32ItoR(EAX, eeScaleBlockCycles());

	call	?eeScaleBlockCycles@@YAIXZ		; eeScaleBlockCycles
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp

; 1071 : 	if(from < 0x80)

	cmp	eax, 128				; 00000080H
	jae	SHORT $LN113@SetBranchR
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	WORD PTR [esi+6], 49283			; 0000c083H
	mov	BYTE PTR [esi+8], al

; 1740 : 	x86Ptr++; 

	add	esi, 9
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp

; 1077 : 	else

	jmp	SHORT $LN138@SetBranchR
$LN113@SetBranchR:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	BYTE PTR [esi+6], 5

; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [esi+7], eax

; 1762 : 	x86Ptr += 4; 

	add	esi, 11					; 0000000bH
$LN138@SetBranchR:

; 1739 : 	*x86Ptr = (u8)val; 

	mov	WORD PTR [esi], 1417			; 00000589H
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1267 : 		JS32((uptr)DispatcherReg - ( (uptr)x86Ptr + 6 ));

	mov	eax, OFFSET ?DispatcherReg@@YAXXZ	; DispatcherReg
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [esi+2], OFFSET ?cpuRegs@@3UcpuRegisters@@A+960

; 1739 : 	*x86Ptr = (u8)val; 

	mov	WORD PTR [esi+6], 1323			; 0000052bH

; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [esi+8], OFFSET ?g_nextBranchCycle@@3IA ; g_nextBranchCycle

; 1762 : 	x86Ptr += 4; 

	add	esi, 12					; 0000000cH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1267 : 		JS32((uptr)DispatcherReg - ( (uptr)x86Ptr + 6 ));

	sub	eax, esi
	sub	eax, 6
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	WORD PTR [esi], 34831			; 0000880fH

; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [esi+2], eax

; 1745 : 	*(u16*)x86Ptr = (u16)val; 

	mov	eax, 50163				; 0000c3f3H
	mov	WORD PTR [esi+6], ax

; 1746 : 	x86Ptr += 2;  

	add	esi, 8
	mov	DWORD PTR ?x86Ptr@@3PAEA, esi		; x86Ptr
	pop	esi
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1066 : }

	ret	0
?SetBranchReg@@YAXI@Z ENDP				; SetBranchReg
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
_TEXT	SEGMENT
?eeScaleBlockCycles@@YAIXZ PROC				; eeScaleBlockCycles

; 1172 : 	// Note: s_nBlockCycles is 3 bit fixed point.  Divide by 8 when done!
; 1173 : 
; 1174 : 	// Let's not scale blocks under 5-ish cycles.  This fixes countless "problems"
; 1175 : 	// caused by sync hacks and such, since games seem to care a lot more about
; 1176 : 	// these small blocks having accurate cycle counts.
; 1177 : 
; 1178 : 	if( s_nBlockCycles <= (5<<3) || (CHECK_EE_CYCLERATE == 0) )

	mov	eax, DWORD PTR ?s_nBlockCycles@@3IA	; s_nBlockCycles
	cmp	eax, 40					; 00000028H
	jbe	SHORT $LN8@eeScaleBlo
	mov	ecx, DWORD PTR ?Config@@3UPcsxConfig@@A+3608
	and	ecx, 3
	je	SHORT $LN8@eeScaleBlo
	push	esi

; 1180 : 
; 1181 : 	uint scalarLow, scalarMid, scalarHigh;
; 1182 : 
; 1183 : 	// Note: larger blocks get a smaller scalar, to help keep
; 1184 : 	// them from becoming "too fat" and delaying branch tests.
; 1185 : 
; 1186 : 	switch( CHECK_EE_CYCLERATE )

	jmp	DWORD PTR $LN17@eeScaleBlo[ecx*4]
$LN5@eeScaleBlo:

; 1187 : 	{
; 1188 : 		case 0:	return s_nBlockCycles >> 3;

	shr	eax, 3
	pop	esi

; 1216 : }

	ret	0
$LN4@eeScaleBlo:

; 1189 : 
; 1190 : 		case 1:		// Sync hack x1.5!
; 1191 : 			scalarLow = 5;

	mov	ecx, 5

; 1192 : 			scalarMid = 7;

	lea	edx, DWORD PTR [ecx+2]

; 1193 : 			scalarHigh = 5;
; 1194 : 		break;

	jmp	SHORT $LN15@eeScaleBlo
$LN3@eeScaleBlo:

; 1195 : 
; 1196 : 		case 2:		// Sync hack x2
; 1197 : 			scalarLow = 7;

	mov	ecx, 7

; 1198 : 			scalarMid = 9;

	lea	edx, DWORD PTR [ecx+2]

; 1199 : 			scalarHigh = 7;
; 1200 : 		break;

	jmp	SHORT $LN15@eeScaleBlo
$LN2@eeScaleBlo:

; 1201 : 
; 1202 : 		case 3:		// Sync hack x3
; 1203 : 			scalarLow = 10;

	mov	ecx, 10					; 0000000aH

; 1204 : 			scalarMid = 19;

	lea	edx, DWORD PTR [ecx+9]
$LN15@eeScaleBlo:

; 1205 : 			scalarHigh = 10;

	mov	esi, ecx

; 1206 : 		break;
; 1207 : 
; 1208 : 		jNO_DEFAULT
; 1209 : 	}
; 1210 : 
; 1211 : 	s_nBlockCycles *= 
; 1212 : 		(s_nBlockCycles <= (10<<3)) ? scalarLow :
; 1213 : 		((s_nBlockCycles > (21<<3)) ? scalarHigh : scalarMid );

	cmp	eax, 80					; 00000050H
	jbe	SHORT $LN13@eeScaleBlo
	cmp	eax, 168				; 000000a8H
	cmova	edx, esi
	mov	ecx, edx
$LN13@eeScaleBlo:
	imul	ecx, eax
	pop	esi
	mov	DWORD PTR ?s_nBlockCycles@@3IA, ecx	; s_nBlockCycles

; 1214 : 
; 1215 : 	return s_nBlockCycles >> (3+2);

	shr	ecx, 5
	mov	eax, ecx

; 1216 : }

	ret	0
$LN8@eeScaleBlo:

; 1179 : 		return s_nBlockCycles >> 3;

	shr	eax, 3

; 1216 : }

	ret	0
	npad	1
$LN17@eeScaleBlo:
	DD	$LN5@eeScaleBlo
	DD	$LN4@eeScaleBlo
	DD	$LN3@eeScaleBlo
	DD	$LN2@eeScaleBlo
?eeScaleBlockCycles@@YAIXZ ENDP				; eeScaleBlockCycles
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
_TEXT	SEGMENT
_ptr$ = -4						; size = 4
?iBranchTest@@YAXI_N@Z PROC				; iBranchTest
; _newpc$ = ecx
; _noDispatch$ = dl

; 1229 : {

	push	ecx

; 1230 : #ifdef _DEBUG
; 1231 : 	//CALLFunc((uptr)testfpu);
; 1232 : #endif
; 1233 : 	u32* ptr;
; 1234 : 
; 1235 : 	if( bExecBIOS ) CheckForBIOSEnd();

	cmp	DWORD PTR ?bExecBIOS@@3IA, 0		; bExecBIOS
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	bl, dl
	mov	edi, ecx
	je	SHORT $LN5@iBranchTes
	call	?CheckForBIOSEnd@@YAXXZ			; CheckForBIOSEnd
$LN5@iBranchTes:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	esi, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
	mov	WORD PTR [esi], 1419			; 0000058bH

; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [esi+2], OFFSET ?cpuRegs@@3UcpuRegisters@@A+960

; 1762 : 	x86Ptr += 4; 

	add	esi, 6
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1238 : 	if( !noDispatch && newpc != 0xffffffff )

	test	bl, bl
	jne	SHORT $LN106@iBranchTes
	cmp	edi, -1
	je	SHORT $LN106@iBranchTes
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	BYTE PTR [esi], 186			; 000000baH

; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [esi+1], 0

; 1762 : 	x86Ptr += 4; 

	add	esi, 5
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1248 : 		ptr = (u32*)(x86Ptr-4);

	lea	ebp, DWORD PTR [esi-4]
	jmp	SHORT $LN4@iBranchTes
$LN106@iBranchTes:
	mov	ebp, DWORD PTR _ptr$[esp+20]
$LN4@iBranchTes:

; 1249 : 	}
; 1250 : 
; 1251 : 	// Check the Event scheduler if our "cycle target" has been reached.
; 1252 : 	// Equiv code to:
; 1253 : 	//    cpuRegs.cycle += blockcycles;
; 1254 : 	//    if( cpuRegs.cycle > g_nextBranchCycle ) { DoEvents(); }
; 1255 : 	ADD32ItoR(EAX, eeScaleBlockCycles());

	call	?eeScaleBlockCycles@@YAIXZ		; eeScaleBlockCycles
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp

; 1071 : 	if(from < 0x80)

	cmp	eax, 128				; 00000080H
	jae	SHORT $LN31@iBranchTes
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	WORD PTR [esi], 49283			; 0000c083H
	mov	BYTE PTR [esi+2], al

; 1740 : 	x86Ptr++; 

	add	esi, 3
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp

; 1077 : 	else

	jmp	SHORT $LN56@iBranchTes
$LN31@iBranchTes:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	BYTE PTR [esi], 5

; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [esi+1], eax

; 1762 : 	x86Ptr += 4; 

	add	esi, 5
$LN56@iBranchTes:

; 1739 : 	*x86Ptr = (u8)val; 

	mov	WORD PTR [esi], 1417			; 00000589H

; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [esi+2], OFFSET ?cpuRegs@@3UcpuRegisters@@A+960

; 1739 : 	*x86Ptr = (u8)val; 

	mov	WORD PTR [esi+6], 1323			; 0000052bH

; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [esi+8], OFFSET ?g_nextBranchCycle@@3IA ; g_nextBranchCycle

; 1762 : 	x86Ptr += 4; 

	add	esi, 12					; 0000000cH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1259 : 	if( newpc != 0xffffffff )

	cmp	edi, -1
	je	SHORT $LN3@iBranchTes

; 1262 : 		*ptr = (u32)JS32((u32)Dispatcher - ( (u32)x86Ptr + 6 ));

	mov	eax, OFFSET ?Dispatcher@@YAXXZ		; Dispatcher
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	WORD PTR [esi], 34831			; 0000880fH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1262 : 		*ptr = (u32)JS32((u32)Dispatcher - ( (u32)x86Ptr + 6 ));

	sub	eax, esi
	sub	eax, 6
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [esi+2], eax

; 1762 : 	x86Ptr += 4; 

	add	esi, 6
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp

; 158  : 	return (u32*)( x86Ptr - 4 );

	lea	eax, DWORD PTR [esi-4]
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1262 : 		*ptr = (u32)JS32((u32)Dispatcher - ( (u32)x86Ptr + 6 ));

	mov	DWORD PTR [ebp], eax
	jmp	SHORT $LN100@iBranchTes
$LN3@iBranchTes:

; 1263 : 	}
; 1264 : 	else if( !noDispatch )

	test	bl, bl
	jne	SHORT $LN100@iBranchTes

; 1267 : 		JS32((uptr)DispatcherReg - ( (uptr)x86Ptr + 6 ));

	mov	eax, OFFSET ?DispatcherReg@@YAXXZ	; DispatcherReg
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	WORD PTR [esi], 34831			; 0000880fH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1267 : 		JS32((uptr)DispatcherReg - ( (uptr)x86Ptr + 6 ));

	sub	eax, esi
	sub	eax, 6
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [esi+2], eax

; 1762 : 	x86Ptr += 4; 

	add	esi, 6
$LN100@iBranchTes:

; 1741 : } 
; 1742 : 
; 1743 : __forceinline void write16(u16 val ) 
; 1744 : { 
; 1745 : 	*(u16*)x86Ptr = (u16)val; 

	mov	eax, 50163				; 0000c3f3H
	mov	WORD PTR [esi], ax

; 1746 : 	x86Ptr += 2;  

	add	esi, 2
	pop	edi
	mov	DWORD PTR ?x86Ptr@@3PAEA, esi		; x86Ptr
	pop	esi
	pop	ebp
	pop	ebx
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1271 : }

	pop	ecx
	ret	0
?iBranchTest@@YAXI_N@Z ENDP				; iBranchTest
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
_TEXT	SEGMENT
?dyna_block_discard@@YIXII@Z PROC			; dyna_block_discard
; _start$ = ecx
; _sz$ = edx

; 1528 : {

	push	esi
	push	edi
	mov	esi, edx
	mov	edi, ecx

; 1529 : 	DevCon::WriteLn("dyna_block_discard %08X , count %d", params start,sz);

	push	esi
	push	edi
	push	0
	push	OFFSET ??_C@_0CD@COAJMALJ@dyna_block_discard?5?$CF08X?5?0?5count?5@
	call	?WriteLn@Console@@YA_NPBDPBU_VARG_PARAM@@ZZ ; Console::WriteLn

; 1530 : 	Cpu->Clear(start,sz);

	mov	eax, DWORD PTR ?Cpu@@3PAUR5900cpu@@A	; Cpu
	push	esi
	push	edi
	mov	eax, DWORD PTR [eax+20]
	call	eax
	add	esp, 24					; 00000018H

; 1531 : }

	pop	edi
	pop	esi
	ret	0
?dyna_block_discard@@YIXII@Z ENDP			; dyna_block_discard
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\windows\winconsole.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\windows\winconsole.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\baseblockex.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\baseblockex.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\baseblockex.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\baseblockex.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\baseblockex.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\windows\memzero.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\icore-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\windows\memzero.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\icore.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\windows\memzero.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\icore-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\icore-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vtlb.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\windows\memzero.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\windows\memzero.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vtlb.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ir5900tables.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ir5900tables.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vtlb.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\icop2.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\icop2.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vtlb.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\memory.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vtlb.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vtlb.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\baseblockex.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\baseblockex.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\baseblockex.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\icore.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ifpu.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ifpu.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ifpu.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\icore.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ifpu.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ifpu.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ifpu.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\baseblockex.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\icore.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ifpu.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ifpu.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ifpu.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\baseblockex.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\baseblockex.h
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp
_TEXT	SEGMENT
_inpage_ptr$1$ = -60					; size = 4
_i$4$ = -60						; size = 4
_scalarHigh$1$ = -56					; size = 4
_usecop2$1$ = -56					; size = 4
_i$3$ = -56						; size = 4
_inpage_sz$ = -56					; size = 4
tv2162 = -52						; size = 4
$T1 = -52						; size = 4
_pgsz$1$ = -48						; size = 4
_inpage_offs$1$ = -48					; size = 4
tv2148 = -48						; size = 4
tv2143 = -48						; size = 4
$T2 = -48						; size = 4
_pcur$3 = -48						; size = 4
_willbranch3$1$ = -44					; size = 4
tv2161 = -40						; size = 4
tv2160 = -36						; size = 4
tv2146 = -32						; size = 4
_ptr$ = -28						; size = 4
_tmp$4 = -24						; size = 4
_tmp$5 = -20						; size = 4
_tmp$6 = -16						; size = 4
_tmp$7 = -12						; size = 4
_bsc$8 = -8						; size = 8
_startpc$ = 8						; size = 4
?recRecompile@@YAXI@Z PROC				; recRecompile

; 1534 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 64					; 00000040H
	push	esi
	push	edi
	mov	edi, DWORD PTR _startpc$[ebp]
	mov	eax, edi
	shr	eax, 16					; 00000010H
	shl	eax, 2
	mov	DWORD PTR tv2161[esp+72], eax
	movzx	eax, di
	add	eax, eax
	mov	DWORD PTR tv2160[esp+72], eax
	mov	eax, edi
	and	eax, 4095				; 00000fffH
	mov	DWORD PTR tv2146[esp+72], eax
$LN929@recRecompi:

; 1535 : 	u32 i = 0;
; 1536 : 	u32 branchTo;
; 1537 : 	u32 willbranch3 = 0;
; 1538 : 	u32* ptr;
; 1539 : 	u32 usecop2;
; 1540 : 
; 1541 : #ifdef _DEBUG
; 1542 :     //dumplog |= 4;
; 1543 :     if( dumplog & 4 )
; 1544 : 		iDumpRegisters(startpc, 0);	
; 1545 : #endif
; 1546 : 
; 1547 : 	assert( startpc );
; 1548 : 
; 1549 : 	// if recPtr reached the mem limit reset whole mem
; 1550 : 	if ( ( (uptr)recPtr - (uptr)recMem ) >= REC_CACHEMEM-0x40000 || dumplog == 0xffffffff) {

	mov	eax, DWORD PTR _recPtr
	sub	eax, DWORD PTR _recMem
	mov	esi, DWORD PTR __imp__fputs
	mov	ecx, DWORD PTR __imp__WriteConsoleA@20
	mov	DWORD PTR _willbranch3$1$[esp+72], 0
	cmp	eax, 16515072				; 00fc0000H
	jb	$LN89@recRecompi
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\windows\winconsole.cpp

; 109  : 		if (hConsole != NULL)

	mov	eax, DWORD PTR _hConsole
	test	eax, eax
	je	SHORT $LN95@recRecompi

; 110  : 		{
; 111  : 			DWORD tmp;
; 112  : 			WriteConsole(hConsole, fmt, (DWORD)strlen(fmt), &tmp, 0);

	push	0
	lea	edx, DWORD PTR _tmp$4[esp+76]
	push	edx
	push	24					; 00000018H
	push	OFFSET ??_C@_0BJ@KGMIHJML@EE?5Recompiler?5data?5reset?$AA@
	push	eax
	call	ecx
	mov	eax, DWORD PTR _hConsole
$LN95@recRecompi:

; 113  : 		}
; 114  : 
; 115  : 		// No flushing here -- only flush after newlines.
; 116  : 		if (emuLog != NULL)

	mov	ecx, DWORD PTR ?emuLog@@3PAU_iobuf@@A	; emuLog
	test	ecx, ecx
	je	SHORT $LN94@recRecompi

; 117  : 			fputs(fmt, emuLog);

	push	ecx
	push	OFFSET ??_C@_0BJ@KGMIHJML@EE?5Recompiler?5data?5reset?$AA@
	call	esi
	mov	eax, DWORD PTR _hConsole
	add	esp, 8
	mov	ecx, DWORD PTR ?emuLog@@3PAU_iobuf@@A	; emuLog
$LN94@recRecompi:

; 90   : 		if (hConsole != NULL)

	test	eax, eax
	je	SHORT $LN99@recRecompi

; 91   : 		{
; 92   : 			DWORD tmp;
; 93   : 			WriteConsole(hConsole, "\r\n", 2, &tmp, 0);

	push	0
	lea	ecx, DWORD PTR _tmp$5[esp+76]
	push	ecx
	push	2
	push	OFFSET ??_C@_02PCIJFNDE@?$AN?6?$AA@
	push	eax
	mov	eax, DWORD PTR __imp__WriteConsoleA@20
	call	eax
	mov	ecx, DWORD PTR ?emuLog@@3PAU_iobuf@@A	; emuLog
$LN99@recRecompi:

; 94   : 		}
; 95   : 
; 96   : 		if (emuLog != NULL)

	test	ecx, ecx
	je	SHORT $LN98@recRecompi

; 97   : 		{
; 98   : 			fputs("\n", emuLog);

	push	ecx
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	esi

; 99   : 			fflush( emuLog );

	push	DWORD PTR ?emuLog@@3PAU_iobuf@@A	; emuLog
	call	DWORD PTR __imp__fflush
	add	esp, 12					; 0000000cH
$LN98@recRecompi:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1552 : 		recResetEE();

	call	?recResetEE@@YAXXZ			; recResetEE
	mov	ecx, DWORD PTR __imp__WriteConsoleA@20
$LN89@recRecompi:

; 1553 : 	}
; 1554 : 	if ( ( (uptr)recStackPtr - (uptr)recStack ) >= RECSTACK_SIZE-0x100 ) {

	mov	eax, DWORD PTR _recStackPtr
	sub	eax, DWORD PTR _recStack
	cmp	eax, 65280				; 0000ff00H
	jb	SHORT $LN87@recRecompi
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\windows\winconsole.cpp

; 109  : 		if (hConsole != NULL)

	mov	eax, DWORD PTR _hConsole
	test	eax, eax
	je	SHORT $LN105@recRecompi

; 110  : 		{
; 111  : 			DWORD tmp;
; 112  : 			WriteConsole(hConsole, fmt, (DWORD)strlen(fmt), &tmp, 0);

	push	0
	lea	edx, DWORD PTR _tmp$6[esp+76]
	push	edx
	push	25					; 00000019H
	push	OFFSET ??_C@_0BK@FEKONKNL@EE?5recompiler?5stack?5reset?$AA@
	push	eax
	call	ecx
	mov	eax, DWORD PTR _hConsole
$LN105@recRecompi:

; 113  : 		}
; 114  : 
; 115  : 		// No flushing here -- only flush after newlines.
; 116  : 		if (emuLog != NULL)

	mov	ecx, DWORD PTR ?emuLog@@3PAU_iobuf@@A	; emuLog
	test	ecx, ecx
	je	SHORT $LN104@recRecompi

; 117  : 			fputs(fmt, emuLog);

	push	ecx
	push	OFFSET ??_C@_0BK@FEKONKNL@EE?5recompiler?5stack?5reset?$AA@
	call	esi
	mov	eax, DWORD PTR _hConsole
	add	esp, 8
	mov	ecx, DWORD PTR ?emuLog@@3PAU_iobuf@@A	; emuLog
$LN104@recRecompi:

; 90   : 		if (hConsole != NULL)

	test	eax, eax
	je	SHORT $LN109@recRecompi

; 91   : 		{
; 92   : 			DWORD tmp;
; 93   : 			WriteConsole(hConsole, "\r\n", 2, &tmp, 0);

	push	0
	lea	ecx, DWORD PTR _tmp$7[esp+76]
	push	ecx
	push	2
	push	OFFSET ??_C@_02PCIJFNDE@?$AN?6?$AA@
	push	eax
	mov	eax, DWORD PTR __imp__WriteConsoleA@20
	call	eax
	mov	ecx, DWORD PTR ?emuLog@@3PAU_iobuf@@A	; emuLog
$LN109@recRecompi:

; 94   : 		}
; 95   : 
; 96   : 		if (emuLog != NULL)

	test	ecx, ecx
	je	SHORT $LN108@recRecompi

; 97   : 		{
; 98   : 			fputs("\n", emuLog);

	push	ecx
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	esi

; 99   : 			fflush( emuLog );

	push	DWORD PTR ?emuLog@@3PAU_iobuf@@A	; emuLog
	call	DWORD PTR __imp__fflush
	add	esp, 12					; 0000000cH
$LN108@recRecompi:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1556 : 		recResetEE();

	call	?recResetEE@@YAXXZ			; recResetEE
$LN87@recRecompi:

; 1557 : 	}
; 1558 : 
; 1559 : 	s_pCurBlock = PC_GETBLOCK(startpc);

	mov	eax, DWORD PTR ?recLUT@@3PAIA		; recLUT
	mov	ecx, DWORD PTR tv2161[esp+72]
	mov	esi, DWORD PTR [ecx+eax]
	add	esi, DWORD PTR tv2160[esp+72]
	mov	DWORD PTR _s_pCurBlock, esi

; 1560 : 	
; 1561 : 	if( s_pCurBlock->GetFnptr() ) {

	test	DWORD PTR [esi], 268435455		; 0fffffffH
	je	SHORT $LN86@recRecompi

; 1562 : 		// clear if already taken
; 1563 : 		assert( s_pCurBlock->startpc < startpc );
; 1564 : 		recClearMem(s_pCurBlock);	

	mov	ecx, esi
	call	?recClearMem@@YAXPAUBASEBLOCK@@@Z	; recClearMem
	mov	esi, DWORD PTR _s_pCurBlock
$LN86@recRecompi:

; 1565 : 	}
; 1566 : 
; 1567 : 	if( s_pCurBlock->startpc == startpc ) {

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, edi
	jne	SHORT $LN85@recRecompi
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\baseblockex.cpp

; 133  : 	return s_vecBaseBlocksEx[cpu].blocks[s_vecBaseBlocksEx[cpu].Get(startpc)];

	push	eax
	mov	ecx, OFFSET _s_vecBaseBlocksEx
	call	?Get@BASEBLOCKS@@QAEHI@Z		; BASEBLOCKS::Get
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1568 : 		s_pCurBlockEx = PC_GETBLOCKEX(s_pCurBlock);

	mov	ecx, DWORD PTR _s_vecBaseBlocksEx
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _s_pCurBlockEx, eax

; 1569 : 		assert( s_pCurBlockEx->startpc == startpc );
; 1570 : 	}
; 1571 : 	else {

	jmp	$LN84@recRecompi
$LN85@recRecompi:

; 1572 : 		s_pCurBlockEx = NULL;
; 1573 : 		for(i = 0; i < EE_NUMBLOCKS; ++i) {

	mov	edx, DWORD PTR _recBlocks
	xor	ecx, ecx
	mov	edi, DWORD PTR _s_nNextBlock
	mov	DWORD PTR _s_pCurBlockEx, 0
	npad	10
$LL83@recRecompi:

; 1574 : 			if( recBlocks[(i+s_nNextBlock)%EE_NUMBLOCKS].size == 0 ) {

	lea	eax, DWORD PTR [edi+ecx]
	and	eax, 32767				; 00007fffH
	lea	eax, DWORD PTR [eax+eax*2]
	cmp	WORD PTR [edx+eax*8], 0
	je	SHORT $LN844@recRecompi

; 1572 : 		s_pCurBlockEx = NULL;
; 1573 : 		for(i = 0; i < EE_NUMBLOCKS; ++i) {

	inc	ecx
	cmp	ecx, 32768				; 00008000H
	jb	SHORT $LL83@recRecompi

; 2044 : 
; 2045 : 		if( pcurblock->startpc == startpc ) {

	jmp	SHORT $LN897@recRecompi
$LN844@recRecompi:

; 1575 : 				s_pCurBlockEx = recBlocks+(i+s_nNextBlock)%EE_NUMBLOCKS;

	add	ecx, edi
	mov	eax, ecx
	and	eax, 32767				; 00007fffH
	lea	eax, DWORD PTR [eax+eax*2]
	lea	edx, DWORD PTR [edx+eax*8]

; 1576 : 				s_nNextBlock = (i+s_nNextBlock+1)%EE_NUMBLOCKS;

	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR _s_pCurBlockEx, edx
	and	eax, 32767				; 00007fffH
	mov	DWORD PTR _s_nNextBlock, eax

; 1577 : 				break;
; 1578 : 			}
; 1579 : 		}
; 1580 : 
; 1581 : 		if( s_pCurBlockEx == NULL ) {

	test	edx, edx
	jne	SHORT $LN79@recRecompi
$LN897@recRecompi:

; 1582 : 			//SysPrintf("ee reset (blocks)\n");
; 1583 : 			recResetEE();

	call	?recResetEE@@YAXXZ			; recResetEE

; 1584 : 			s_nNextBlock = 0;
; 1585 : 			s_pCurBlockEx = recBlocks;

	mov	edx, DWORD PTR _recBlocks
	mov	esi, DWORD PTR _s_pCurBlock
	mov	DWORD PTR _s_nNextBlock, 0
	mov	DWORD PTR _s_pCurBlockEx, edx
$LN79@recRecompi:

; 1586 : 		}
; 1587 : 
; 1588 : 		s_pCurBlockEx->startpc = startpc;

	mov	edi, DWORD PTR _startpc$[ebp]
	mov	DWORD PTR [edx+4], edi
$LN84@recRecompi:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp

; 258  : 	x86Ptr = (u8*)( ( (uptr)x86Ptr + bytes - 1) & ~( bytes - 1 ) );

	mov	ecx, DWORD PTR _recPtr
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\baseblockex.h

; 40   : 		m_pFnptr = ptr>>4;

	mov	eax, DWORD PTR [esi]
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp

; 258  : 	x86Ptr = (u8*)( ( (uptr)x86Ptr + bytes - 1) & ~( bytes - 1 ) );

	add	ecx, 15					; 0000000fH
	and	ecx, -16				; fffffff0H
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1595 : 	s_pCurBlock->startpc = startpc;

	mov	DWORD PTR [esi+4], edi
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp

; 258  : 	x86Ptr = (u8*)( ( (uptr)x86Ptr + bytes - 1) & ~( bytes - 1 ) );

	mov	DWORD PTR ?x86Ptr@@3PAEA, ecx		; x86Ptr
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\baseblockex.h

; 40   : 		m_pFnptr = ptr>>4;

	and	eax, -268435456				; f0000000H
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1593 : 	recPtr = x86Ptr;

	mov	DWORD PTR _recPtr, ecx
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\baseblockex.h

; 40   : 		m_pFnptr = ptr>>4;

	shr	ecx, 4
	or	eax, ecx
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1597 : 	branch = 0;

	mov	DWORD PTR ?branch@@3HA, 0		; branch
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\baseblockex.h

; 40   : 		m_pFnptr = ptr>>4;

	mov	DWORD PTR [esi], eax
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1602 : 	x86FpuState = FPU_STATE;

	xor	eax, eax
	mov	DWORD PTR ?s_nBlockCycles@@3IA, 0	; s_nBlockCycles
	mov	DWORD PTR ?pc@@3IA, edi			; pc
	mov	WORD PTR ?x86FpuState@@3GA, ax		; x86FpuState

; 1603 : 	iCWstate = 0;

	mov	WORD PTR ?iCWstate@@3GA, ax		; iCWstate

; 1604 : 	s_saveConstGPRreg = 0;

	mov	DWORD PTR ?s_saveConstGPRreg@@3IA, eax	; s_saveConstGPRreg

; 1605 : 	g_cpuHasConstReg = g_cpuFlushedConstReg = 1;

	mov	DWORD PTR ?g_cpuFlushedConstReg@@3IA, 1	; g_cpuFlushedConstReg
	mov	DWORD PTR ?g_cpuHasConstReg@@3IA, 1	; g_cpuHasConstReg

; 1606 : 	g_cpuPrevRegHasLive1 = g_cpuRegHasLive1 = 0xffffffff;

	mov	DWORD PTR ?g_cpuRegHasLive1@@3IA, -1	; g_cpuRegHasLive1
	mov	DWORD PTR ?g_cpuPrevRegHasLive1@@3IA, -1 ; g_cpuPrevRegHasLive1

; 1607 : 	g_cpuPrevRegHasSignExt = g_cpuRegHasSignExt = 0;

	mov	DWORD PTR ?g_cpuRegHasSignExt@@3IA, eax	; g_cpuRegHasSignExt
	mov	DWORD PTR ?g_cpuPrevRegHasSignExt@@3IA, eax ; g_cpuPrevRegHasSignExt
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\windows\memzero.h

; 239  : 				cld;

	cld

; 240  : 				mov ecx, remdat

	mov	ecx, 24					; 00000018H

; 241  : 				mov edi, dest

	mov	edi, OFFSET ?x86regs@@3PAU_x86regs@@A	; x86regs

; 242  : 				xor eax, eax

	xor	eax, eax

; 243  : 				rep stosd

	rep	 stosd
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\icore-32.cpp

; 41   : 	g_x86AllocCounter = 0;

	xor	eax, eax
	mov	WORD PTR ?g_x86AllocCounter@@3GA, ax	; g_x86AllocCounter

; 42   : 	g_x86checknext = 0;

	mov	DWORD PTR ?g_x86checknext@@3HA, eax	; g_x86checknext
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\windows\memzero.h

; 239  : 				cld;

	cld

; 240  : 				mov ecx, remdat

	mov	ecx, 16					; 00000010H

; 241  : 				mov edi, dest

	mov	edi, OFFSET ?xmmregs@@3PAU_xmmregs@@A	; xmmregs

; 242  : 				xor eax, eax

	xor	eax, eax

; 243  : 				rep stosd

	rep	 stosd
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\icore.cpp

; 87   : 	g_xmmAllocCounter = 0;

	xor	eax, eax
	mov	WORD PTR ?g_xmmAllocCounter@@3GA, ax	; g_xmmAllocCounter

; 88   : 	s_xmmchecknext = 0;

	mov	DWORD PTR _s_xmmchecknext, eax
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\windows\memzero.h

; 239  : 				cld;

	cld

; 240  : 				mov ecx, remdat

	mov	ecx, 12					; 0000000cH

; 241  : 				mov edi, dest

	mov	edi, OFFSET ?mmxregs@@3PAU_mmxregs@@A	; mmxregs

; 242  : 				xor eax, eax

	xor	eax, eax

; 243  : 				rep stosd

	rep	 stosd
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1626 : 	i = startpc;

	mov	esi, DWORD PTR _startpc$[ebp]
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\icore-32.cpp

; 406  : 	g_mmxAllocCounter = 0;

	xor	eax, eax
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1628 : 	s_nHasDelay = 0;

	mov	edx, DWORD PTR _s_pCurBlock
	mov	edi, DWORD PTR ?recLUT@@3PAIA		; recLUT
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\icore-32.cpp

; 406  : 	g_mmxAllocCounter = 0;

	mov	WORD PTR ?g_mmxAllocCounter@@3GA, ax	; g_mmxAllocCounter

; 407  : 	s_mmxchecknext = 0;

	mov	DWORD PTR _s_mmxchecknext, eax
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1628 : 	s_nHasDelay = 0;

	mov	DWORD PTR _s_nHasDelay, eax
	npad	6
$LL78@recRecompi:

; 1629 : 	
; 1630 : 	while(1) {
; 1631 : 		BASEBLOCK* pblock = PC_GETBLOCK(i);

	mov	eax, esi
	movzx	ecx, si
	shr	eax, 16					; 00000010H
	mov	eax, DWORD PTR [edi+eax*4]

; 1632 : 		if( pblock->GetFnptr() != 0 && pblock->startpc != s_pCurBlock->startpc ) {

	test	DWORD PTR [eax+ecx*2], 268435455	; 0fffffffH
	je	SHORT $LN75@recRecompi
	mov	eax, DWORD PTR [eax+ecx*2+4]
	cmp	eax, DWORD PTR [edx+4]
	je	SHORT $LN75@recRecompi

; 1633 : 
; 1634 : 			if( i == pblock->startpc ) {

	cmp	esi, eax
	je	$LN845@recRecompi
$LN75@recRecompi:

; 1642 : 		cpuRegs.code = *(int *)PSM(i);

	mov	ecx, esi
	and	ecx, 536870911				; 1fffffffH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vtlb.cpp

; 440  : 	if (paddr>=VTLB_PMAP_SZ || pmap[paddr>>VTLB_PAGE_BITS]<0)

	cmp	ecx, 536870912				; 20000000H
	jae	SHORT $LN243@recRecompi
	mov	eax, ecx
	shr	eax, 12					; 0000000cH
	mov	eax, DWORD PTR ?pmap@vtlb_private@@3PAHA[eax*4]
	test	eax, eax
	js	SHORT $LN243@recRecompi

; 442  : 	else
; 443  : 		return reinterpret_cast<void*>(pmap[paddr>>VTLB_PAGE_BITS]+(paddr&VTLB_PAGE_MASK));

	and	ecx, 4095				; 00000fffH
	add	ecx, eax
	jmp	SHORT $LN242@recRecompi
$LN243@recRecompi:

; 441  : 		return 0;

	xor	ecx, ecx
$LN242@recRecompi:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1642 : 		cpuRegs.code = *(int *)PSM(i);

	mov	ecx, DWORD PTR [ecx]

; 1643 : 
; 1644 : 		switch(cpuRegs.code >> 26) {

	mov	eax, ecx
	shr	eax, 26					; 0000001aH
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+684, ecx
	cmp	eax, 23					; 00000017H
	ja	$LN46@recRecompi
	movzx	eax, BYTE PTR $LN900@recRecompi[eax]
	jmp	DWORD PTR $LN931@recRecompi[eax*4]
$LN72@recRecompi:

; 1645 : 			case 0: // special
; 1646 : 
; 1647 : 				if( _Funct_ == 8 || _Funct_ == 9 ) { // JR, JALR

	and	ecx, 63					; 0000003fH
	cmp	ecx, 8
	je	SHORT $LN846@recRecompi
	cmp	ecx, 9
	jne	$LN46@recRecompi
$LN846@recRecompi:

; 1648 : 					s_nEndBlock = i + 8;
; 1649 : 					s_nHasDelay = 1;

	mov	DWORD PTR _s_nHasDelay, 1
$LN54@recRecompi:

; 1685 : 				else  s_nEndBlock = i+8;

	add	esi, 8
$LN920@recRecompi:
	mov	DWORD PTR _s_nEndBlock, esi

; 1720 : 
; 1721 : 	// rec info //
; 1722 : 	{
; 1723 : 		EEINST* pcur;
; 1724 : 
; 1725 : 		if( s_nInstCacheSize < (s_nEndBlock-startpc)/4+1 ) {

	sub	esi, DWORD PTR _startpc$[ebp]
	shr	esi, 2
$StartRecomp$934:
	lea	eax, DWORD PTR [esi+1]
	cmp	DWORD PTR _s_nInstCacheSize, eax
	jae	$LN901@recRecompi

; 1726 : 			free(s_pInstCache);

	push	DWORD PTR _s_pInstCache
	call	DWORD PTR __imp__free

; 1727 : 			s_nInstCacheSize = (s_nEndBlock-startpc)/4+10;

	lea	eax, DWORD PTR [esi+10]
	add	esp, 4
	mov	DWORD PTR _s_nInstCacheSize, eax

; 1728 : 			s_pInstCache = (EEINST*)malloc(sizeof(EEINST)*s_nInstCacheSize);

	imul	eax, eax, 112
	push	eax
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	DWORD PTR _s_pInstCache, eax
	jmp	$LN40@recRecompi
$LN68@recRecompi:

; 1650 : 					goto StartRecomp;
; 1651 : 				}
; 1652 : 
; 1653 : 				break;
; 1654 : 			case 1: // regimm
; 1655 : 				
; 1656 : 				if( _Rt_ < 4 || (_Rt_ >= 16 && _Rt_ < 20) ) {

	mov	eax, ecx
	shr	eax, 16					; 00000010H
	and	eax, 31					; 0000001fH
	cmp	eax, 4
	jb	SHORT $LN847@recRecompi
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN46@recRecompi
	cmp	eax, 20					; 00000014H
	jae	SHORT $LN46@recRecompi
$LN847@recRecompi:

; 1657 : 					// branches
; 1658 : 					if( _Rt_ == 2 || _Rt_ == 3 || _Rt_ == 18 || _Rt_ == 19 ) s_nHasDelay = 1;

	mov	eax, ecx
	shr	eax, 16					; 00000010H
	and	eax, 31					; 0000001fH
	cmp	eax, 2
	je	SHORT $LN64@recRecompi
	cmp	eax, 3
	je	SHORT $LN64@recRecompi
	cmp	eax, 18					; 00000012H
	je	SHORT $LN64@recRecompi

; 1659 : 					else s_nHasDelay = 2;

	mov	DWORD PTR _s_nHasDelay, 2
	cmp	eax, 19					; 00000013H
	jne	SHORT $LN63@recRecompi
$LN64@recRecompi:

; 1657 : 					// branches
; 1658 : 					if( _Rt_ == 2 || _Rt_ == 3 || _Rt_ == 18 || _Rt_ == 19 ) s_nHasDelay = 1;

	mov	DWORD PTR _s_nHasDelay, 1
$LN63@recRecompi:

; 1660 : 
; 1661 : 					branchTo = _Imm_ * 4 + i + 4;

	movsx	eax, cx
	inc	eax
	lea	eax, DWORD PTR [esi+eax*4]

; 1662 : 					if( branchTo > startpc && branchTo < i ) s_nEndBlock = branchTo;

	cmp	eax, DWORD PTR _startpc$[ebp]
	jbe	$LN54@recRecompi
	cmp	eax, esi
	jae	$LN54@recRecompi
	mov	esi, eax
	jmp	$LN920@recRecompi
$LN51@recRecompi:

; 1686 : 				
; 1687 : 				goto StartRecomp;
; 1688 : 
; 1689 : 			case 16: // cp0
; 1690 : 				if( _Rs_ == 16 ) {

	mov	eax, ecx
	and	eax, 65011712				; 03e00000H
	cmp	eax, 33554432				; 02000000H
	jne	SHORT $LN49@recRecompi

; 1691 : 					if( _Funct_ == 24 ) { // eret

	mov	eax, ecx
	and	eax, 63					; 0000003fH
	cmp	al, 24					; 00000018H
	je	SHORT $LN848@recRecompi
$LN49@recRecompi:

; 1693 : 						goto StartRecomp;
; 1694 : 					}
; 1695 : 				}
; 1696 : 				// Fall through!
; 1697 : 				// COP0's branch opcodes line up with COP1 and COP2's
; 1698 : 
; 1699 : 			case 17: // cp1
; 1700 : 			case 18: // cp2
; 1701 : 				if( _Rs_ == 8 ) {

	mov	eax, ecx
	and	eax, 65011712				; 03e00000H
	cmp	eax, 16777216				; 01000000H
	je	SHORT $LN849@recRecompi
$LN46@recRecompi:

; 1709 : 					else  s_nEndBlock = i+8;
; 1710 : 					
; 1711 : 					goto StartRecomp;
; 1712 : 				}
; 1713 : 				break;
; 1714 : 		}
; 1715 : 
; 1716 : 		i += 4;

	add	esi, 4

; 1717 : 	}

	jmp	$LL78@recRecompi
$LN845@recRecompi:

; 1635 : 				// branch = 3
; 1636 : 				willbranch3 = 1;

	mov	DWORD PTR _willbranch3$1$[esp+72], 1

; 1718 : 
; 1719 : StartRecomp:

	jmp	$LN920@recRecompi
$LN848@recRecompi:

; 1692 : 						s_nEndBlock = i+4;

	add	esi, 4

; 1718 : 
; 1719 : StartRecomp:

	jmp	$LN920@recRecompi
$LN849@recRecompi:

; 1702 : 					// BC1F, BC1T, BC1FL, BC1TL
; 1703 : 					// BC2F, BC2T, BC2FL, BC2TL
; 1704 : 					if( _Rt_ >= 2 ) s_nHasDelay = 1;

	mov	eax, ecx
	and	eax, 2031616				; 001f0000H
	cmp	eax, 131072				; 00020000H
	sbb	eax, eax
	neg	eax
	inc	eax
	mov	DWORD PTR _s_nHasDelay, eax

; 1705 : 					else s_nHasDelay = 2;
; 1706 : 
; 1707 : 					branchTo = _Imm_ * 4 + i + 4;
; 1708 : 					if( branchTo > startpc && branchTo < i ) s_nEndBlock = branchTo;

	jmp	SHORT $LN63@recRecompi
$LN57@recRecompi:

; 1663 : 					else  s_nEndBlock = i+8;
; 1664 : 
; 1665 : 					goto StartRecomp;
; 1666 : 				}
; 1667 : 
; 1668 : 				break;
; 1669 : 
; 1670 : 			case 2: // J
; 1671 : 			case 3: // JAL
; 1672 : 				s_nHasDelay = 1;
; 1673 : 				s_nEndBlock = i + 8;
; 1674 : 				goto StartRecomp;
; 1675 : 
; 1676 : 			// branches
; 1677 : 			case 4: case 5: case 6: case 7: 
; 1678 : 			case 20: case 21: case 22: case 23:
; 1679 : 
; 1680 : 				if( (cpuRegs.code >> 26) >= 20 ) s_nHasDelay = 1;

	mov	eax, ecx
	and	eax, -67108864				; fc000000H
	cmp	eax, 1342177280				; 50000000H
	sbb	eax, eax
	neg	eax
	inc	eax
	mov	DWORD PTR _s_nHasDelay, eax

; 1681 : 				else s_nHasDelay = 2;
; 1682 : 
; 1683 : 				branchTo = _Imm_ * 4 + i + 4;
; 1684 : 				if( branchTo > startpc && branchTo < i ) s_nEndBlock = branchTo;

	jmp	$LN63@recRecompi
$LN901@recRecompi:

; 1728 : 			s_pInstCache = (EEINST*)malloc(sizeof(EEINST)*s_nInstCacheSize);

	mov	eax, DWORD PTR _s_pInstCache
$LN40@recRecompi:

; 1729 : 			assert( s_pInstCache != NULL );
; 1730 : 		}
; 1731 : 
; 1732 : 		pcur = s_pInstCache + (s_nEndBlock-startpc)/4;

	imul	edx, esi, 112
	add	edx, eax
	mov	DWORD PTR _pcur$3[esp+72], edx
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\windows\memzero.h

; 239  : 				cld;

	cld

; 240  : 				mov ecx, remdat

	mov	ecx, 28					; 0000001cH

; 241  : 				mov edi, dest

	mov	edi, DWORD PTR _pcur$3[esp+72]

; 242  : 				xor eax, eax

	xor	eax, eax

; 243  : 				rep stosd

	rep	 stosd

; 260  : 		memset( dest, data, bytes );

	movdqa	xmm0, XMMWORD PTR __xmm@07070707070707070707070707070707
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1736 : 		for(i = s_nEndBlock; i > startpc; i -= 4 ) {

	mov	esi, DWORD PTR _s_nEndBlock
	mov	ecx, DWORD PTR _startpc$[ebp]
	mov	DWORD PTR _i$3$[esp+72], esi
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\windows\memzero.h

; 260  : 		memset( dest, data, bytes );

	movdqu	XMMWORD PTR [edx], xmm0
	movdqu	XMMWORD PTR [edx+16], xmm0
	mov	WORD PTR [edx+32], 117901063		; 07070707H
	movdqa	xmm0, XMMWORD PTR __xmm@01010101010101010101010101010101
	movdqu	XMMWORD PTR [edx+34], xmm0
	movdqu	XMMWORD PTR [edx+50], xmm0
	mov	WORD PTR [edx+66], 1
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1736 : 		for(i = s_nEndBlock; i > startpc; i -= 4 ) {

	cmp	esi, ecx
	jbe	$LN37@recRecompi
	npad	9
$LL39@recRecompi:

; 1737 : 			cpuRegs.code = *(int *)PSM(i-4);

	lea	ecx, DWORD PTR [esi-4]
	and	ecx, 536870911				; 1fffffffH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vtlb.cpp

; 440  : 	if (paddr>=VTLB_PMAP_SZ || pmap[paddr>>VTLB_PAGE_BITS]<0)

	cmp	ecx, 536870912				; 20000000H
	jae	SHORT $LN303@recRecompi
	mov	eax, ecx
	shr	eax, 12					; 0000000cH
	mov	eax, DWORD PTR ?pmap@vtlb_private@@3PAHA[eax*4]
	test	eax, eax
	js	SHORT $LN303@recRecompi

; 442  : 	else
; 443  : 		return reinterpret_cast<void*>(pmap[paddr>>VTLB_PAGE_BITS]+(paddr&VTLB_PAGE_MASK));

	and	ecx, 4095				; 00000fffH
	add	ecx, eax
	jmp	SHORT $LN302@recRecompi
$LN303@recRecompi:

; 441  : 		return 0;

	xor	ecx, ecx
$LN302@recRecompi:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1737 : 			cpuRegs.code = *(int *)PSM(i-4);

	mov	eax, DWORD PTR [ecx]

; 1738 : 			pcur[-1] = pcur[0];

	mov	esi, edx
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+684, eax
	mov	ecx, 28					; 0000001cH
	lea	eax, DWORD PTR [edx-112]
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ir5900tables.cpp

; 92   : {

	mov	DWORD PTR _bsc$8[esp+76], edx
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1738 : 			pcur[-1] = pcur[0];

	mov	edi, eax
	mov	DWORD PTR tv2148[esp+72], eax
	rep movsd

; 1741 : 			bsc.rprop();

	lea	ecx, DWORD PTR _bsc$8[esp+72]
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ir5900tables.cpp

; 92   : {

	mov	DWORD PTR _bsc$8[esp+72], eax
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1741 : 			bsc.rprop();

	call	?rprop@BSCPropagate@@QAEXXZ		; BSCPropagate::rprop
	mov	esi, DWORD PTR _i$3$[esp+72]
	mov	ecx, DWORD PTR _startpc$[ebp]
	sub	esi, 4

; 1742 : 			pcur--;

	mov	edx, DWORD PTR tv2148[esp+72]
	mov	DWORD PTR _i$3$[esp+72], esi
	cmp	esi, ecx
	ja	SHORT $LL39@recRecompi

; 1736 : 		for(i = s_nEndBlock; i > startpc; i -= 4 ) {

	mov	esi, DWORD PTR _s_nEndBlock
$LN37@recRecompi:

; 1743 : 		}
; 1744 : 	}
; 1745 : 
; 1746 : 	// analyze instructions //
; 1747 : 	{
; 1748 : 		usecop2 = 0;
; 1749 : 		g_pCurInstInfo = s_pInstCache;

	mov	edi, DWORD PTR _s_pInstCache
	xor	edx, edx
	mov	DWORD PTR _usecop2$1$[esp+72], edx

; 1750 : 
; 1751 : 		for(i = startpc; i < s_nEndBlock; i += 4) {

	mov	eax, ecx
	mov	DWORD PTR ?g_pCurInstInfo@@3PAUEEINST@@A, edi ; g_pCurInstInfo
	mov	DWORD PTR _i$4$[esp+72], ecx
	cmp	ecx, esi
	jae	$LN29@recRecompi
$LL36@recRecompi:

; 1753 : 			cpuRegs.code = *(u32*)PSM(i);

	mov	ecx, eax
	add	edi, 112				; 00000070H
	and	ecx, 536870911				; 1fffffffH
	mov	DWORD PTR ?g_pCurInstInfo@@3PAUEEINST@@A, edi ; g_pCurInstInfo
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vtlb.cpp

; 440  : 	if (paddr>=VTLB_PMAP_SZ || pmap[paddr>>VTLB_PAGE_BITS]<0)

	cmp	ecx, 536870912				; 20000000H
	jae	SHORT $LN310@recRecompi
	mov	eax, ecx
	shr	eax, 12					; 0000000cH
	mov	eax, DWORD PTR ?pmap@vtlb_private@@3PAHA[eax*4]
	test	eax, eax
	js	SHORT $LN310@recRecompi

; 442  : 	else
; 443  : 		return reinterpret_cast<void*>(pmap[paddr>>VTLB_PAGE_BITS]+(paddr&VTLB_PAGE_MASK));

	and	ecx, 4095				; 00000fffH
	add	ecx, eax
	jmp	SHORT $LN309@recRecompi
$LN310@recRecompi:

; 441  : 		return 0;

	xor	ecx, ecx
$LN309@recRecompi:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1753 : 			cpuRegs.code = *(u32*)PSM(i);

	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+684, ecx

; 1754 : 
; 1755 : 			// cop2 //
; 1756 : 			if( g_pCurInstInfo->info & EEINSTINFO_COP2 ) {

	test	BYTE PTR [edi+67], 2
	je	SHORT $LN33@recRecompi

; 1757 : 
; 1758 : 				if( !usecop2 ) {

	test	edx, edx
	jne	SHORT $LN32@recRecompi

; 1759 : 					// init
; 1760 : 					vucycle = 0;

	mov	DWORD PTR ?vucycle@@3HA, edx		; vucycle

; 1761 : 					usecop2 = 1;

	mov	DWORD PTR _usecop2$1$[esp+72], 1
$LN32@recRecompi:

; 1762 : 				}
; 1763 : 				
; 1764 : 				VU0.code = cpuRegs.code;

	mov	DWORD PTR ?VU0@@3UVURegs@@A+1108, ecx

; 1765 : 				_vuRegsCOP22( &VU0, &g_pCurInstInfo->vuregs );

	lea	eax, DWORD PTR [edi+88]
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\icop2.cpp

; 627  : 	_vuRegsCOP2t[_Rs_](VU, VUregsn);

	shr	ecx, 21					; 00000015H
	and	ecx, 31					; 0000001fH
	push	eax
	push	OFFSET ?VU0@@3UVURegs@@A		; VU0
	mov	eax, DWORD PTR ?_vuRegsCOP2t@@3PAP6AXPAUVURegs@@PAU_VURegsNum@@@ZA[ecx*4]
	call	eax
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1766 : 				continue;

	mov	esi, DWORD PTR _s_nEndBlock
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\icop2.cpp

; 627  : 	_vuRegsCOP2t[_Rs_](VU, VUregsn);

	add	esp, 8
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1766 : 				continue;

	mov	edi, DWORD PTR ?g_pCurInstInfo@@3PAUEEINST@@A ; g_pCurInstInfo
	mov	edx, DWORD PTR _usecop2$1$[esp+72]
	jmp	SHORT $LN35@recRecompi
$LN33@recRecompi:

; 1767 : 			}
; 1768 : 
; 1769 : 			// fixme - This should be based on the cycle count of the current EE
; 1770 : 			// instruction being analyzed.
; 1771 : 			if( usecop2 ) vucycle++;

	test	edx, edx
	je	SHORT $LN35@recRecompi
	inc	DWORD PTR ?vucycle@@3HA			; vucycle
$LN35@recRecompi:

; 1750 : 
; 1751 : 		for(i = startpc; i < s_nEndBlock; i += 4) {

	mov	eax, DWORD PTR _i$4$[esp+72]
	add	eax, 4
	mov	DWORD PTR _i$4$[esp+72], eax
	cmp	eax, esi
	jb	$LL36@recRecompi

; 1772 : 
; 1773 : 			// peephole optimizations //
; 1774 : #ifdef PCSX2_VM_COISSUE
; 1775 : 			if( i < s_nEndBlock-4 && recompileCodeSafe(i) ) {
; 1776 : 				u32 curcode = cpuRegs.code;
; 1777 : 				u32 nextcode = *(u32*)PSM(i+4);
; 1778 : 				if( _eeIsLoadStoreCoIssue(curcode, nextcode) && recBSC_co[curcode>>26] != NULL ) {
; 1779 : 
; 1780 : 					// rs has to be the same, and cannot be just written
; 1781 : 					if( ((curcode >> 21) & 0x1F) == ((nextcode >> 21) & 0x1F) && !_eeLoadWritesRs(curcode) ) {
; 1782 : 
; 1783 : 						if( _eeIsLoadStoreCoX(curcode) && ((nextcode>>16)&0x1f) != ((curcode>>21)&0x1f) ) {
; 1784 : 							// see how many stores there are
; 1785 : 							u32 j;
; 1786 : 							// use xmmregs since only supporting lwc1,lq,swc1,sq
; 1787 : 							for(j = i+8; j < s_nEndBlock && j < i+4*XMMREGS; j += 4 ) {
; 1788 : 								u32 nncode = *(u32*)PSM(j);
; 1789 : 								if( (nncode>>26) != (curcode>>26) || ((curcode>>21)&0x1f) != ((nncode>>21)&0x1f) ||
; 1790 : 									_eeLoadWritesRs(nncode))
; 1791 : 									break;
; 1792 : 							}
; 1793 : 
; 1794 : 							if( j > i+8 ) {
; 1795 : 								u32 num = (j-i)>>2; // number of stores that can coissue
; 1796 : 								assert( num <= XMMREGS );
; 1797 : 
; 1798 : 								g_pCurInstInfo[0].numpeeps = num-1;
; 1799 : 								g_pCurInstInfo[0].info |= EEINSTINFO_COREC;
; 1800 : 
; 1801 : 								while(i < j-4) {
; 1802 : 									g_pCurInstInfo++;
; 1803 : 									g_pCurInstInfo[0].info |= EEINSTINFO_NOREC;
; 1804 : 									i += 4;	
; 1805 : 								}
; 1806 : 
; 1807 : 								continue;
; 1808 : 							}
; 1809 : 
; 1810 : 							// fall through
; 1811 : 						}
; 1812 : 
; 1813 : 						// unaligned loadstores
; 1814 : 
; 1815 : 						// if LWL, check if LWR and that offsets are +3 away
; 1816 : 						switch(curcode >> 26) {
; 1817 : 							case 0x22: // LWL
; 1818 : 								if( (nextcode>>26) != 0x26 || ((s16)nextcode)+3 != (s16)curcode )
; 1819 : 									continue;
; 1820 : 								break;
; 1821 : 							case 0x26: // LWR
; 1822 : 								if( (nextcode>>26) != 0x22 || ((s16)nextcode) != (s16)curcode+3 )
; 1823 : 									continue;
; 1824 : 								break;
; 1825 : 
; 1826 : 							case 0x2a: // SWL
; 1827 : 								if( (nextcode>>26) != 0x2e || ((s16)nextcode)+3 != (s16)curcode )
; 1828 : 									continue;
; 1829 : 								break;
; 1830 : 							case 0x2e: // SWR
; 1831 : 								if( (nextcode>>26) != 0x2a || ((s16)nextcode) != (s16)curcode+3 )
; 1832 : 									continue;
; 1833 : 								break;
; 1834 : 
; 1835 : 							case 0x1a: // LDL
; 1836 : 								if( (nextcode>>26) != 0x1b || ((s16)nextcode)+7 != (s16)curcode )
; 1837 : 									continue;
; 1838 : 								break;
; 1839 : 							case 0x1b: // LWR
; 1840 : 								if( (nextcode>>26) != 0x1aa || ((s16)nextcode) != (s16)curcode+7 )
; 1841 : 									continue;
; 1842 : 								break;
; 1843 : 
; 1844 : 							case 0x2c: // SWL
; 1845 : 								if( (nextcode>>26) != 0x2d || ((s16)nextcode)+7 != (s16)curcode )
; 1846 : 									continue;
; 1847 : 								break;
; 1848 : 							case 0x2d: // SWR
; 1849 : 								if( (nextcode>>26) != 0x2c || ((s16)nextcode) != (s16)curcode+7 )
; 1850 : 									continue;
; 1851 : 								break;
; 1852 : 						}
; 1853 : 						
; 1854 : 						// good enough
; 1855 : 						g_pCurInstInfo[0].info |= EEINSTINFO_COREC;
; 1856 : 						g_pCurInstInfo[0].numpeeps = 1;
; 1857 : 						g_pCurInstInfo[1].info |= EEINSTINFO_NOREC;
; 1858 : 						g_pCurInstInfo++;
; 1859 : 						i += 4;
; 1860 : 						continue;
; 1861 : 					}
; 1862 : 				}
; 1863 : 			}
; 1864 : #endif // end peephole
; 1865 : 		}
; 1866 : 		// This *is* important because g_pCurInstInfo is checked a bit later on and
; 1867 : 		// if it's not equal to s_pInstCache it handles recompilation differently.
; 1868 : 		// ... but the empty if() conditional inside the for loop is still amusing. >_<
; 1869 : 		if( usecop2 ) {
; 1870 : 			// add necessary mac writebacks
; 1871 : 			g_pCurInstInfo = s_pInstCache;

	mov	edi, DWORD PTR _s_pInstCache

; 1872 : 
; 1873 : 			for(i = startpc; i < s_nEndBlock-4; i += 4) {

	mov	ecx, DWORD PTR _startpc$[ebp]
	test	edx, edx
	je	SHORT $LN29@recRecompi
	lea	eax, DWORD PTR [esi-4]
	mov	DWORD PTR ?g_pCurInstInfo@@3PAUEEINST@@A, edi ; g_pCurInstInfo
	cmp	ecx, eax
	jae	SHORT $LN29@recRecompi
	sub	eax, ecx
	dec	eax
	shr	eax, 2
	inc	eax
	imul	eax, eax, 112
	add	eax, edi
	mov	DWORD PTR ?g_pCurInstInfo@@3PAUEEINST@@A, eax ; g_pCurInstInfo
$LN29@recRecompi:

; 1874 : 				g_pCurInstInfo++;
; 1875 : 
; 1876 : 				if( g_pCurInstInfo->info & EEINSTINFO_COP2 ) {
; 1877 : 				}
; 1878 : 			}
; 1879 : 		}
; 1880 : 	}
; 1881 : 
; 1882 : #ifdef _DEBUG
; 1883 : 	// dump code
; 1884 : 	for(i = 0; i < ARRAYSIZE(s_recblocks); ++i) {
; 1885 : 		if( startpc == s_recblocks[i] ) {
; 1886 : 			iDumpBlock(startpc, recPtr);
; 1887 : 		}
; 1888 : 	}
; 1889 : 
; 1890 : 	if( (dumplog & 1) ) //|| usecop2 )
; 1891 : 		iDumpBlock(startpc, recPtr);
; 1892 : #endif
; 1893 : 
; 1894 : 	u32 sz=(s_nEndBlock-startpc)>>2;
; 1895 : #ifdef lulz
; 1896 : 	/*
; 1897 : 		Block checking (ADDED BY RAZ-TEMP)
; 1898 : 	*/
; 1899 : 	
; 1900 : 	MOV32ItoR(ECX,startpc);
; 1901 : 	MOV32ItoR(EDX,sz);
; 1902 : 
; 1903 : #endif
; 1904 : 
; 1905 : 	u32 inpage_offs=startpc&0xFFF;

	mov	edx, DWORD PTR tv2146[esp+72]
	mov	eax, esi
	sub	eax, ecx
	mov	DWORD PTR _inpage_offs$1$[esp+72], edx
	shr	eax, 2

; 1906 : 	u32 inpage_ptr=startpc;

	mov	DWORD PTR _inpage_ptr$1$[esp+72], ecx
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1761 : 	*(u32*)x86Ptr = val; 

	mov	ecx, DWORD PTR _startpc$[ebp]
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1907 : 	u32 inpage_sz=sz*4;

	lea	edx, DWORD PTR [eax*4]
	mov	DWORD PTR _inpage_sz$[esp+72], edx
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	edx, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
	mov	BYTE PTR [edx], 185			; 000000b9H

; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [edx+1], ecx
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1912 : 	while(inpage_sz)

	mov	ecx, DWORD PTR _inpage_ptr$1$[esp+72]
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	BYTE PTR [edx+5], 186			; 000000baH

; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [edx+6], eax

; 1762 : 	x86Ptr += 4; 

	add	edx, 10					; 0000000aH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1912 : 	while(inpage_sz)

	cmp	DWORD PTR _inpage_sz$[esp+72], 0
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1762 : 	x86Ptr += 4; 

	mov	DWORD PTR ?x86Ptr@@3PAEA, edx		; x86Ptr
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1912 : 	while(inpage_sz)

	je	$LN24@recRecompi
	npad	1
$LL25@recRecompi:

; 1913 : 	{
; 1914 : 		int PageType=mmap_GetRamPageInfo((u32*)PSM(inpage_ptr));

	mov	esi, ecx
	and	esi, 536870911				; 1fffffffH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vtlb.cpp

; 440  : 	if (paddr>=VTLB_PMAP_SZ || pmap[paddr>>VTLB_PAGE_BITS]<0)

	cmp	esi, 536870912				; 20000000H
	jae	SHORT $LN333@recRecompi
	mov	eax, esi
	shr	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR ?pmap@vtlb_private@@3PAHA[eax*4]
	test	ecx, ecx
	js	SHORT $LN333@recRecompi

; 442  : 	else
; 443  : 		return reinterpret_cast<void*>(pmap[paddr>>VTLB_PAGE_BITS]+(paddr&VTLB_PAGE_MASK));

	mov	eax, esi
	and	eax, 4095				; 00000fffH
	add	eax, ecx
	jmp	SHORT $LN332@recRecompi
$LN333@recRecompi:

; 441  : 		return 0;

	xor	eax, eax
$LN332@recRecompi:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\memory.cpp

; 830  : 	u32 offset=((u8*)ptr-psM);

	sub	eax, DWORD PTR ?psM@@3PAEA		; psM

; 831  : 	if (offset>=Ps2MemSize::Base)

	cmp	eax, 33554432				; 02000000H
	jb	SHORT $LN337@recRecompi

; 832  : 		return -1; //not in ram, no tracking done ...

	or	edi, -1
	jmp	SHORT $LN338@recRecompi
$LN337@recRecompi:

; 833  : 	offset>>=12;

	shr	eax, 12					; 0000000cH

; 834  : 	return (psMPWC[(offset/32)]&(1<<(offset&31)))?1:0;

	mov	edi, 1
	mov	ecx, eax
	shr	eax, 5
	and	ecx, 31					; 0000001fH
	shl	edi, cl
	and	edi, DWORD PTR ?psMPWC@@3PAIA[eax*4]
	neg	edi
	sbb	edi, edi
	neg	edi
$LN338@recRecompi:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1915 : 		u32 pgsz=std::min(0x1000-inpage_offs,inpage_sz);

	mov	eax, 4096				; 00001000H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 4121 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	lea	ecx, DWORD PTR _inpage_sz$[esp+72]
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1915 : 		u32 pgsz=std::min(0x1000-inpage_offs,inpage_sz);

	sub	eax, DWORD PTR _inpage_offs$1$[esp+72]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 4121 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmp	DWORD PTR _inpage_sz$[esp+72], eax
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1915 : 		u32 pgsz=std::min(0x1000-inpage_offs,inpage_sz);

	mov	DWORD PTR tv2143[esp+72], eax
	mov	DWORD PTR $T1[esp+72], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 4121 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	lea	eax, DWORD PTR $T1[esp+72]
	cmovae	ecx, eax
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1915 : 		u32 pgsz=std::min(0x1000-inpage_offs,inpage_sz);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR _pgsz$1$[esp+72], eax

; 1916 : 
; 1917 : 		if(PageType!=-1)

	cmp	edi, -1
	je	$LN19@recRecompi

; 1918 : 		{
; 1919 : 			if (PageType==0)

	test	edi, edi
	jne	SHORT $LN22@recRecompi
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vtlb.cpp

; 440  : 	if (paddr>=VTLB_PMAP_SZ || pmap[paddr>>VTLB_PAGE_BITS]<0)

	cmp	esi, 536870912				; 20000000H
	jae	SHORT $LN343@recRecompi
	mov	eax, esi
	shr	eax, 12					; 0000000cH
	mov	eax, DWORD PTR ?pmap@vtlb_private@@3PAHA[eax*4]
	test	eax, eax
	js	SHORT $LN343@recRecompi

; 442  : 	else
; 443  : 		return reinterpret_cast<void*>(pmap[paddr>>VTLB_PAGE_BITS]+(paddr&VTLB_PAGE_MASK));

	and	esi, 4095				; 00000fffH
	add	esi, eax
	jmp	SHORT $LN342@recRecompi
$LN343@recRecompi:

; 441  : 		return 0;

	xor	esi, esi
$LN342@recRecompi:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1925 : 				mmap_MarkCountedRamPage(PSM(inpage_ptr),inpage_ptr&~0xFFF);

	mov	edx, DWORD PTR _inpage_ptr$1$[esp+72]
	mov	ecx, esi
	and	edx, -4096				; fffff000H
	call	?mmap_MarkCountedRamPage@@YAXPAXI@Z	; mmap_MarkCountedRamPage

; 1926 : 			}
; 1927 : 			else

	mov	edx, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
	jmp	$LN921@recRecompi
$LN22@recRecompi:

; 1928 : 			{
; 1929 : 				u32 lpc=inpage_ptr;

	mov	edi, DWORD PTR _inpage_ptr$1$[esp+72]

; 1931 : 				while(stg>0)

	test	eax, eax
	je	$LN19@recRecompi

; 1928 : 			{
; 1929 : 				u32 lpc=inpage_ptr;

	dec	eax
	shr	eax, 2
	inc	eax
	mov	DWORD PTR tv2162[esp+72], eax
	npad	10
$LL20@recRecompi:

; 1934 : 					CMP32ItoM((uptr)PSM(lpc),*(u32*)PSM(lpc));

	mov	ecx, edi
	and	ecx, 536870911				; 1fffffffH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\vtlb.cpp

; 440  : 	if (paddr>=VTLB_PMAP_SZ || pmap[paddr>>VTLB_PAGE_BITS]<0)

	cmp	ecx, 536870912				; 20000000H
	jae	SHORT $LN348@recRecompi
	mov	eax, ecx
	shr	eax, 12					; 0000000cH
	mov	eax, DWORD PTR ?pmap@vtlb_private@@3PAHA[eax*4]
	test	eax, eax
	js	SHORT $LN348@recRecompi

; 442  : 	else
; 443  : 		return reinterpret_cast<void*>(pmap[paddr>>VTLB_PAGE_BITS]+(paddr&VTLB_PAGE_MASK));

	mov	esi, ecx
	and	esi, 4095				; 00000fffH
	add	esi, eax
	jmp	SHORT $LN347@recRecompi
$LN348@recRecompi:

; 441  : 		return 0;

	xor	esi, esi
$LN347@recRecompi:

; 440  : 	if (paddr>=VTLB_PMAP_SZ || pmap[paddr>>VTLB_PAGE_BITS]<0)

	cmp	ecx, 536870912				; 20000000H
	jae	SHORT $LN353@recRecompi
	mov	eax, ecx
	shr	eax, 12					; 0000000cH
	mov	eax, DWORD PTR ?pmap@vtlb_private@@3PAHA[eax*4]
	test	eax, eax
	js	SHORT $LN353@recRecompi

; 442  : 	else
; 443  : 		return reinterpret_cast<void*>(pmap[paddr>>VTLB_PAGE_BITS]+(paddr&VTLB_PAGE_MASK));

	and	ecx, 4095				; 00000fffH
	add	ecx, eax
	jmp	SHORT $LN352@recRecompi
$LN353@recRecompi:

; 441  : 		return 0;

	xor	ecx, ecx
$LN352@recRecompi:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1934 : 					CMP32ItoM((uptr)PSM(lpc),*(u32*)PSM(lpc));

	mov	eax, DWORD PTR [esi]

; 1936 : 
; 1937 : 					stg-=4;
; 1938 : 					lpc+=4;

	add	edi, 4
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	WORD PTR [edx], 15745			; 00003d81H

; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [edx+2], ecx
	mov	DWORD PTR [edx+6], eax

; 1762 : 	x86Ptr += 4; 

	add	edx, 10					; 0000000aH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1935 : 					JNE32(((u32)&dyna_block_discard)- ( (u32)x86Ptr + 6 ));

	mov	eax, OFFSET ?dyna_block_discard@@YIXII@Z ; dyna_block_discard
	sub	eax, edx
	sub	eax, 6
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	WORD PTR [edx], 34063			; 0000850fH

; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [edx+2], eax

; 1762 : 	x86Ptr += 4; 

	add	edx, 6
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1931 : 				while(stg>0)

	dec	DWORD PTR tv2162[esp+72]
	jne	SHORT $LL20@recRecompi
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1762 : 	x86Ptr += 4; 

	mov	DWORD PTR ?x86Ptr@@3PAEA, edx		; x86Ptr
$LN921@recRecompi:
	mov	eax, DWORD PTR _pgsz$1$[esp+72]
$LN19@recRecompi:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1944 : 		inpage_ptr+=pgsz;

	add	DWORD PTR _inpage_ptr$1$[esp+72], eax

; 1945 : 		inpage_sz-=pgsz;

	mov	esi, DWORD PTR _inpage_sz$[esp+72]

; 1946 : 		inpage_offs=inpage_ptr&0xFFF;

	mov	ecx, DWORD PTR _inpage_ptr$1$[esp+72]
	sub	esi, eax
	and	ecx, 4095				; 00000fffH
	mov	DWORD PTR _inpage_sz$[esp+72], esi
	mov	DWORD PTR _inpage_offs$1$[esp+72], ecx
	mov	ecx, DWORD PTR _inpage_ptr$1$[esp+72]
	test	esi, esi
	jne	$LL25@recRecompi

; 1912 : 	while(inpage_sz)

	mov	esi, DWORD PTR _s_nEndBlock
	mov	edi, DWORD PTR _s_pInstCache
$LN24@recRecompi:

; 1947 : 	}
; 1948 : 
; 1949 : 	// finally recompile //
; 1950 : 	g_pCurInstInfo = s_pInstCache;
; 1951 : 	while (!branch && pc < s_nEndBlock) {

	cmp	DWORD PTR ?branch@@3HA, 0		; branch
	mov	DWORD PTR ?g_pCurInstInfo@@3PAUEEINST@@A, edi ; g_pCurInstInfo
	jne	SHORT $LN919@recRecompi
	npad	3
$LL18@recRecompi:
	mov	eax, DWORD PTR ?pc@@3IA			; pc
	cmp	eax, esi
	jae	SHORT $LN17@recRecompi

; 1952 : 		recompileNextInstruction(0);

	xor	ecx, ecx
	call	?recompileNextInstruction@@YAXH@Z	; recompileNextInstruction
	cmp	DWORD PTR ?branch@@3HA, 0		; branch
	jne	SHORT $LN919@recRecompi

; 1947 : 	}
; 1948 : 
; 1949 : 	// finally recompile //
; 1950 : 	g_pCurInstInfo = s_pInstCache;
; 1951 : 	while (!branch && pc < s_nEndBlock) {

	mov	esi, DWORD PTR _s_nEndBlock
	jmp	SHORT $LL18@recRecompi
$LN919@recRecompi:
	mov	eax, DWORD PTR ?pc@@3IA			; pc
$LN17@recRecompi:

; 1953 : 	}
; 1954 : 
; 1955 : #ifdef _DEBUG
; 1956 : 	if( (dumplog & 1) )
; 1957 : 		iDumpBlock(startpc, recPtr);
; 1958 : #endif
; 1959 : 
; 1960 : 	assert( (pc-startpc)>>2 <= 0xffff );
; 1961 : 	s_pCurBlockEx->size = (pc-startpc)>>2;

	sub	eax, DWORD PTR _startpc$[ebp]

; 1962 : 
; 1963 : 	for(i = 1; i < (u32)s_pCurBlockEx->size-1; ++i) {

	mov	edx, 1
	mov	edi, DWORD PTR _s_pCurBlockEx
	mov	esi, DWORD PTR _s_pCurBlock
	shr	eax, 2
	mov	WORD PTR [edi], ax
	movzx	eax, ax
	dec	eax
	cmp	eax, edx
	jbe	SHORT $LN14@recRecompi
$LL16@recRecompi:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\baseblockex.h

; 35   : 	const uptr GetFnptr() const { return ((u32)m_pFnptr)<<4; }

	mov	ecx, DWORD PTR [esi]

; 40   : 		m_pFnptr = ptr>>4;

	mov	eax, DWORD PTR [esi+edx*8]

; 35   : 	const uptr GetFnptr() const { return ((u32)m_pFnptr)<<4; }

	shl	ecx, 4

; 40   : 		m_pFnptr = ptr>>4;

	and	eax, -268435456				; f0000000H
	shr	ecx, 4
	or	ecx, eax
	mov	DWORD PTR [esi+edx*8], ecx
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1965 : 		s_pCurBlock[i].startpc = s_pCurBlock->startpc;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+edx*8+4], eax
	inc	edx
	movzx	eax, WORD PTR [edi]
	dec	eax
	cmp	edx, eax
	jb	SHORT $LL16@recRecompi
$LN14@recRecompi:

; 1966 : 	}
; 1967 : 
; 1968 : 	// don't overwrite if delay slot
; 1969 : 	if( i < (u32)s_pCurBlockEx->size && !(s_pCurBlock[i].uType & BLOCKTYPE_DELAYSLOT) ) {

	movzx	eax, WORD PTR [edi]
	cmp	edx, eax
	jae	SHORT $LN13@recRecompi
	test	DWORD PTR [esi+edx*8], 268435456	; 10000000H
	jne	SHORT $LN13@recRecompi
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\baseblockex.h

; 35   : 	const uptr GetFnptr() const { return ((u32)m_pFnptr)<<4; }

	mov	ecx, DWORD PTR [esi]

; 40   : 		m_pFnptr = ptr>>4;

	mov	eax, DWORD PTR [esi+edx*8]

; 35   : 	const uptr GetFnptr() const { return ((u32)m_pFnptr)<<4; }

	shl	ecx, 4

; 40   : 		m_pFnptr = ptr>>4;

	and	eax, -268435456				; f0000000H
	shr	ecx, 4
	or	eax, ecx
	mov	DWORD PTR [esi+edx*8], eax
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1971 : 		s_pCurBlock[i].startpc = s_pCurBlock->startpc;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+edx*8+4], eax
$LN13@recRecompi:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\baseblockex.cpp

; 128  : 	s_vecBaseBlocksEx[cpu].Add(pex);

	push	edi
	mov	ecx, OFFSET _s_vecBaseBlocksEx
	call	?Add@BASEBLOCKS@@QAEXPAUBASEBLOCKEX@@@Z	; BASEBLOCKS::Add
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1987 : 	if( !(pc&0x10000000) )

	mov	esi, DWORD PTR ?pc@@3IA			; pc
	test	esi, 268435456				; 10000000H
	jne	SHORT $LN12@recRecompi

; 1988 : 		maxrecmem = std::max( (pc&~0xa0000000), maxrecmem );

	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 4088 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	edx, DWORD PTR $T2[esp+72]
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1988 : 		maxrecmem = std::max( (pc&~0xa0000000), maxrecmem );

	and	ecx, 1610612735				; 5fffffffH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 4088 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, OFFSET ?maxrecmem@@3IA		; maxrecmem
	cmp	ecx, DWORD PTR ?maxrecmem@@3IA		; maxrecmem
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1988 : 		maxrecmem = std::max( (pc&~0xa0000000), maxrecmem );

	mov	DWORD PTR $T2[esp+72], ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 4088 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmovae	eax, edx
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1988 : 		maxrecmem = std::max( (pc&~0xa0000000), maxrecmem );

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR ?maxrecmem@@3IA, eax		; maxrecmem
$LN12@recRecompi:

; 1989 : 
; 1990 : 	if( branch == 2 )

	mov	edx, DWORD PTR ?branch@@3HA		; branch
	cmp	edx, 2
	jne	$LN11@recRecompi

; 1130 : 	_freeX86regs();

	call	?_freeX86regs@@YAXXZ			; _freeX86regs
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\icore.cpp

; 992  : 	for (i=0; i<XMMREGS; i++) {

	xor	esi, esi
	npad	3
$LL515@recRecompi:

; 993  : 		if (xmmregs[i].inuse == 0) continue;

	cmp	BYTE PTR ?xmmregs@@3PAU_xmmregs@@A[esi*8], 0
	je	SHORT $LN514@recRecompi

; 994  : 
; 995  : 		assert( xmmregs[i].type != XMMTYPE_TEMP );
; 996  : 		//assert( xmmregs[i].mode & (MODE_READ|MODE_WRITE) );
; 997  : 
; 998  : 		_freeXMMreg(i);

	mov	ecx, esi
	call	?_freeXMMreg@@YAXH@Z			; _freeXMMreg
$LN514@recRecompi:

; 992  : 	for (i=0; i<XMMREGS; i++) {

	inc	esi
	cmp	esi, 8
	jl	SHORT $LL515@recRecompi
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1143 : 		_flushConstRegs();

	call	?_freeMMXregs@@YAXXZ			; _freeMMXregs
	call	?_flushConstRegs@@YAXXZ			; _flushConstRegs
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ifpu.cpp

; 52   : 	if (iCWstate == 0) return;

	mov	ax, WORD PTR ?iCWstate@@3GA		; iCWstate
	test	ax, ax
	je	SHORT $LN906@recRecompi

; 57   : 	if (iCWstate & 1) {

	test	al, 1
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	eax, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ifpu.cpp

; 57   : 	if (iCWstate & 1) {

	je	SHORT $LN537@recRecompi
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	WORD PTR [eax], 11737			; 00002dd9H

; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [eax+2], OFFSET _fpucws

; 1762 : 	x86Ptr += 4; 

	add	eax, 6
	mov	DWORD PTR ?x86Ptr@@3PAEA, eax		; x86Ptr
$LN537@recRecompi:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ifpu.cpp

; 60   : 	iCWstate = 0;

	xor	ecx, ecx
	mov	WORD PTR ?iCWstate@@3GA, cx		; iCWstate
	jmp	SHORT $LN527@recRecompi
$LN906@recRecompi:
	mov	eax, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
$LN527@recRecompi:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1147 : 	if (x86FpuState==MMX_STATE) {

	cmp	WORD PTR ?x86FpuState@@3GA, 1		; x86FpuState
	jne	SHORT $LN502@recRecompi

; 1148 : 		if (cpucaps.has3DNOWInstructionExtensions) FEMMS();

	cmp	DWORD PTR ?cpucaps@@3UCAPABILITIES@@A+136, 0
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1745 : 	*(u16*)x86Ptr = (u16)val; 

	mov	ecx, 3599				; 00000e0fH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1148 : 		if (cpucaps.has3DNOWInstructionExtensions) FEMMS();

	jne	SHORT $LN922@recRecompi
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1745 : 	*(u16*)x86Ptr = (u16)val; 

	mov	ecx, 30479				; 0000770fH
$LN922@recRecompi:
	mov	WORD PTR [eax], cx

; 1746 : 	x86Ptr += 2;  

	add	eax, 2
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1150 : 		x86FpuState=FPU_STATE;

	xor	ecx, ecx
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1746 : 	x86Ptr += 2;  

	mov	DWORD PTR ?x86Ptr@@3PAEA, eax		; x86Ptr
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1150 : 		x86FpuState=FPU_STATE;

	mov	WORD PTR ?x86FpuState@@3GA, cx		; x86FpuState
$LN502@recRecompi:

; 1216 : }
; 1217 : 
; 1218 : // Generates dynarec code for Event tests followed by a block dispatch (branch).
; 1219 : // Parameters:
; 1220 : //   newpc - address to jump to at the end of the block.  If newpc == 0xffffffff then
; 1221 : //   the jump is assumed to be to a register (dynamic).  For any other value the
; 1222 : //   jump is assumed to be static, in which case the block will be "hardlinked" after
; 1223 : //   the first time it's dispatched.
; 1224 : // 
; 1225 : //   noDispatch - When set true, the jump to Dispatcher.  Used by the recs
; 1226 : //   for blocks which perform exception checks without branching (it's enabled by
; 1227 : //   setting "branch = 2";
; 1228 : static void iBranchTest(u32 newpc, bool noDispatch)
; 1229 : {
; 1230 : #ifdef _DEBUG
; 1231 : 	//CALLFunc((uptr)testfpu);
; 1232 : #endif
; 1233 : 	u32* ptr;
; 1234 : 
; 1235 : 	if( bExecBIOS ) CheckForBIOSEnd();

	cmp	DWORD PTR ?bExecBIOS@@3IA, 0		; bExecBIOS
	je	SHORT $LN551@recRecompi
	call	?CheckForBIOSEnd@@YAXXZ			; CheckForBIOSEnd
	mov	eax, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
$LN551@recRecompi:

; 1178 : 	if( s_nBlockCycles <= (5<<3) || (CHECK_EE_CYCLERATE == 0) )

	mov	ecx, DWORD PTR ?s_nBlockCycles@@3IA	; s_nBlockCycles
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	WORD PTR [eax], 1419			; 0000058bH

; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [eax+2], OFFSET ?cpuRegs@@3UcpuRegisters@@A+960

; 1762 : 	x86Ptr += 4; 

	add	eax, 6
	mov	DWORD PTR ?x86Ptr@@3PAEA, eax		; x86Ptr
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1178 : 	if( s_nBlockCycles <= (5<<3) || (CHECK_EE_CYCLERATE == 0) )

	cmp	ecx, 40					; 00000028H
	jbe	SHORT $LN581@recRecompi
	mov	edx, DWORD PTR ?Config@@3UPcsxConfig@@A+3608
	and	edx, 3
	je	SHORT $LN581@recRecompi

; 1180 : 
; 1181 : 	uint scalarLow, scalarMid, scalarHigh;
; 1182 : 
; 1183 : 	// Note: larger blocks get a smaller scalar, to help keep
; 1184 : 	// them from becoming "too fat" and delaying branch tests.
; 1185 : 
; 1186 : 	switch( CHECK_EE_CYCLERATE )

	jmp	DWORD PTR $LN932@recRecompi[edx*4]
$LN577@recRecompi:

; 1187 : 	{
; 1188 : 		case 0:	return s_nBlockCycles >> 3;
; 1189 : 
; 1190 : 		case 1:		// Sync hack x1.5!
; 1191 : 			scalarLow = 5;

	mov	esi, 5

; 1192 : 			scalarMid = 7;

	lea	edx, DWORD PTR [esi+2]

; 1193 : 			scalarHigh = 5;
; 1194 : 		break;

	jmp	SHORT $LN923@recRecompi
$LN576@recRecompi:

; 1195 : 
; 1196 : 		case 2:		// Sync hack x2
; 1197 : 			scalarLow = 7;

	mov	esi, 7

; 1198 : 			scalarMid = 9;

	lea	edx, DWORD PTR [esi+2]

; 1199 : 			scalarHigh = 7;
; 1200 : 		break;

	jmp	SHORT $LN923@recRecompi
$LN575@recRecompi:

; 1201 : 
; 1202 : 		case 3:		// Sync hack x3
; 1203 : 			scalarLow = 10;

	mov	esi, 10					; 0000000aH

; 1204 : 			scalarMid = 19;

	lea	edx, DWORD PTR [esi+9]
$LN923@recRecompi:

; 1205 : 			scalarHigh = 10;

	mov	edi, esi

; 1206 : 		break;
; 1207 : 
; 1208 : 		jNO_DEFAULT
; 1209 : 	}
; 1210 : 
; 1211 : 	s_nBlockCycles *= 
; 1212 : 		(s_nBlockCycles <= (10<<3)) ? scalarLow :
; 1213 : 		((s_nBlockCycles > (21<<3)) ? scalarHigh : scalarMid );

	cmp	ecx, 80					; 00000050H
	jbe	SHORT $LN586@recRecompi
	cmp	ecx, 168				; 000000a8H
	cmova	edx, edi
	mov	esi, edx
$LN586@recRecompi:
	imul	ecx, esi
	mov	DWORD PTR ?s_nBlockCycles@@3IA, ecx	; s_nBlockCycles

; 1214 : 
; 1215 : 	return s_nBlockCycles >> (3+2);

	shr	ecx, 5
	jmp	SHORT $LN583@recRecompi
$LN581@recRecompi:

; 1179 : 		return s_nBlockCycles >> 3;

	shr	ecx, 3
$LN583@recRecompi:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp

; 1071 : 	if(from < 0x80)

	cmp	ecx, 128				; 00000080H
	jae	SHORT $LN591@recRecompi
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	WORD PTR [eax], 49283			; 0000c083H
	mov	BYTE PTR [eax+2], cl

; 1740 : 	x86Ptr++; 

	add	eax, 3
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp

; 1077 : 	else

	jmp	SHORT $LN616@recRecompi
$LN591@recRecompi:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	BYTE PTR [eax], 5

; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [eax+1], ecx

; 1762 : 	x86Ptr += 4; 

	add	eax, 5
$LN616@recRecompi:

; 1739 : 	*x86Ptr = (u8)val; 

	mov	WORD PTR [eax], 1417			; 00000589H

; 1745 : 	*(u16*)x86Ptr = (u16)val; 

	mov	ecx, 50163				; 0000c3f3H

; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [eax+2], OFFSET ?cpuRegs@@3UcpuRegisters@@A+960

; 1739 : 	*x86Ptr = (u8)val; 

	mov	WORD PTR [eax+6], 1323			; 0000052bH

; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [eax+8], OFFSET ?g_nextBranchCycle@@3IA ; g_nextBranchCycle

; 1745 : 	*(u16*)x86Ptr = (u16)val; 

	mov	WORD PTR [eax+12], cx

; 1746 : 	x86Ptr += 2;  

	add	eax, 14					; 0000000eH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 2001 : 	else

	jmp	$LN924@recRecompi
$LN11@recRecompi:

; 2002 : 	{
; 2003 : 		assert( branch != 3 );
; 2004 : 		if( branch )

	test	edx, edx
	jne	SHORT $LN907@recRecompi

; 1178 : 	if( s_nBlockCycles <= (5<<3) || (CHECK_EE_CYCLERATE == 0) )

	mov	ecx, DWORD PTR ?s_nBlockCycles@@3IA	; s_nBlockCycles
	cmp	ecx, 40					; 00000028H
	jbe	SHORT $LN673@recRecompi
	mov	eax, DWORD PTR ?Config@@3UPcsxConfig@@A+3608
	and	eax, 3
	je	SHORT $LN673@recRecompi

; 1180 : 
; 1181 : 	uint scalarLow, scalarMid, scalarHigh;
; 1182 : 
; 1183 : 	// Note: larger blocks get a smaller scalar, to help keep
; 1184 : 	// them from becoming "too fat" and delaying branch tests.
; 1185 : 
; 1186 : 	switch( CHECK_EE_CYCLERATE )

	jmp	DWORD PTR $LN933@recRecompi[eax*4]
$LN669@recRecompi:

; 1187 : 	{
; 1188 : 		case 0:	return s_nBlockCycles >> 3;
; 1189 : 
; 1190 : 		case 1:		// Sync hack x1.5!
; 1191 : 			scalarLow = 5;

	mov	eax, 5

; 1192 : 			scalarMid = 7;

	lea	edi, DWORD PTR [eax+2]

; 1193 : 			scalarHigh = 5;
; 1194 : 		break;

	jmp	SHORT $LN925@recRecompi
$LN668@recRecompi:

; 1195 : 
; 1196 : 		case 2:		// Sync hack x2
; 1197 : 			scalarLow = 7;

	mov	eax, 7

; 1198 : 			scalarMid = 9;

	lea	edi, DWORD PTR [eax+2]

; 1199 : 			scalarHigh = 7;
; 1200 : 		break;

	jmp	SHORT $LN925@recRecompi
$LN667@recRecompi:

; 1201 : 
; 1202 : 		case 3:		// Sync hack x3
; 1203 : 			scalarLow = 10;

	mov	eax, 10					; 0000000aH

; 1204 : 			scalarMid = 19;

	lea	edi, DWORD PTR [eax+9]
$LN925@recRecompi:

; 1205 : 			scalarHigh = 10;

	mov	DWORD PTR _scalarHigh$1$[esp+72], eax

; 1206 : 		break;
; 1207 : 
; 1208 : 		jNO_DEFAULT
; 1209 : 	}
; 1210 : 
; 1211 : 	s_nBlockCycles *= 
; 1212 : 		(s_nBlockCycles <= (10<<3)) ? scalarLow :
; 1213 : 		((s_nBlockCycles > (21<<3)) ? scalarHigh : scalarMid );

	cmp	ecx, 80					; 00000050H
	jbe	SHORT $LN678@recRecompi
	cmp	ecx, 168				; 000000a8H
	cmova	edi, eax
	mov	eax, edi
$LN678@recRecompi:
	imul	ecx, eax
	mov	DWORD PTR ?s_nBlockCycles@@3IA, ecx	; s_nBlockCycles

; 1214 : 
; 1215 : 	return s_nBlockCycles >> (3+2);

	shr	ecx, 5
	jmp	SHORT $LN675@recRecompi
$LN673@recRecompi:

; 1179 : 		return s_nBlockCycles >> 3;

	shr	ecx, 3
$LN675@recRecompi:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	eax, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
	mov	WORD PTR [eax], 1409			; 00000581H

; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [eax+2], OFFSET ?cpuRegs@@3UcpuRegisters@@A+960
	mov	DWORD PTR [eax+6], ecx

; 1762 : 	x86Ptr += 4; 

	add	eax, 10					; 0000000aH
	mov	DWORD PTR ?x86Ptr@@3PAEA, eax		; x86Ptr
	jmp	SHORT $LN689@recRecompi
$LN907@recRecompi:
	mov	eax, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
$LN689@recRecompi:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 2009 : 		if( willbranch3 ) {

	cmp	DWORD PTR _willbranch3$1$[esp+72], 0
	je	$LN7@recRecompi

; 2010 : 			BASEBLOCK* pblock = PC_GETBLOCK(s_nEndBlock);

	movzx	ecx, WORD PTR _s_nEndBlock+2
	mov	eax, DWORD PTR ?recLUT@@3PAIA		; recLUT
	movzx	edx, WORD PTR _s_nEndBlock
	mov	eax, DWORD PTR [eax+ecx*4]
	lea	edi, DWORD PTR [eax+edx*2]

; 1130 : 	_freeX86regs();

	call	?_freeX86regs@@YAXXZ			; _freeX86regs
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\icore.cpp

; 992  : 	for (i=0; i<XMMREGS; i++) {

	xor	esi, esi
$LL706@recRecompi:

; 993  : 		if (xmmregs[i].inuse == 0) continue;

	cmp	BYTE PTR ?xmmregs@@3PAU_xmmregs@@A[esi*8], 0
	je	SHORT $LN705@recRecompi

; 994  : 
; 995  : 		assert( xmmregs[i].type != XMMTYPE_TEMP );
; 996  : 		//assert( xmmregs[i].mode & (MODE_READ|MODE_WRITE) );
; 997  : 
; 998  : 		_freeXMMreg(i);

	mov	ecx, esi
	call	?_freeXMMreg@@YAXH@Z			; _freeXMMreg
$LN705@recRecompi:

; 992  : 	for (i=0; i<XMMREGS; i++) {

	inc	esi
	cmp	esi, 8
	jl	SHORT $LL706@recRecompi
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1143 : 		_flushConstRegs();

	call	?_freeMMXregs@@YAXXZ			; _freeMMXregs
	call	?_flushConstRegs@@YAXXZ			; _flushConstRegs
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ifpu.cpp

; 52   : 	if (iCWstate == 0) return;

	mov	ax, WORD PTR ?iCWstate@@3GA		; iCWstate
	test	ax, ax
	je	SHORT $LN909@recRecompi

; 57   : 	if (iCWstate & 1) {

	test	al, 1
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	eax, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ifpu.cpp

; 57   : 	if (iCWstate & 1) {

	je	SHORT $LN728@recRecompi
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	WORD PTR [eax], 11737			; 00002dd9H

; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [eax+2], OFFSET _fpucws

; 1762 : 	x86Ptr += 4; 

	add	eax, 6
$LN728@recRecompi:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ifpu.cpp

; 60   : 	iCWstate = 0;

	xor	ecx, ecx
	mov	WORD PTR ?iCWstate@@3GA, cx		; iCWstate
	jmp	SHORT $LN718@recRecompi
$LN909@recRecompi:
	mov	eax, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
$LN718@recRecompi:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1147 : 	if (x86FpuState==MMX_STATE) {

	cmp	WORD PTR ?x86FpuState@@3GA, 1		; x86FpuState
	jne	SHORT $LN693@recRecompi

; 1148 : 		if (cpucaps.has3DNOWInstructionExtensions) FEMMS();

	cmp	DWORD PTR ?cpucaps@@3UCAPABILITIES@@A+136, 0
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1745 : 	*(u16*)x86Ptr = (u16)val; 

	mov	ecx, 3599				; 00000e0fH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1148 : 		if (cpucaps.has3DNOWInstructionExtensions) FEMMS();

	jne	SHORT $LN926@recRecompi
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1745 : 	*(u16*)x86Ptr = (u16)val; 

	mov	ecx, 30479				; 0000770fH
$LN926@recRecompi:
	mov	WORD PTR [eax], cx

; 1746 : 	x86Ptr += 2;  

	add	eax, 2
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1150 : 		x86FpuState=FPU_STATE;

	xor	ecx, ecx
	mov	WORD PTR ?x86FpuState@@3GA, cx		; x86FpuState
$LN693@recRecompi:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1761 : 	*(u32*)x86Ptr = val; 

	mov	esi, DWORD PTR ?pc@@3IA			; pc
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 2015 : 			branch = 3;

	mov	edx, 3
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	WORD PTR [eax], 1479			; 000005c7H

; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [eax+2], OFFSET ?cpuRegs@@3UcpuRegisters@@A+680
	mov	DWORD PTR [eax+6], esi

; 1762 : 	x86Ptr += 4; 

	add	eax, 10					; 0000000aH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\baseblockex.h

; 35   : 	const uptr GetFnptr() const { return ((u32)m_pFnptr)<<4; }

	mov	ecx, DWORD PTR [edi]
	shl	ecx, 4
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 2014 : 			JMP32((uptr)pblock->GetFnptr() - ((uptr)x86Ptr + 5));

	sub	ecx, eax

; 2015 : 			branch = 3;

	mov	DWORD PTR ?branch@@3HA, edx		; branch
	sub	ecx, 5
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	BYTE PTR [eax], 233			; 000000e9H

; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [eax+1], ecx

; 1762 : 	x86Ptr += 4; 

	add	eax, 5
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 2015 : 			branch = 3;

	jmp	$LN927@recRecompi
$LN7@recRecompi:

; 2016 : 		}
; 2017 : 		else if( !branch ) {

	test	edx, edx
	jne	$LN5@recRecompi
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	WORD PTR [eax], 1479			; 000005c7H

; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [eax+2], OFFSET ?cpuRegs@@3UcpuRegisters@@A+680
	mov	DWORD PTR [eax+6], esi

; 1762 : 	x86Ptr += 4; 

	add	eax, 10					; 0000000aH
	mov	DWORD PTR ?x86Ptr@@3PAEA, eax		; x86Ptr
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1130 : 	_freeX86regs();

	call	?_freeX86regs@@YAXXZ			; _freeX86regs
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\icore.cpp

; 992  : 	for (i=0; i<XMMREGS; i++) {

	xor	esi, esi
$LL785@recRecompi:

; 993  : 		if (xmmregs[i].inuse == 0) continue;

	cmp	BYTE PTR ?xmmregs@@3PAU_xmmregs@@A[esi*8], 0
	je	SHORT $LN784@recRecompi

; 994  : 
; 995  : 		assert( xmmregs[i].type != XMMTYPE_TEMP );
; 996  : 		//assert( xmmregs[i].mode & (MODE_READ|MODE_WRITE) );
; 997  : 
; 998  : 		_freeXMMreg(i);

	mov	ecx, esi
	call	?_freeXMMreg@@YAXH@Z			; _freeXMMreg
$LN784@recRecompi:

; 992  : 	for (i=0; i<XMMREGS; i++) {

	inc	esi
	cmp	esi, 8
	jl	SHORT $LL785@recRecompi
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1143 : 		_flushConstRegs();

	call	?_freeMMXregs@@YAXXZ			; _freeMMXregs
	call	?_flushConstRegs@@YAXXZ			; _flushConstRegs
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ifpu.cpp

; 52   : 	if (iCWstate == 0) return;

	mov	ax, WORD PTR ?iCWstate@@3GA		; iCWstate
	test	ax, ax
	je	SHORT $LN911@recRecompi

; 57   : 	if (iCWstate & 1) {

	test	al, 1
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	eax, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ifpu.cpp

; 57   : 	if (iCWstate & 1) {

	je	SHORT $LN807@recRecompi
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	WORD PTR [eax], 11737			; 00002dd9H

; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [eax+2], OFFSET _fpucws

; 1762 : 	x86Ptr += 4; 

	add	eax, 6
$LN807@recRecompi:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ifpu.cpp

; 60   : 	iCWstate = 0;

	xor	ecx, ecx
	mov	WORD PTR ?iCWstate@@3GA, cx		; iCWstate
	jmp	SHORT $LN797@recRecompi
$LN911@recRecompi:
	mov	eax, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
$LN797@recRecompi:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1147 : 	if (x86FpuState==MMX_STATE) {

	cmp	WORD PTR ?x86FpuState@@3GA, 1		; x86FpuState
	jne	SHORT $LN772@recRecompi

; 1148 : 		if (cpucaps.has3DNOWInstructionExtensions) FEMMS();

	cmp	DWORD PTR ?cpucaps@@3UCAPABILITIES@@A+136, 0
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1745 : 	*(u16*)x86Ptr = (u16)val; 

	mov	ecx, 3599				; 00000e0fH
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1148 : 		if (cpucaps.has3DNOWInstructionExtensions) FEMMS();

	jne	SHORT $LN928@recRecompi
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1745 : 	*(u16*)x86Ptr = (u16)val; 

	mov	ecx, 30479				; 0000770fH
$LN928@recRecompi:
	mov	WORD PTR [eax], cx

; 1746 : 	x86Ptr += 2;  

	add	eax, 2
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 1150 : 		x86FpuState=FPU_STATE;

	xor	ecx, ecx
	mov	WORD PTR ?x86FpuState@@3GA, cx		; x86FpuState
$LN772@recRecompi:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1739 : 	*x86Ptr = (u8)val; 

	mov	BYTE PTR [eax], 233			; 000000e9H

; 1761 : 	*(u32*)x86Ptr = val; 

	mov	DWORD PTR [eax+1], 0

; 1762 : 	x86Ptr += 4; 

	add	eax, 5
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.cpp

; 2565 : 	return (u32*)(x86Ptr - 4 );

	lea	ecx, DWORD PTR [eax-4]
	mov	DWORD PTR _ptr$[esp+72], ecx
$LN924@recRecompi:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 2023 : 			ptr = JMP32(0);

	mov	esi, DWORD PTR ?pc@@3IA			; pc
	mov	edx, DWORD PTR ?branch@@3HA		; branch
$LN927@recRecompi:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86\ix86.h

; 1762 : 	x86Ptr += 4; 

	mov	DWORD PTR ?x86Ptr@@3PAEA, eax		; x86Ptr
$LN5@recRecompi:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 2032 : 	recPtr = x86Ptr;

	mov	DWORD PTR _recPtr, eax

; 2033 : 
; 2034 : 	assert( (g_cpuHasConstReg&g_cpuFlushedConstReg) == g_cpuHasConstReg );
; 2035 : 
; 2036 : 	if( !branch ) {

	test	edx, edx
	jne	SHORT $LN1@recRecompi

; 2037 : 		BASEBLOCK* pcurblock = s_pCurBlock;
; 2038 : 		u32 nEndBlock = s_nEndBlock;
; 2039 : 		s_pCurBlock = PC_GETBLOCK(pc);

	movzx	ecx, WORD PTR ?pc@@3IA+2
	mov	eax, DWORD PTR ?recLUT@@3PAIA		; recLUT
	mov	edi, DWORD PTR _s_pCurBlock
	movzx	edx, si
	mov	eax, DWORD PTR [eax+ecx*4]
	lea	eax, DWORD PTR [eax+edx*2]
	mov	DWORD PTR _s_pCurBlock, eax

; 2040 : 		assert( ptr != NULL );
; 2041 : 		
; 2042 : 		if( s_pCurBlock->startpc != pc ) 

	cmp	DWORD PTR [eax+4], esi
	je	SHORT $LN3@recRecompi

; 2043 :  			recRecompile(pc);

	push	esi
	call	?recRecompile@@YAXI@Z			; recRecompile
	mov	eax, DWORD PTR _s_pCurBlock
	add	esp, 4
$LN3@recRecompi:

; 2044 : 
; 2045 : 		if( pcurblock->startpc == startpc ) {

	mov	ecx, DWORD PTR _startpc$[ebp]
	cmp	DWORD PTR [edi+4], ecx
	je	SHORT $LN850@recRecompi

; 2048 : 			*ptr = s_pCurBlock->GetFnptr() - ( (u32)ptr + 4 );

	mov	edi, ecx
	jmp	$LN929@recRecompi
$LN850@recRecompi:
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\baseblockex.h

; 35   : 	const uptr GetFnptr() const { return ((u32)m_pFnptr)<<4; }

	mov	eax, DWORD PTR [eax]
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 2048 : 			*ptr = s_pCurBlock->GetFnptr() - ( (u32)ptr + 4 );

	mov	ecx, DWORD PTR _ptr$[esp+72]
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\baseblockex.h

; 35   : 	const uptr GetFnptr() const { return ((u32)m_pFnptr)<<4; }

	shl	eax, 4
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\x86\ix86-32\ir5900-32.cpp

; 2048 : 			*ptr = s_pCurBlock->GetFnptr() - ( (u32)ptr + 4 );

	sub	eax, ecx
	sub	eax, 4
	mov	DWORD PTR [ecx], eax
$LN1@recRecompi:

; 2049 : 		}
; 2050 : 		else {
; 2051 : 			recRecompile(startpc);
; 2052 : 			assert( pcurblock->GetFnptr() != 0 );
; 2053 : 		}
; 2054 : 	}
; 2055 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN931@recRecompi:
	DD	$LN72@recRecompi
	DD	$LN68@recRecompi
	DD	$LN846@recRecompi
	DD	$LN57@recRecompi
	DD	$LN51@recRecompi
	DD	$LN49@recRecompi
	DD	$LN46@recRecompi
$LN900@recRecompi:
	DB	0
	DB	1
	DB	2
	DB	2
	DB	3
	DB	3
	DB	3
	DB	3
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	4
	DB	5
	DB	5
	DB	6
	DB	3
	DB	3
	DB	3
	DB	3
$LN932@recRecompi:
	DD	$LN581@recRecompi
	DD	$LN577@recRecompi
	DD	$LN576@recRecompi
	DD	$LN575@recRecompi
$LN933@recRecompi:
	DD	$LN673@recRecompi
	DD	$LN669@recRecompi
	DD	$LN668@recRecompi
	DD	$LN667@recRecompi
?recRecompile@@YAXI@Z ENDP				; recRecompile
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\windows\memzero.h
_TEXT	SEGMENT
_dest$ = -8						; size = 4
??$memset_8@$0MN@$0BAAAAAA@@@YAXPAX@Z PROC		; memset_8<205,16777216>
; _dest$dead$ = ecx

; 252  : {

	sub	esp, 8
	mov	eax, DWORD PTR _recMem
	push	edi
	mov	DWORD PTR _dest$[esp+12], eax

; 377  : 			{
; 378  : 				cld;

	cld

; 379  : 				mov ecx, remdat;

	mov	ecx, 4194304				; 00400000H

; 380  : 				mov edi, dest;

	mov	edi, DWORD PTR _dest$[esp+12]

; 381  : 				mov eax, data32;

	mov	eax, -842150451				; cdcdcdcdH

; 382  : 				rep stosd;

	rep	 stosd

; 253  : 	if( bytes == 0 ) return;
; 254  : 
; 255  : 	if( (bytes & 0x3) != 0 )
; 256  : 	{
; 257  : 		// unaligned data length.  No point in doing an optimized inline version (too complicated!)
; 258  : 		// So fall back on the compiler implementation:
; 259  : 
; 260  : 		memset( dest, data, bytes );
; 261  : 		return;
; 262  : 	}
; 263  : 
; 264  : 	//u64 _xmm_backup[2];
; 265  : 
; 266  : 	/*static const size_t remainder = bytes & 127;
; 267  : 	static const size_t bytes128 = bytes / 128;
; 268  : 	if( bytes128 > 32 )
; 269  : 	{
; 270  : 		// This function only works on 128-bit alignments.
; 271  : 		jASSUME( (bytes & 0xf) == 0 );
; 272  : 		jASSUME( ((uptr)dest & 0xf) == 0 );
; 273  : 
; 274  : 		__asm
; 275  : 		{
; 276  : 			movups _xmm_backup,xmm0;
; 277  : 			mov eax,bytes128
; 278  : 			mov ecx,dest
; 279  : 			movss xmm0,data
; 280  : 
; 281  : 			align 16
; 282  : 
; 283  : 		_loop_8:
; 284  : 			movaps [ecx],xmm0;
; 285  : 			movaps [ecx+0x10],xmm0;
; 286  : 			movaps [ecx+0x20],xmm0;
; 287  : 			movaps [ecx+0x30],xmm0;
; 288  : 			movaps [ecx+0x40],xmm0;
; 289  : 			movaps [ecx+0x50],xmm0;
; 290  : 			movaps [ecx+0x60],xmm0;
; 291  : 			movaps [ecx+0x70],xmm0;
; 292  : 			sub ecx,-128
; 293  : 			dec eax;
; 294  : 			jnz _loop_8;
; 295  : 		}
; 296  : 		if( remainder != 0 )
; 297  : 		{
; 298  : 			// Copy the remainder in reverse (using the decrementing eax as our indexer)
; 299  : 			__asm
; 300  : 			{
; 301  : 				mov eax, remainder
; 302  : 
; 303  : 			_loop_10:
; 304  : 				movaps [ecx+eax],xmm0;
; 305  : 				sub eax,16;
; 306  : 				jnz _loop_10;
; 307  : 			}
; 308  : 		}
; 309  : 		__asm
; 310  : 		{
; 311  : 			movups xmm0,[_xmm_backup];
; 312  : 		}
; 313  : 	}*/
; 314  : 
; 315  : 	// This function only works on 32-bit alignments of data copied.
; 316  : 	jASSUME( (bytes & 0x3) == 0 );
; 317  : 
; 318  : 	enum
; 319  : 	{
; 320  : 		remdat = bytes>>2,
; 321  : 		data32 = data + (data<<8) + (data<<16) + (data<<24)
; 322  : 	};
; 323  : 
; 324  : 	// macro to execute the x86/32 "stosd" copies.
; 325  : 	switch( remdat )
; 326  : 	{
; 327  : 		case 1:
; 328  : 			*(u32*)dest = data32;
; 329  : 		return;
; 330  : 
; 331  : 		case 2:
; 332  : 			((u32*)dest)[0] = data32;
; 333  : 			((u32*)dest)[1] = data32;
; 334  : 		return;
; 335  : 
; 336  : 		case 3:
; 337  : 			__asm
; 338  : 			{
; 339  : 				cld;
; 340  : 				mov edi, dest;
; 341  : 				mov eax, data32;
; 342  : 				stosd;
; 343  : 				stosd;
; 344  : 				stosd;
; 345  : 			}
; 346  : 		return;
; 347  : 
; 348  : 		case 4:
; 349  : 			__asm
; 350  : 			{
; 351  : 				cld;
; 352  : 				mov edi, dest;
; 353  : 				mov eax, data32;
; 354  : 				stosd;
; 355  : 				stosd;
; 356  : 				stosd;
; 357  : 				stosd;
; 358  : 			}
; 359  : 		return;
; 360  : 
; 361  : 		case 5:
; 362  : 			__asm
; 363  : 			{
; 364  : 				cld;
; 365  : 				mov edi, dest;
; 366  : 				mov eax, data32;
; 367  : 				stosd;
; 368  : 				stosd;
; 369  : 				stosd;
; 370  : 				stosd;
; 371  : 				stosd;
; 372  : 			}
; 373  : 		return;
; 374  : 
; 375  : 		default:
; 376  : 			__asm

	pop	edi

; 383  : 			}
; 384  : 		return;
; 385  : 	}
; 386  : }

	add	esp, 8
	ret	0
??$memset_8@$0MN@$0BAAAAAA@@@YAXPAX@Z ENDP		; memset_8<205,16777216>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\windows\memzero.h
_TEXT	SEGMENT
__xmm_backup$1 = -20					; size = 16
_dest$ = -4						; size = 4
??$memzero_ptr@$0EJFAAAA@@@YAXPAX@Z PROC		; memzero_ptr<76873728>
; _dest$dead$ = ecx

; 50   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR _m_recBlockAlloc
	mov	DWORD PTR _dest$[ebp], eax

; 51   : 	if( bytes == 0 ) return;
; 52   : 
; 53   : 	// This function only works on 32-bit alignments.  For anything else we just fall back
; 54   : 	// on the compiler-provided implementation of memset...
; 55   : 
; 56   : 	if( (bytes & 0x3) != 0 )
; 57   : 	{
; 58   : 		memset( dest, 0, bytes );
; 59   : 		return;
; 60   : 	}
; 61   : 
; 62   : 	enum
; 63   : 	{
; 64   : 		remainder = bytes & 127,
; 65   : 		bytes128 = bytes / 128
; 66   : 	};
; 67   : 
; 68   : 	// Initial check -- if the length is not a multiple of 16 then fall back on
; 69   : 	// using rep movsd methods.  Handling these unaligned clears in a more efficient
; 70   : 	// manner isn't necessary in pcsx2 (meaning they aren't used in speed-critical
; 71   : 	// scenarios).
; 72   : 
; 73   : 	if( (bytes & 0xf) == 0 )
; 74   : 	{
; 75   : 		u64 _xmm_backup[2];
; 76   : 
; 77   : 		if( ((uptr)dest & 0xf) != 0 )

	test	al, 15					; 0000000fH
	je	SHORT $LN14@memzero_pt

; 78   : 		{
; 79   : 			// UNALIGNED COPY MODE.
; 80   : 			// For unaligned copies we have a threshold of at least 128 vectors.  Anything
; 81   : 			// less and it's probably better off just falling back on the rep movsd.
; 82   : 			if( bytes128 > 128 )
; 83   : 			{
; 84   : 				__asm
; 85   : 				{
; 86   : 					movups _xmm_backup,xmm0;

	movups	XMMWORD PTR __xmm_backup$1[ebp], xmm0

; 87   : 					mov ecx,dest

	mov	ecx, DWORD PTR _dest$[ebp]

; 88   : 					pxor xmm0,xmm0

	pxor	xmm0, xmm0

; 89   : 					mov eax,bytes128

	mov	eax, 600576				; 00092a00H
	npad	14
$_loop_6$21:

; 90   : 
; 91   : 					align 16
; 92   : 
; 93   : 				_loop_6:
; 94   : 					movups [ecx],xmm0;

	movups	XMMWORD PTR [ecx], xmm0

; 95   : 					movups [ecx+0x10],xmm0;

	movups	XMMWORD PTR [ecx+16], xmm0

; 96   : 					movups [ecx+0x20],xmm0;

	movups	XMMWORD PTR [ecx+32], xmm0

; 97   : 					movups [ecx+0x30],xmm0;

	movups	XMMWORD PTR [ecx+48], xmm0

; 98   : 					movups [ecx+0x40],xmm0;

	movups	XMMWORD PTR [ecx+64], xmm0

; 99   : 					movups [ecx+0x50],xmm0;

	movups	XMMWORD PTR [ecx+80], xmm0

; 100  : 					movups [ecx+0x60],xmm0;

	movups	XMMWORD PTR [ecx+96], xmm0

; 101  : 					movups [ecx+0x70],xmm0;

	movups	XMMWORD PTR [ecx+112], xmm0

; 102  : 					sub ecx,-128

	sub	ecx, -128				; ffffff80H

; 103  : 					dec eax;

	dec	eax

; 104  : 					jnz _loop_6;

	jne	SHORT $_loop_6$21

; 105  : 				}
; 106  : 				if( remainder != 0 )
; 107  : 				{
; 108  : 					// Copy the remainder in reverse (using the decrementing eax as our indexer)
; 109  : 					__asm
; 110  : 					{
; 111  : 						mov eax, remainder
; 112  : 
; 113  : 					_loop_5:
; 114  : 						movups [ecx+eax],xmm0;
; 115  : 						sub eax,16;
; 116  : 						jnz _loop_5;
; 117  : 					}
; 118  : 				}
; 119  : 				__asm
; 120  : 				{
; 121  : 					movups xmm0,[_xmm_backup];

	movups	xmm0, XMMWORD PTR __xmm_backup$1[ebp]

; 170  : 			}
; 171  : 			return;
; 172  : 		}
; 173  : 	}
; 174  : 
; 175  : 	// This function only works on 32-bit alignments.
; 176  : 	jASSUME( (bytes & 0x3) == 0 );
; 177  : 	jASSUME( ((uptr)dest & 0x3) == 0 );
; 178  : 
; 179  : 	enum
; 180  : 	{
; 181  : 		remdat = bytes>>2
; 182  : 	};
; 183  : 
; 184  : 	// This case statement handles 5 special-case sizes (small blocks)
; 185  : 	// in addition to the generic large block that uses rep stosd.
; 186  : 
; 187  : 	switch( remdat )
; 188  : 	{
; 189  : 		case 1:
; 190  : 			*(u32*)dest = 0;
; 191  : 		return;
; 192  : 
; 193  : 		case 2:
; 194  : 			*(u64*)dest = 0;
; 195  : 		return;
; 196  : 
; 197  : 		case 3:
; 198  : 			__asm
; 199  : 			{
; 200  : 				cld;
; 201  : 				mov edi, dest
; 202  : 				xor eax, eax
; 203  : 				stosd
; 204  : 				stosd
; 205  : 				stosd
; 206  : 			}
; 207  : 		return;
; 208  : 
; 209  : 		case 4:
; 210  : 			__asm
; 211  : 			{
; 212  : 				cld;
; 213  : 				mov edi, dest
; 214  : 				xor eax, eax
; 215  : 				stosd
; 216  : 				stosd
; 217  : 				stosd
; 218  : 				stosd
; 219  : 			}
; 220  : 		return;
; 221  : 
; 222  : 		case 5:
; 223  : 			__asm
; 224  : 			{
; 225  : 				cld;
; 226  : 				mov edi, dest
; 227  : 				xor eax, eax
; 228  : 				stosd
; 229  : 				stosd
; 230  : 				stosd
; 231  : 				stosd
; 232  : 				stosd
; 233  : 			}
; 234  : 		return;
; 235  : 
; 236  : 		default:
; 237  : 			__asm
; 238  : 			{
; 239  : 				cld;
; 240  : 				mov ecx, remdat
; 241  : 				mov edi, dest
; 242  : 				xor eax, eax
; 243  : 				rep stosd
; 244  : 			}
; 245  : 		return;
; 246  : 	}
; 247  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@memzero_pt:

; 122  : 				}
; 123  : 				return;
; 124  : 			}
; 125  : 		}
; 126  : 		else if( bytes128 > 48 )
; 127  : 		{
; 128  : 			// ALIGNED COPY MODE
; 129  : 			// Data is aligned and the size of data is large enough to merit a nice
; 130  : 			// fancy chunk of unrolled goodness:
; 131  : 
; 132  : 			__asm
; 133  : 			{
; 134  : 				movups _xmm_backup,xmm0;

	movups	XMMWORD PTR __xmm_backup$1[ebp], xmm0

; 135  : 				mov ecx,dest

	mov	ecx, DWORD PTR _dest$[ebp]

; 136  : 				pxor xmm0,xmm0

	pxor	xmm0, xmm0

; 137  : 				mov eax,bytes128

	mov	eax, 600576				; 00092a00H
	npad	3
$_loop_8$22:

; 138  : 
; 139  : 				align 16
; 140  : 
; 141  : 			_loop_8:
; 142  : 				movaps [ecx],xmm0;

	movaps	XMMWORD PTR [ecx], xmm0

; 143  : 				movaps [ecx+0x10],xmm0;

	movaps	XMMWORD PTR [ecx+16], xmm0

; 144  : 				movaps [ecx+0x20],xmm0;

	movaps	XMMWORD PTR [ecx+32], xmm0

; 145  : 				movaps [ecx+0x30],xmm0;

	movaps	XMMWORD PTR [ecx+48], xmm0

; 146  : 				movaps [ecx+0x40],xmm0;

	movaps	XMMWORD PTR [ecx+64], xmm0

; 147  : 				movaps [ecx+0x50],xmm0;

	movaps	XMMWORD PTR [ecx+80], xmm0

; 148  : 				movaps [ecx+0x60],xmm0;

	movaps	XMMWORD PTR [ecx+96], xmm0

; 149  : 				movaps [ecx+0x70],xmm0;

	movaps	XMMWORD PTR [ecx+112], xmm0

; 150  : 				sub ecx,-128

	sub	ecx, -128				; ffffff80H

; 151  : 				dec eax;

	dec	eax

; 152  : 				jnz _loop_8;

	jne	SHORT $_loop_8$22

; 153  : 			}
; 154  : 			if( remainder != 0 )
; 155  : 			{
; 156  : 				// Copy the remainder in reverse (using the decrementing eax as our indexer)
; 157  : 				__asm
; 158  : 				{
; 159  : 					mov eax, remainder
; 160  : 
; 161  : 				_loop_10:
; 162  : 					movaps [ecx+eax],xmm0;
; 163  : 					sub eax,16;
; 164  : 					jnz _loop_10;
; 165  : 				}
; 166  : 			}
; 167  : 			__asm
; 168  : 			{
; 169  : 				movups xmm0,[_xmm_backup];

	movups	xmm0, XMMWORD PTR __xmm_backup$1[ebp]

; 170  : 			}
; 171  : 			return;
; 172  : 		}
; 173  : 	}
; 174  : 
; 175  : 	// This function only works on 32-bit alignments.
; 176  : 	jASSUME( (bytes & 0x3) == 0 );
; 177  : 	jASSUME( ((uptr)dest & 0x3) == 0 );
; 178  : 
; 179  : 	enum
; 180  : 	{
; 181  : 		remdat = bytes>>2
; 182  : 	};
; 183  : 
; 184  : 	// This case statement handles 5 special-case sizes (small blocks)
; 185  : 	// in addition to the generic large block that uses rep stosd.
; 186  : 
; 187  : 	switch( remdat )
; 188  : 	{
; 189  : 		case 1:
; 190  : 			*(u32*)dest = 0;
; 191  : 		return;
; 192  : 
; 193  : 		case 2:
; 194  : 			*(u64*)dest = 0;
; 195  : 		return;
; 196  : 
; 197  : 		case 3:
; 198  : 			__asm
; 199  : 			{
; 200  : 				cld;
; 201  : 				mov edi, dest
; 202  : 				xor eax, eax
; 203  : 				stosd
; 204  : 				stosd
; 205  : 				stosd
; 206  : 			}
; 207  : 		return;
; 208  : 
; 209  : 		case 4:
; 210  : 			__asm
; 211  : 			{
; 212  : 				cld;
; 213  : 				mov edi, dest
; 214  : 				xor eax, eax
; 215  : 				stosd
; 216  : 				stosd
; 217  : 				stosd
; 218  : 				stosd
; 219  : 			}
; 220  : 		return;
; 221  : 
; 222  : 		case 5:
; 223  : 			__asm
; 224  : 			{
; 225  : 				cld;
; 226  : 				mov edi, dest
; 227  : 				xor eax, eax
; 228  : 				stosd
; 229  : 				stosd
; 230  : 				stosd
; 231  : 				stosd
; 232  : 				stosd
; 233  : 			}
; 234  : 		return;
; 235  : 
; 236  : 		default:
; 237  : 			__asm
; 238  : 			{
; 239  : 				cld;
; 240  : 				mov ecx, remdat
; 241  : 				mov edi, dest
; 242  : 				xor eax, eax
; 243  : 				rep stosd
; 244  : 			}
; 245  : 		return;
; 246  : 	}
; 247  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$memzero_ptr@$0EJFAAAA@@@YAXPAX@Z ENDP		; memzero_ptr<76873728>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File d:\downloads\development\pcsx2-rr-lua\pcsx2\windows\memzero.h
_TEXT	SEGMENT
__xmm_backup$1 = -20					; size = 16
_dest$ = -4						; size = 4
??$memzero_ptr@$0EAAAA@@@YAXPAX@Z PROC			; memzero_ptr<262144>
; _dest$dead$ = ecx

; 50   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ?recLUT@@3PAIA		; recLUT
	mov	DWORD PTR _dest$[ebp], eax

; 51   : 	if( bytes == 0 ) return;
; 52   : 
; 53   : 	// This function only works on 32-bit alignments.  For anything else we just fall back
; 54   : 	// on the compiler-provided implementation of memset...
; 55   : 
; 56   : 	if( (bytes & 0x3) != 0 )
; 57   : 	{
; 58   : 		memset( dest, 0, bytes );
; 59   : 		return;
; 60   : 	}
; 61   : 
; 62   : 	enum
; 63   : 	{
; 64   : 		remainder = bytes & 127,
; 65   : 		bytes128 = bytes / 128
; 66   : 	};
; 67   : 
; 68   : 	// Initial check -- if the length is not a multiple of 16 then fall back on
; 69   : 	// using rep movsd methods.  Handling these unaligned clears in a more efficient
; 70   : 	// manner isn't necessary in pcsx2 (meaning they aren't used in speed-critical
; 71   : 	// scenarios).
; 72   : 
; 73   : 	if( (bytes & 0xf) == 0 )
; 74   : 	{
; 75   : 		u64 _xmm_backup[2];
; 76   : 
; 77   : 		if( ((uptr)dest & 0xf) != 0 )

	test	al, 15					; 0000000fH
	je	SHORT $LN14@memzero_pt

; 78   : 		{
; 79   : 			// UNALIGNED COPY MODE.
; 80   : 			// For unaligned copies we have a threshold of at least 128 vectors.  Anything
; 81   : 			// less and it's probably better off just falling back on the rep movsd.
; 82   : 			if( bytes128 > 128 )
; 83   : 			{
; 84   : 				__asm
; 85   : 				{
; 86   : 					movups _xmm_backup,xmm0;

	movups	XMMWORD PTR __xmm_backup$1[ebp], xmm0

; 87   : 					mov ecx,dest

	mov	ecx, DWORD PTR _dest$[ebp]

; 88   : 					pxor xmm0,xmm0

	pxor	xmm0, xmm0

; 89   : 					mov eax,bytes128

	mov	eax, 2048				; 00000800H
	npad	14
$_loop_6$21:

; 90   : 
; 91   : 					align 16
; 92   : 
; 93   : 				_loop_6:
; 94   : 					movups [ecx],xmm0;

	movups	XMMWORD PTR [ecx], xmm0

; 95   : 					movups [ecx+0x10],xmm0;

	movups	XMMWORD PTR [ecx+16], xmm0

; 96   : 					movups [ecx+0x20],xmm0;

	movups	XMMWORD PTR [ecx+32], xmm0

; 97   : 					movups [ecx+0x30],xmm0;

	movups	XMMWORD PTR [ecx+48], xmm0

; 98   : 					movups [ecx+0x40],xmm0;

	movups	XMMWORD PTR [ecx+64], xmm0

; 99   : 					movups [ecx+0x50],xmm0;

	movups	XMMWORD PTR [ecx+80], xmm0

; 100  : 					movups [ecx+0x60],xmm0;

	movups	XMMWORD PTR [ecx+96], xmm0

; 101  : 					movups [ecx+0x70],xmm0;

	movups	XMMWORD PTR [ecx+112], xmm0

; 102  : 					sub ecx,-128

	sub	ecx, -128				; ffffff80H

; 103  : 					dec eax;

	dec	eax

; 104  : 					jnz _loop_6;

	jne	SHORT $_loop_6$21

; 105  : 				}
; 106  : 				if( remainder != 0 )
; 107  : 				{
; 108  : 					// Copy the remainder in reverse (using the decrementing eax as our indexer)
; 109  : 					__asm
; 110  : 					{
; 111  : 						mov eax, remainder
; 112  : 
; 113  : 					_loop_5:
; 114  : 						movups [ecx+eax],xmm0;
; 115  : 						sub eax,16;
; 116  : 						jnz _loop_5;
; 117  : 					}
; 118  : 				}
; 119  : 				__asm
; 120  : 				{
; 121  : 					movups xmm0,[_xmm_backup];

	movups	xmm0, XMMWORD PTR __xmm_backup$1[ebp]

; 170  : 			}
; 171  : 			return;
; 172  : 		}
; 173  : 	}
; 174  : 
; 175  : 	// This function only works on 32-bit alignments.
; 176  : 	jASSUME( (bytes & 0x3) == 0 );
; 177  : 	jASSUME( ((uptr)dest & 0x3) == 0 );
; 178  : 
; 179  : 	enum
; 180  : 	{
; 181  : 		remdat = bytes>>2
; 182  : 	};
; 183  : 
; 184  : 	// This case statement handles 5 special-case sizes (small blocks)
; 185  : 	// in addition to the generic large block that uses rep stosd.
; 186  : 
; 187  : 	switch( remdat )
; 188  : 	{
; 189  : 		case 1:
; 190  : 			*(u32*)dest = 0;
; 191  : 		return;
; 192  : 
; 193  : 		case 2:
; 194  : 			*(u64*)dest = 0;
; 195  : 		return;
; 196  : 
; 197  : 		case 3:
; 198  : 			__asm
; 199  : 			{
; 200  : 				cld;
; 201  : 				mov edi, dest
; 202  : 				xor eax, eax
; 203  : 				stosd
; 204  : 				stosd
; 205  : 				stosd
; 206  : 			}
; 207  : 		return;
; 208  : 
; 209  : 		case 4:
; 210  : 			__asm
; 211  : 			{
; 212  : 				cld;
; 213  : 				mov edi, dest
; 214  : 				xor eax, eax
; 215  : 				stosd
; 216  : 				stosd
; 217  : 				stosd
; 218  : 				stosd
; 219  : 			}
; 220  : 		return;
; 221  : 
; 222  : 		case 5:
; 223  : 			__asm
; 224  : 			{
; 225  : 				cld;
; 226  : 				mov edi, dest
; 227  : 				xor eax, eax
; 228  : 				stosd
; 229  : 				stosd
; 230  : 				stosd
; 231  : 				stosd
; 232  : 				stosd
; 233  : 			}
; 234  : 		return;
; 235  : 
; 236  : 		default:
; 237  : 			__asm
; 238  : 			{
; 239  : 				cld;
; 240  : 				mov ecx, remdat
; 241  : 				mov edi, dest
; 242  : 				xor eax, eax
; 243  : 				rep stosd
; 244  : 			}
; 245  : 		return;
; 246  : 	}
; 247  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@memzero_pt:

; 122  : 				}
; 123  : 				return;
; 124  : 			}
; 125  : 		}
; 126  : 		else if( bytes128 > 48 )
; 127  : 		{
; 128  : 			// ALIGNED COPY MODE
; 129  : 			// Data is aligned and the size of data is large enough to merit a nice
; 130  : 			// fancy chunk of unrolled goodness:
; 131  : 
; 132  : 			__asm
; 133  : 			{
; 134  : 				movups _xmm_backup,xmm0;

	movups	XMMWORD PTR __xmm_backup$1[ebp], xmm0

; 135  : 				mov ecx,dest

	mov	ecx, DWORD PTR _dest$[ebp]

; 136  : 				pxor xmm0,xmm0

	pxor	xmm0, xmm0

; 137  : 				mov eax,bytes128

	mov	eax, 2048				; 00000800H
	npad	3
$_loop_8$22:

; 138  : 
; 139  : 				align 16
; 140  : 
; 141  : 			_loop_8:
; 142  : 				movaps [ecx],xmm0;

	movaps	XMMWORD PTR [ecx], xmm0

; 143  : 				movaps [ecx+0x10],xmm0;

	movaps	XMMWORD PTR [ecx+16], xmm0

; 144  : 				movaps [ecx+0x20],xmm0;

	movaps	XMMWORD PTR [ecx+32], xmm0

; 145  : 				movaps [ecx+0x30],xmm0;

	movaps	XMMWORD PTR [ecx+48], xmm0

; 146  : 				movaps [ecx+0x40],xmm0;

	movaps	XMMWORD PTR [ecx+64], xmm0

; 147  : 				movaps [ecx+0x50],xmm0;

	movaps	XMMWORD PTR [ecx+80], xmm0

; 148  : 				movaps [ecx+0x60],xmm0;

	movaps	XMMWORD PTR [ecx+96], xmm0

; 149  : 				movaps [ecx+0x70],xmm0;

	movaps	XMMWORD PTR [ecx+112], xmm0

; 150  : 				sub ecx,-128

	sub	ecx, -128				; ffffff80H

; 151  : 				dec eax;

	dec	eax

; 152  : 				jnz _loop_8;

	jne	SHORT $_loop_8$22

; 153  : 			}
; 154  : 			if( remainder != 0 )
; 155  : 			{
; 156  : 				// Copy the remainder in reverse (using the decrementing eax as our indexer)
; 157  : 				__asm
; 158  : 				{
; 159  : 					mov eax, remainder
; 160  : 
; 161  : 				_loop_10:
; 162  : 					movaps [ecx+eax],xmm0;
; 163  : 					sub eax,16;
; 164  : 					jnz _loop_10;
; 165  : 				}
; 166  : 			}
; 167  : 			__asm
; 168  : 			{
; 169  : 				movups xmm0,[_xmm_backup];

	movups	xmm0, XMMWORD PTR __xmm_backup$1[ebp]

; 170  : 			}
; 171  : 			return;
; 172  : 		}
; 173  : 	}
; 174  : 
; 175  : 	// This function only works on 32-bit alignments.
; 176  : 	jASSUME( (bytes & 0x3) == 0 );
; 177  : 	jASSUME( ((uptr)dest & 0x3) == 0 );
; 178  : 
; 179  : 	enum
; 180  : 	{
; 181  : 		remdat = bytes>>2
; 182  : 	};
; 183  : 
; 184  : 	// This case statement handles 5 special-case sizes (small blocks)
; 185  : 	// in addition to the generic large block that uses rep stosd.
; 186  : 
; 187  : 	switch( remdat )
; 188  : 	{
; 189  : 		case 1:
; 190  : 			*(u32*)dest = 0;
; 191  : 		return;
; 192  : 
; 193  : 		case 2:
; 194  : 			*(u64*)dest = 0;
; 195  : 		return;
; 196  : 
; 197  : 		case 3:
; 198  : 			__asm
; 199  : 			{
; 200  : 				cld;
; 201  : 				mov edi, dest
; 202  : 				xor eax, eax
; 203  : 				stosd
; 204  : 				stosd
; 205  : 				stosd
; 206  : 			}
; 207  : 		return;
; 208  : 
; 209  : 		case 4:
; 210  : 			__asm
; 211  : 			{
; 212  : 				cld;
; 213  : 				mov edi, dest
; 214  : 				xor eax, eax
; 215  : 				stosd
; 216  : 				stosd
; 217  : 				stosd
; 218  : 				stosd
; 219  : 			}
; 220  : 		return;
; 221  : 
; 222  : 		case 5:
; 223  : 			__asm
; 224  : 			{
; 225  : 				cld;
; 226  : 				mov edi, dest
; 227  : 				xor eax, eax
; 228  : 				stosd
; 229  : 				stosd
; 230  : 				stosd
; 231  : 				stosd
; 232  : 				stosd
; 233  : 			}
; 234  : 		return;
; 235  : 
; 236  : 		default:
; 237  : 			__asm
; 238  : 			{
; 239  : 				cld;
; 240  : 				mov ecx, remdat
; 241  : 				mov edi, dest
; 242  : 				xor eax, eax
; 243  : 				rep stosd
; 244  : 			}
; 245  : 		return;
; 246  : 	}
; 247  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$memzero_ptr@$0EAAAA@@@YAXPAX@Z ENDP			; memzero_ptr<262144>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
;	COMDAT ??$max@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
??$max@I@std@@YAABIABI0@Z PROC				; std::max<unsigned int>, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 4088 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	cmovb	ecx, edx
	mov	eax, ecx

; 4089 : 	}

	ret	0
??$max@I@std@@YAABIABI0@Z ENDP				; std::max<unsigned int>
_TEXT	ENDS
END
