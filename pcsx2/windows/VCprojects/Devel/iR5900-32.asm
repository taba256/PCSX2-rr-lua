; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	f:\Emu\ps2\src\pcsx2\x86\ix86-32\iR5900-32.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	?recClear@@YAXII@Z				; recClear
PUBLIC	?recExecute@@YAXXZ				; recExecute
PUBLIC	?recStep@@YAXXZ					; recStep
PUBLIC	?recResetEE@@YAXXZ				; recResetEE
PUBLIC	?GetFnptr@BASEBLOCK@@QBE?BIXZ			; BASEBLOCK::GetFnptr
PUBLIC	?SetFnptr@BASEBLOCK@@QAEXI@Z			; BASEBLOCK::SetFnptr
PUBLIC	??$max@I@std@@YAABIABI0@Z			; std::max<unsigned int>
PUBLIC	??0HardwareDeficiency@Exception@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Exception::HardwareDeficiency::HardwareDeficiency
PUBLIC	??1HardwareDeficiency@Exception@@UAE@XZ		; Exception::HardwareDeficiency::~HardwareDeficiency
PUBLIC	??_GHardwareDeficiency@Exception@@UAEPAXI@Z	; Exception::HardwareDeficiency::`scalar deleting destructor'
PUBLIC	??0HardwareDeficiency@Exception@@QAE@ABV01@@Z	; Exception::HardwareDeficiency::HardwareDeficiency
PUBLIC	?pc@@3IA					; pc
PUBLIC	?branch@@3HA					; branch
PUBLIC	?s_ConstGPRreg@@3TGPR_reg64@@A			; s_ConstGPRreg
PUBLIC	?g_EEFreezeRegs@@3_NA				; g_EEFreezeRegs
PUBLIC	?maxrecmem@@3IA					; maxrecmem
PUBLIC	?recLUT@@3PAIA					; recLUT
PUBLIC	?s_nBlockCycles@@3IA				; s_nBlockCycles
PUBLIC	?g_cpuConstRegs@@3PATGPR_reg64@@A		; g_cpuConstRegs
PUBLIC	?g_cpuHasConstReg@@3IA				; g_cpuHasConstReg
PUBLIC	?g_cpuFlushedConstReg@@3IA			; g_cpuFlushedConstReg
PUBLIC	?s_saveConstGPRreg@@3IA				; s_saveConstGPRreg
PUBLIC	?s_pDispatchBlock@@3PBUBASEBLOCK@@B		; s_pDispatchBlock
PUBLIC	??_C@_0BO@BJGNDGDH@Processor?5doesn?8t?5support?5MMX?$AA@ ; `string'
PUBLIC	??_C@_0BO@EAHPPEPN@Processor?5doesn?8t?5support?5SSE?$AA@ ; `string'
PUBLIC	??_C@_0BP@CODMKFCE@Processor?5doesn?8t?5support?5SSE2?$AA@ ; `string'
PUBLIC	??_C@_0BA@GOFBLDMA@recAlloc?$CIR5900?$CJ?$AA@	; `string'
PUBLIC	??_C@_0DB@KMMEHCKA@R5900?932?5?$DO?5failed?5to?5allocate?5re@ ; `string'
PUBLIC	??_C@_0EA@NGEJMDFP@R5900?932?5Init?5?$DO?5Failed?5to?5alloca@ ; `string'
PUBLIC	??_C@_0DK@KMFNGPCI@R5900?932?5Init?5?$DO?5failed?5to?5alloca@ ; `string'
PUBLIC	??_C@_05OAHDOEDM@EERec?$AA@			; `string'
PUBLIC	??_R0?AVHardwareDeficiency@Exception@@@8	; Exception::HardwareDeficiency `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVHardwareDeficiency@Exception@@@8??0HardwareDeficiency@Exception@@QAE@ABV01@@Z32
PUBLIC	__CTA3?AVHardwareDeficiency@Exception@@
PUBLIC	__TI3?AVHardwareDeficiency@Exception@@
PUBLIC	??_C@_0DF@HHKJLMIF@Pcsx2?5Foopah?$CB?5?5Frozen?5regs?5have?5@ ; `string'
PUBLIC	??_C@_0O@HOCNDIGO@delay?5slot?5?$CFx?$AA@	; `string'
PUBLIC	??_C@_0BJ@BNOPKFMB@branch?5?$CFx?5in?5delay?5slot?$CB?$AA@ ; `string'
PUBLIC	?s_recblocks@@3PAIA				; s_recblocks
PUBLIC	??_C@_08HNLAIHMJ@Bad?5esp?$CB?$AA@		; `string'
PUBLIC	??_C@_0CD@COAJMALJ@dyna_block_discard?5?$CF08X?5?0?5count?5@ ; `string'
PUBLIC	??_C@_0BJ@KGMIHJML@EE?5Recompiler?5data?5reset?$AA@ ; `string'
PUBLIC	??_C@_0BK@FEKONKNL@EE?5recompiler?5stack?5reset?$AA@ ; `string'
PUBLIC	?recCpu@@3UR5900cpu@@A				; recCpu
PUBLIC	??_7HardwareDeficiency@Exception@@6B@		; Exception::HardwareDeficiency::`vftable'
EXTRN	__aligned_malloc:PROC
EXTRN	??_EHardwareDeficiency@Exception@@UAEPAXI@Z:PROC ; Exception::HardwareDeficiency::`vector deleting destructor'
EXTRN	__aligned_free:PROC
?pc@@3IA DD	01H DUP (?)				; pc
?branch@@3HA DD	01H DUP (?)				; branch
?s_ConstGPRreg@@3TGPR_reg64@@A DB 010H DUP (?)		; s_ConstGPRreg
?g_EEFreezeRegs@@3_NA DB 01H DUP (?)			; g_EEFreezeRegs
	ALIGN	4

?maxrecmem@@3IA DD 01H DUP (?)				; maxrecmem
?recLUT@@3PAIA DD 01H DUP (?)				; recLUT
?s_nBlockCycles@@3IA DD 01H DUP (?)			; s_nBlockCycles
?g_cpuConstRegs@@3PATGPR_reg64@@A DB 0200H DUP (?)	; g_cpuConstRegs
?g_cpuHasConstReg@@3IA DD 01H DUP (?)			; g_cpuHasConstReg
?g_cpuFlushedConstReg@@3IA DD 01H DUP (?)		; g_cpuFlushedConstReg
?s_saveConstGPRreg@@3IA DD 01H DUP (?)			; s_saveConstGPRreg
_recMem	DD	01H DUP (?)
_recStack DD	01H DUP (?)
_recRAM	DD	01H DUP (?)
_recROM	DD	01H DUP (?)
_recROM1 DD	01H DUP (?)
_recBlocks DD	01H DUP (?)
_recPtr	DD	01H DUP (?)
_recStackPtr DD	01H DUP (?)
_s_pInstCache DD 01H DUP (?)
_s_nInstCacheSize DD 01H DUP (?)
_s_pCurBlock DD	01H DUP (?)
_s_pCurBlockEx DD 01H DUP (?)
?s_pDispatchBlock@@3PBUBASEBLOCK@@B DD 01H DUP (?)	; s_pDispatchBlock
_s_nEndBlock DD	01H DUP (?)
_s_nHasDelay DD	01H DUP (?)
_s_nNextBlock DD 01H DUP (?)
_s_saveHasConstReg DD 01H DUP (?)
_s_saveFlushedConstReg DD 01H DUP (?)
_s_saveRegHasLive1 DD 01H DUP (?)
_s_saveRegHasSignExt DD 01H DUP (?)
_s_psaveInstInfo DD 01H DUP (?)
_s_savenBlockCycles DD 01H DUP (?)
_m_recBlockAlloc DD 01H DUP (?)
?s_recblocks@@3PAIA DD 01H DUP (?)			; s_recblocks
;	COMDAT ??_7HardwareDeficiency@Exception@@6B@
CONST	SEGMENT
??_7HardwareDeficiency@Exception@@6B@ DD FLAT:??_EHardwareDeficiency@Exception@@UAEPAXI@Z ; Exception::HardwareDeficiency::`vftable'
CONST	ENDS
;	COMDAT ??_C@_0BK@FEKONKNL@EE?5recompiler?5stack?5reset?$AA@
CONST	SEGMENT
??_C@_0BK@FEKONKNL@EE?5recompiler?5stack?5reset?$AA@ DB 'EE recompiler st'
	DB	'ack reset', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@KGMIHJML@EE?5Recompiler?5data?5reset?$AA@
CONST	SEGMENT
??_C@_0BJ@KGMIHJML@EE?5Recompiler?5data?5reset?$AA@ DB 'EE Recompiler dat'
	DB	'a reset', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@COAJMALJ@dyna_block_discard?5?$CF08X?5?0?5count?5@
CONST	SEGMENT
??_C@_0CD@COAJMALJ@dyna_block_discard?5?$CF08X?5?0?5count?5@ DB 'dyna_blo'
	DB	'ck_discard %08X , count %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08HNLAIHMJ@Bad?5esp?$CB?$AA@
CONST	SEGMENT
??_C@_08HNLAIHMJ@Bad?5esp?$CB?$AA@ DB 'Bad esp!', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BNOPKFMB@branch?5?$CFx?5in?5delay?5slot?$CB?$AA@
CONST	SEGMENT
??_C@_0BJ@BNOPKFMB@branch?5?$CFx?5in?5delay?5slot?$CB?$AA@ DB 'branch %x '
	DB	'in delay slot!', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HOCNDIGO@delay?5slot?5?$CFx?$AA@
CONST	SEGMENT
??_C@_0O@HOCNDIGO@delay?5slot?5?$CFx?$AA@ DB 'delay slot %x', 00H ; `string'
CONST	ENDS
;	COMDAT ?s_bFlushReg@?1??recompileNextInstruction@@YAXH@Z@4EA
_DATA	SEGMENT
?s_bFlushReg@?1??recompileNextInstruction@@YAXH@Z@4EA DB 01H ; `recompileNextInstruction'::`2'::s_bFlushReg
_DATA	ENDS
;	COMDAT ??_C@_0DF@HHKJLMIF@Pcsx2?5Foopah?$CB?5?5Frozen?5regs?5have?5@
CONST	SEGMENT
??_C@_0DF@HHKJLMIF@Pcsx2?5Foopah?$CB?5?5Frozen?5regs?5have?5@ DB 'Pcsx2 F'
	DB	'oopah!  Frozen regs have not been restored!!!', 00H ; `string'
CONST	ENDS
;	COMDAT __TI3?AVHardwareDeficiency@Exception@@
xdata$x	SEGMENT
__TI3?AVHardwareDeficiency@Exception@@ DD 00H
	DD	FLAT:??1HardwareDeficiency@Exception@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVHardwareDeficiency@Exception@@
xdata$x	ENDS
;	COMDAT __CTA3?AVHardwareDeficiency@Exception@@
xdata$x	SEGMENT
__CTA3?AVHardwareDeficiency@Exception@@ DD 03H
	DD	FLAT:__CT??_R0?AVHardwareDeficiency@Exception@@@8??0HardwareDeficiency@Exception@@QAE@ABV01@@Z32
	DD	FLAT:__CT??_R0?AVRuntimeError@Exception@@@8??0RuntimeError@Exception@@QAE@ABV01@@Z32
	DD	FLAT:__CT??_R0?AVBaseException@Exception@@@8??0BaseException@Exception@@QAE@ABV01@@Z32
xdata$x	ENDS
;	COMDAT __CT??_R0?AVHardwareDeficiency@Exception@@@8??0HardwareDeficiency@Exception@@QAE@ABV01@@Z32
xdata$x	SEGMENT
__CT??_R0?AVHardwareDeficiency@Exception@@@8??0HardwareDeficiency@Exception@@QAE@ABV01@@Z32 DD 00H
	DD	FLAT:??_R0?AVHardwareDeficiency@Exception@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	020H
	DD	FLAT:??0HardwareDeficiency@Exception@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVHardwareDeficiency@Exception@@@8
_DATA	SEGMENT
??_R0?AVHardwareDeficiency@Exception@@@8 DD FLAT:??_7type_info@@6B@ ; Exception::HardwareDeficiency `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVHardwareDeficiency@Exception@@', 00H
_DATA	ENDS
;	COMDAT ??_C@_05OAHDOEDM@EERec?$AA@
CONST	SEGMENT
??_C@_05OAHDOEDM@EERec?$AA@ DB 'EERec', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@KMFNGPCI@R5900?932?5Init?5?$DO?5failed?5to?5alloca@
CONST	SEGMENT
??_C@_0DK@KMFNGPCI@R5900?932?5Init?5?$DO?5failed?5to?5alloca@ DB 'R5900-3'
	DB	'2 Init > failed to allocate memory for pInstCache.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@NGEJMDFP@R5900?932?5Init?5?$DO?5Failed?5to?5alloca@
CONST	SEGMENT
??_C@_0EA@NGEJMDFP@R5900?932?5Init?5?$DO?5Failed?5to?5alloca@ DB 'R5900-3'
	DB	'2 Init > Failed to allocate memory for BASEBLOCK tables.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@KMMEHCKA@R5900?932?5?$DO?5failed?5to?5allocate?5re@
CONST	SEGMENT
??_C@_0DB@KMMEHCKA@R5900?932?5?$DO?5failed?5to?5allocate?5re@ DB 'R5900-3'
	DB	'2 > failed to allocate recompiler memory.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GOFBLDMA@recAlloc?$CIR5900?$CJ?$AA@
CONST	SEGMENT
??_C@_0BA@GOFBLDMA@recAlloc?$CIR5900?$CJ?$AA@ DB 'recAlloc(R5900)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@CODMKFCE@Processor?5doesn?8t?5support?5SSE2?$AA@
CONST	SEGMENT
??_C@_0BP@CODMKFCE@Processor?5doesn?8t?5support?5SSE2?$AA@ DB 'Processor '
	DB	'doesn''t support SSE2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@EAHPPEPN@Processor?5doesn?8t?5support?5SSE?$AA@
CONST	SEGMENT
??_C@_0BO@EAHPPEPN@Processor?5doesn?8t?5support?5SSE?$AA@ DB 'Processor d'
	DB	'oesn''t support SSE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@BJGNDGDH@Processor?5doesn?8t?5support?5MMX?$AA@
CONST	SEGMENT
??_C@_0BO@BJGNDGDH@Processor?5doesn?8t?5support?5MMX?$AA@ DB 'Processor d'
	DB	'oesn''t support MMX', 00H			; `string'
	ORG $+165632
?recCpu@@3UR5900cpu@@A DD FLAT:?recAlloc@@YAXXZ		; recCpu
	DD	FLAT:?recResetEE@@YAXXZ
	DD	FLAT:?recStep@@YAXXZ
	DD	FLAT:?recExecute@@YAXXZ
	DD	FLAT:?recExecuteBlock@@YAXXZ
	DD	FLAT:?recClear@@YAXII@Z
	DD	FLAT:?recShutdown@@YAXXZ
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$max@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
??$max@I@std@@YAABIABI0@Z PROC				; std::max<unsigned int>, COMDAT
; __Left$ = ecx
; __Right$ = eax

; 3384 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax]
	jb	SHORT $LN4@max
	mov	eax, ecx
$LN4@max:

; 3385 : 	}

	ret	0
??$max@I@std@@YAABIABI0@Z ENDP				; std::max<unsigned int>
; Function compile flags: /Ogtpy
; File f:\emu\ps2\src\pcsx2\windows\memzero.h
_TEXT	ENDS
_TEXT	SEGMENT
__xmm_backup$89780 = -20				; size = 16
_dest$ = -4						; size = 4
??$memzero_ptr@$0EAAAA@@@YAXPAX@Z PROC			; memzero_ptr<262144>

; 50   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ?recLUT@@3PAIA		; recLUT

; 51   : 	if( bytes == 0 ) return;
; 52   : 
; 53   : 	// This function only works on 32-bit alignments.  For anything else we just fall back
; 54   : 	// on the compiler-provided implementation of memset...
; 55   : 
; 56   : 	if( (bytes & 0x3) != 0 )
; 57   : 	{
; 58   : 		memset( dest, 0, bytes );
; 59   : 		return;
; 60   : 	}
; 61   : 
; 62   : 	enum
; 63   : 	{
; 64   : 		remainder = bytes & 127,
; 65   : 		bytes128 = bytes / 128
; 66   : 	};
; 67   : 
; 68   : 	// Initial check -- if the length is not a multiple of 16 then fall back on
; 69   : 	// using rep movsd methods.  Handling these unaligned clears in a more efficient
; 70   : 	// manner isn't necessary in pcsx2 (meaning they aren't used in speed-critical
; 71   : 	// scenarios).
; 72   : 
; 73   : 	if( (bytes & 0xf) == 0 )
; 74   : 	{
; 75   : 		u64 _xmm_backup[2];
; 76   : 
; 77   : 		if( ((uptr)dest & 0xf) != 0 )

	mov	DWORD PTR _dest$[ebp], eax
	test	al, 15					; 0000000fH
	je	SHORT $LN14@memzero_pt

; 78   : 		{
; 79   : 			// UNALIGNED COPY MODE.
; 80   : 			// For unaligned copies we have a threshold of at least 128 vectors.  Anything
; 81   : 			// less and it's probably better off just falling back on the rep movsd.
; 82   : 			if( bytes128 > 128 )
; 83   : 			{
; 84   : 				__asm
; 85   : 				{
; 86   : 					movups _xmm_backup,xmm0;

	movups	XMMWORD PTR __xmm_backup$89780[ebp], xmm0

; 87   : 					mov ecx,dest

	mov	ecx, DWORD PTR _dest$[ebp]

; 88   : 					pxor xmm0,xmm0

	pxor	xmm0, xmm0

; 89   : 					mov eax,bytes128

	mov	eax, 2048				; 00000800H
	npad	14
$_loop_6$89784:

; 90   : 
; 91   : 					align 16
; 92   : 
; 93   : 				_loop_6:
; 94   : 					movups [ecx],xmm0;

	movups	XMMWORD PTR [ecx], xmm0

; 95   : 					movups [ecx+0x10],xmm0;

	movups	XMMWORD PTR [ecx+16], xmm0

; 96   : 					movups [ecx+0x20],xmm0;

	movups	XMMWORD PTR [ecx+32], xmm0

; 97   : 					movups [ecx+0x30],xmm0;

	movups	XMMWORD PTR [ecx+48], xmm0

; 98   : 					movups [ecx+0x40],xmm0;

	movups	XMMWORD PTR [ecx+64], xmm0

; 99   : 					movups [ecx+0x50],xmm0;

	movups	XMMWORD PTR [ecx+80], xmm0

; 100  : 					movups [ecx+0x60],xmm0;

	movups	XMMWORD PTR [ecx+96], xmm0

; 101  : 					movups [ecx+0x70],xmm0;

	movups	XMMWORD PTR [ecx+112], xmm0

; 102  : 					sub ecx,-128

	sub	ecx, -128				; ffffff80H

; 103  : 					dec eax;

	dec	eax

; 104  : 					jnz _loop_6;

	jne	SHORT $_loop_6$89784

; 105  : 				}
; 106  : 				if( remainder != 0 )
; 107  : 				{
; 108  : 					// Copy the remainder in reverse (using the decrementing eax as our indexer)
; 109  : 					__asm
; 110  : 					{
; 111  : 						mov eax, remainder
; 112  : 
; 113  : 					_loop_5:
; 114  : 						movups [ecx+eax],xmm0;
; 115  : 						sub eax,16;
; 116  : 						jnz _loop_5;
; 117  : 					}
; 118  : 				}
; 119  : 				__asm
; 120  : 				{
; 121  : 					movups xmm0,[_xmm_backup];

	movups	xmm0, XMMWORD PTR __xmm_backup$89780[ebp]

; 170  : 			}
; 171  : 			return;
; 172  : 		}
; 173  : 	}
; 174  : 
; 175  : 	// This function only works on 32-bit alignments.
; 176  : 	jASSUME( (bytes & 0x3) == 0 );
; 177  : 	jASSUME( ((uptr)dest & 0x3) == 0 );
; 178  : 
; 179  : 	enum
; 180  : 	{
; 181  : 		remdat = bytes>>2
; 182  : 	};
; 183  : 
; 184  : 	// This case statement handles 5 special-case sizes (small blocks)
; 185  : 	// in addition to the generic large block that uses rep stosd.
; 186  : 
; 187  : 	switch( remdat )
; 188  : 	{
; 189  : 		case 1:
; 190  : 			*(u32*)dest = 0;
; 191  : 		return;
; 192  : 
; 193  : 		case 2:
; 194  : 			*(u64*)dest = 0;
; 195  : 		return;
; 196  : 
; 197  : 		case 3:
; 198  : 			__asm
; 199  : 			{
; 200  : 				cld;
; 201  : 				mov edi, dest
; 202  : 				xor eax, eax
; 203  : 				stosd
; 204  : 				stosd
; 205  : 				stosd
; 206  : 			}
; 207  : 		return;
; 208  : 
; 209  : 		case 4:
; 210  : 			__asm
; 211  : 			{
; 212  : 				cld;
; 213  : 				mov edi, dest
; 214  : 				xor eax, eax
; 215  : 				stosd
; 216  : 				stosd
; 217  : 				stosd
; 218  : 				stosd
; 219  : 			}
; 220  : 		return;
; 221  : 
; 222  : 		case 5:
; 223  : 			__asm
; 224  : 			{
; 225  : 				cld;
; 226  : 				mov edi, dest
; 227  : 				xor eax, eax
; 228  : 				stosd
; 229  : 				stosd
; 230  : 				stosd
; 231  : 				stosd
; 232  : 				stosd
; 233  : 			}
; 234  : 		return;
; 235  : 
; 236  : 		default:
; 237  : 			__asm
; 238  : 			{
; 239  : 				cld;
; 240  : 				mov ecx, remdat
; 241  : 				mov edi, dest
; 242  : 				xor eax, eax
; 243  : 				rep stosd
; 244  : 			}
; 245  : 		return;
; 246  : 	}
; 247  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@memzero_pt:

; 122  : 				}
; 123  : 				return;
; 124  : 			}
; 125  : 		}
; 126  : 		else if( bytes128 > 48 )
; 127  : 		{
; 128  : 			// ALIGNED COPY MODE
; 129  : 			// Data is aligned and the size of data is large enough to merit a nice
; 130  : 			// fancy chunk of unrolled goodness:
; 131  : 
; 132  : 			__asm
; 133  : 			{
; 134  : 				movups _xmm_backup,xmm0;

	movups	XMMWORD PTR __xmm_backup$89780[ebp], xmm0

; 135  : 				mov ecx,dest

	mov	ecx, DWORD PTR _dest$[ebp]

; 136  : 				pxor xmm0,xmm0

	pxor	xmm0, xmm0

; 137  : 				mov eax,bytes128

	mov	eax, 2048				; 00000800H
	npad	3
$_loop_8$89789:

; 138  : 
; 139  : 				align 16
; 140  : 
; 141  : 			_loop_8:
; 142  : 				movaps [ecx],xmm0;

	movaps	XMMWORD PTR [ecx], xmm0

; 143  : 				movaps [ecx+0x10],xmm0;

	movaps	XMMWORD PTR [ecx+16], xmm0

; 144  : 				movaps [ecx+0x20],xmm0;

	movaps	XMMWORD PTR [ecx+32], xmm0

; 145  : 				movaps [ecx+0x30],xmm0;

	movaps	XMMWORD PTR [ecx+48], xmm0

; 146  : 				movaps [ecx+0x40],xmm0;

	movaps	XMMWORD PTR [ecx+64], xmm0

; 147  : 				movaps [ecx+0x50],xmm0;

	movaps	XMMWORD PTR [ecx+80], xmm0

; 148  : 				movaps [ecx+0x60],xmm0;

	movaps	XMMWORD PTR [ecx+96], xmm0

; 149  : 				movaps [ecx+0x70],xmm0;

	movaps	XMMWORD PTR [ecx+112], xmm0

; 150  : 				sub ecx,-128

	sub	ecx, -128				; ffffff80H

; 151  : 				dec eax;

	dec	eax

; 152  : 				jnz _loop_8;

	jne	SHORT $_loop_8$89789

; 153  : 			}
; 154  : 			if( remainder != 0 )
; 155  : 			{
; 156  : 				// Copy the remainder in reverse (using the decrementing eax as our indexer)
; 157  : 				__asm
; 158  : 				{
; 159  : 					mov eax, remainder
; 160  : 
; 161  : 				_loop_10:
; 162  : 					movaps [ecx+eax],xmm0;
; 163  : 					sub eax,16;
; 164  : 					jnz _loop_10;
; 165  : 				}
; 166  : 			}
; 167  : 			__asm
; 168  : 			{
; 169  : 				movups xmm0,[_xmm_backup];

	movups	xmm0, XMMWORD PTR __xmm_backup$89780[ebp]

; 170  : 			}
; 171  : 			return;
; 172  : 		}
; 173  : 	}
; 174  : 
; 175  : 	// This function only works on 32-bit alignments.
; 176  : 	jASSUME( (bytes & 0x3) == 0 );
; 177  : 	jASSUME( ((uptr)dest & 0x3) == 0 );
; 178  : 
; 179  : 	enum
; 180  : 	{
; 181  : 		remdat = bytes>>2
; 182  : 	};
; 183  : 
; 184  : 	// This case statement handles 5 special-case sizes (small blocks)
; 185  : 	// in addition to the generic large block that uses rep stosd.
; 186  : 
; 187  : 	switch( remdat )
; 188  : 	{
; 189  : 		case 1:
; 190  : 			*(u32*)dest = 0;
; 191  : 		return;
; 192  : 
; 193  : 		case 2:
; 194  : 			*(u64*)dest = 0;
; 195  : 		return;
; 196  : 
; 197  : 		case 3:
; 198  : 			__asm
; 199  : 			{
; 200  : 				cld;
; 201  : 				mov edi, dest
; 202  : 				xor eax, eax
; 203  : 				stosd
; 204  : 				stosd
; 205  : 				stosd
; 206  : 			}
; 207  : 		return;
; 208  : 
; 209  : 		case 4:
; 210  : 			__asm
; 211  : 			{
; 212  : 				cld;
; 213  : 				mov edi, dest
; 214  : 				xor eax, eax
; 215  : 				stosd
; 216  : 				stosd
; 217  : 				stosd
; 218  : 				stosd
; 219  : 			}
; 220  : 		return;
; 221  : 
; 222  : 		case 5:
; 223  : 			__asm
; 224  : 			{
; 225  : 				cld;
; 226  : 				mov edi, dest
; 227  : 				xor eax, eax
; 228  : 				stosd
; 229  : 				stosd
; 230  : 				stosd
; 231  : 				stosd
; 232  : 				stosd
; 233  : 			}
; 234  : 		return;
; 235  : 
; 236  : 		default:
; 237  : 			__asm
; 238  : 			{
; 239  : 				cld;
; 240  : 				mov ecx, remdat
; 241  : 				mov edi, dest
; 242  : 				xor eax, eax
; 243  : 				rep stosd
; 244  : 			}
; 245  : 		return;
; 246  : 	}
; 247  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$memzero_ptr@$0EAAAA@@@YAXPAX@Z ENDP			; memzero_ptr<262144>
; Function compile flags: /Ogtpy
__xmm_backup$89746 = -20				; size = 16
_dest$ = -4						; size = 4
??$memzero_ptr@$0EJFAAAA@@@YAXPAX@Z PROC		; memzero_ptr<76873728>

; 50   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR _m_recBlockAlloc
	mov	DWORD PTR _dest$[ebp], eax

; 51   : 	if( bytes == 0 ) return;
; 52   : 
; 53   : 	// This function only works on 32-bit alignments.  For anything else we just fall back
; 54   : 	// on the compiler-provided implementation of memset...
; 55   : 
; 56   : 	if( (bytes & 0x3) != 0 )
; 57   : 	{
; 58   : 		memset( dest, 0, bytes );
; 59   : 		return;
; 60   : 	}
; 61   : 
; 62   : 	enum
; 63   : 	{
; 64   : 		remainder = bytes & 127,
; 65   : 		bytes128 = bytes / 128
; 66   : 	};
; 67   : 
; 68   : 	// Initial check -- if the length is not a multiple of 16 then fall back on
; 69   : 	// using rep movsd methods.  Handling these unaligned clears in a more efficient
; 70   : 	// manner isn't necessary in pcsx2 (meaning they aren't used in speed-critical
; 71   : 	// scenarios).
; 72   : 
; 73   : 	if( (bytes & 0xf) == 0 )
; 74   : 	{
; 75   : 		u64 _xmm_backup[2];
; 76   : 
; 77   : 		if( ((uptr)dest & 0xf) != 0 )

	test	al, 15					; 0000000fH
	je	SHORT $LN14@memzero_pt@2

; 78   : 		{
; 79   : 			// UNALIGNED COPY MODE.
; 80   : 			// For unaligned copies we have a threshold of at least 128 vectors.  Anything
; 81   : 			// less and it's probably better off just falling back on the rep movsd.
; 82   : 			if( bytes128 > 128 )
; 83   : 			{
; 84   : 				__asm
; 85   : 				{
; 86   : 					movups _xmm_backup,xmm0;

	movups	XMMWORD PTR __xmm_backup$89746[ebp], xmm0

; 87   : 					mov ecx,dest

	mov	ecx, DWORD PTR _dest$[ebp]

; 88   : 					pxor xmm0,xmm0

	pxor	xmm0, xmm0

; 89   : 					mov eax,bytes128

	mov	eax, 600576				; 00092a00H
	npad	14
$_loop_6$89750:

; 90   : 
; 91   : 					align 16
; 92   : 
; 93   : 				_loop_6:
; 94   : 					movups [ecx],xmm0;

	movups	XMMWORD PTR [ecx], xmm0

; 95   : 					movups [ecx+0x10],xmm0;

	movups	XMMWORD PTR [ecx+16], xmm0

; 96   : 					movups [ecx+0x20],xmm0;

	movups	XMMWORD PTR [ecx+32], xmm0

; 97   : 					movups [ecx+0x30],xmm0;

	movups	XMMWORD PTR [ecx+48], xmm0

; 98   : 					movups [ecx+0x40],xmm0;

	movups	XMMWORD PTR [ecx+64], xmm0

; 99   : 					movups [ecx+0x50],xmm0;

	movups	XMMWORD PTR [ecx+80], xmm0

; 100  : 					movups [ecx+0x60],xmm0;

	movups	XMMWORD PTR [ecx+96], xmm0

; 101  : 					movups [ecx+0x70],xmm0;

	movups	XMMWORD PTR [ecx+112], xmm0

; 102  : 					sub ecx,-128

	sub	ecx, -128				; ffffff80H

; 103  : 					dec eax;

	dec	eax

; 104  : 					jnz _loop_6;

	jne	SHORT $_loop_6$89750

; 105  : 				}
; 106  : 				if( remainder != 0 )
; 107  : 				{
; 108  : 					// Copy the remainder in reverse (using the decrementing eax as our indexer)
; 109  : 					__asm
; 110  : 					{
; 111  : 						mov eax, remainder
; 112  : 
; 113  : 					_loop_5:
; 114  : 						movups [ecx+eax],xmm0;
; 115  : 						sub eax,16;
; 116  : 						jnz _loop_5;
; 117  : 					}
; 118  : 				}
; 119  : 				__asm
; 120  : 				{
; 121  : 					movups xmm0,[_xmm_backup];

	movups	xmm0, XMMWORD PTR __xmm_backup$89746[ebp]

; 170  : 			}
; 171  : 			return;
; 172  : 		}
; 173  : 	}
; 174  : 
; 175  : 	// This function only works on 32-bit alignments.
; 176  : 	jASSUME( (bytes & 0x3) == 0 );
; 177  : 	jASSUME( ((uptr)dest & 0x3) == 0 );
; 178  : 
; 179  : 	enum
; 180  : 	{
; 181  : 		remdat = bytes>>2
; 182  : 	};
; 183  : 
; 184  : 	// This case statement handles 5 special-case sizes (small blocks)
; 185  : 	// in addition to the generic large block that uses rep stosd.
; 186  : 
; 187  : 	switch( remdat )
; 188  : 	{
; 189  : 		case 1:
; 190  : 			*(u32*)dest = 0;
; 191  : 		return;
; 192  : 
; 193  : 		case 2:
; 194  : 			*(u64*)dest = 0;
; 195  : 		return;
; 196  : 
; 197  : 		case 3:
; 198  : 			__asm
; 199  : 			{
; 200  : 				cld;
; 201  : 				mov edi, dest
; 202  : 				xor eax, eax
; 203  : 				stosd
; 204  : 				stosd
; 205  : 				stosd
; 206  : 			}
; 207  : 		return;
; 208  : 
; 209  : 		case 4:
; 210  : 			__asm
; 211  : 			{
; 212  : 				cld;
; 213  : 				mov edi, dest
; 214  : 				xor eax, eax
; 215  : 				stosd
; 216  : 				stosd
; 217  : 				stosd
; 218  : 				stosd
; 219  : 			}
; 220  : 		return;
; 221  : 
; 222  : 		case 5:
; 223  : 			__asm
; 224  : 			{
; 225  : 				cld;
; 226  : 				mov edi, dest
; 227  : 				xor eax, eax
; 228  : 				stosd
; 229  : 				stosd
; 230  : 				stosd
; 231  : 				stosd
; 232  : 				stosd
; 233  : 			}
; 234  : 		return;
; 235  : 
; 236  : 		default:
; 237  : 			__asm
; 238  : 			{
; 239  : 				cld;
; 240  : 				mov ecx, remdat
; 241  : 				mov edi, dest
; 242  : 				xor eax, eax
; 243  : 				rep stosd
; 244  : 			}
; 245  : 		return;
; 246  : 	}
; 247  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@memzero_pt@2:

; 122  : 				}
; 123  : 				return;
; 124  : 			}
; 125  : 		}
; 126  : 		else if( bytes128 > 48 )
; 127  : 		{
; 128  : 			// ALIGNED COPY MODE
; 129  : 			// Data is aligned and the size of data is large enough to merit a nice
; 130  : 			// fancy chunk of unrolled goodness:
; 131  : 
; 132  : 			__asm
; 133  : 			{
; 134  : 				movups _xmm_backup,xmm0;

	movups	XMMWORD PTR __xmm_backup$89746[ebp], xmm0

; 135  : 				mov ecx,dest

	mov	ecx, DWORD PTR _dest$[ebp]

; 136  : 				pxor xmm0,xmm0

	pxor	xmm0, xmm0

; 137  : 				mov eax,bytes128

	mov	eax, 600576				; 00092a00H
	npad	3
$_loop_8$89755:

; 138  : 
; 139  : 				align 16
; 140  : 
; 141  : 			_loop_8:
; 142  : 				movaps [ecx],xmm0;

	movaps	XMMWORD PTR [ecx], xmm0

; 143  : 				movaps [ecx+0x10],xmm0;

	movaps	XMMWORD PTR [ecx+16], xmm0

; 144  : 				movaps [ecx+0x20],xmm0;

	movaps	XMMWORD PTR [ecx+32], xmm0

; 145  : 				movaps [ecx+0x30],xmm0;

	movaps	XMMWORD PTR [ecx+48], xmm0

; 146  : 				movaps [ecx+0x40],xmm0;

	movaps	XMMWORD PTR [ecx+64], xmm0

; 147  : 				movaps [ecx+0x50],xmm0;

	movaps	XMMWORD PTR [ecx+80], xmm0

; 148  : 				movaps [ecx+0x60],xmm0;

	movaps	XMMWORD PTR [ecx+96], xmm0

; 149  : 				movaps [ecx+0x70],xmm0;

	movaps	XMMWORD PTR [ecx+112], xmm0

; 150  : 				sub ecx,-128

	sub	ecx, -128				; ffffff80H

; 151  : 				dec eax;

	dec	eax

; 152  : 				jnz _loop_8;

	jne	SHORT $_loop_8$89755

; 153  : 			}
; 154  : 			if( remainder != 0 )
; 155  : 			{
; 156  : 				// Copy the remainder in reverse (using the decrementing eax as our indexer)
; 157  : 				__asm
; 158  : 				{
; 159  : 					mov eax, remainder
; 160  : 
; 161  : 				_loop_10:
; 162  : 					movaps [ecx+eax],xmm0;
; 163  : 					sub eax,16;
; 164  : 					jnz _loop_10;
; 165  : 				}
; 166  : 			}
; 167  : 			__asm
; 168  : 			{
; 169  : 				movups xmm0,[_xmm_backup];

	movups	xmm0, XMMWORD PTR __xmm_backup$89746[ebp]

; 170  : 			}
; 171  : 			return;
; 172  : 		}
; 173  : 	}
; 174  : 
; 175  : 	// This function only works on 32-bit alignments.
; 176  : 	jASSUME( (bytes & 0x3) == 0 );
; 177  : 	jASSUME( ((uptr)dest & 0x3) == 0 );
; 178  : 
; 179  : 	enum
; 180  : 	{
; 181  : 		remdat = bytes>>2
; 182  : 	};
; 183  : 
; 184  : 	// This case statement handles 5 special-case sizes (small blocks)
; 185  : 	// in addition to the generic large block that uses rep stosd.
; 186  : 
; 187  : 	switch( remdat )
; 188  : 	{
; 189  : 		case 1:
; 190  : 			*(u32*)dest = 0;
; 191  : 		return;
; 192  : 
; 193  : 		case 2:
; 194  : 			*(u64*)dest = 0;
; 195  : 		return;
; 196  : 
; 197  : 		case 3:
; 198  : 			__asm
; 199  : 			{
; 200  : 				cld;
; 201  : 				mov edi, dest
; 202  : 				xor eax, eax
; 203  : 				stosd
; 204  : 				stosd
; 205  : 				stosd
; 206  : 			}
; 207  : 		return;
; 208  : 
; 209  : 		case 4:
; 210  : 			__asm
; 211  : 			{
; 212  : 				cld;
; 213  : 				mov edi, dest
; 214  : 				xor eax, eax
; 215  : 				stosd
; 216  : 				stosd
; 217  : 				stosd
; 218  : 				stosd
; 219  : 			}
; 220  : 		return;
; 221  : 
; 222  : 		case 5:
; 223  : 			__asm
; 224  : 			{
; 225  : 				cld;
; 226  : 				mov edi, dest
; 227  : 				xor eax, eax
; 228  : 				stosd
; 229  : 				stosd
; 230  : 				stosd
; 231  : 				stosd
; 232  : 				stosd
; 233  : 			}
; 234  : 		return;
; 235  : 
; 236  : 		default:
; 237  : 			__asm
; 238  : 			{
; 239  : 				cld;
; 240  : 				mov ecx, remdat
; 241  : 				mov edi, dest
; 242  : 				xor eax, eax
; 243  : 				rep stosd
; 244  : 			}
; 245  : 		return;
; 246  : 	}
; 247  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??$memzero_ptr@$0EJFAAAA@@@YAXPAX@Z ENDP		; memzero_ptr<76873728>
; Function compile flags: /Ogtpy
_dest$ = -4						; size = 4
??$memset_8@$0MN@$0BAAAAAA@@@YAXPAX@Z PROC		; memset_8<205,16777216>

; 252  : {

	push	ecx

; 253  : 	if( bytes == 0 ) return;
; 254  : 
; 255  : 	if( (bytes & 0x3) != 0 )
; 256  : 	{
; 257  : 		// unaligned data length.  No point in doing an optimized inline version (too complicated!)
; 258  : 		// So fall back on the compiler implementation:
; 259  : 
; 260  : 		memset( dest, data, bytes );
; 261  : 		return;
; 262  : 	}
; 263  : 
; 264  : 	//u64 _xmm_backup[2];
; 265  : 
; 266  : 	/*static const size_t remainder = bytes & 127;
; 267  : 	static const size_t bytes128 = bytes / 128;
; 268  : 	if( bytes128 > 32 )
; 269  : 	{
; 270  : 		// This function only works on 128-bit alignments.
; 271  : 		jASSUME( (bytes & 0xf) == 0 );
; 272  : 		jASSUME( ((uptr)dest & 0xf) == 0 );
; 273  : 
; 274  : 		__asm
; 275  : 		{
; 276  : 			movups _xmm_backup,xmm0;
; 277  : 			mov eax,bytes128
; 278  : 			mov ecx,dest
; 279  : 			movss xmm0,data
; 280  : 
; 281  : 			align 16
; 282  : 
; 283  : 		_loop_8:
; 284  : 			movaps [ecx],xmm0;
; 285  : 			movaps [ecx+0x10],xmm0;
; 286  : 			movaps [ecx+0x20],xmm0;
; 287  : 			movaps [ecx+0x30],xmm0;
; 288  : 			movaps [ecx+0x40],xmm0;
; 289  : 			movaps [ecx+0x50],xmm0;
; 290  : 			movaps [ecx+0x60],xmm0;
; 291  : 			movaps [ecx+0x70],xmm0;
; 292  : 			sub ecx,-128
; 293  : 			dec eax;
; 294  : 			jnz _loop_8;
; 295  : 		}
; 296  : 		if( remainder != 0 )
; 297  : 		{
; 298  : 			// Copy the remainder in reverse (using the decrementing eax as our indexer)
; 299  : 			__asm
; 300  : 			{
; 301  : 				mov eax, remainder
; 302  : 
; 303  : 			_loop_10:
; 304  : 				movaps [ecx+eax],xmm0;
; 305  : 				sub eax,16;
; 306  : 				jnz _loop_10;
; 307  : 			}
; 308  : 		}
; 309  : 		__asm
; 310  : 		{
; 311  : 			movups xmm0,[_xmm_backup];
; 312  : 		}
; 313  : 	}*/
; 314  : 
; 315  : 	// This function only works on 32-bit alignments of data copied.
; 316  : 	jASSUME( (bytes & 0x3) == 0 );
; 317  : 
; 318  : 	enum
; 319  : 	{
; 320  : 		remdat = bytes>>2,
; 321  : 		data32 = data + (data<<8) + (data<<16) + (data<<24)
; 322  : 	};
; 323  : 
; 324  : 	// macro to execute the x86/32 "stosd" copies.
; 325  : 	switch( remdat )
; 326  : 	{
; 327  : 		case 1:
; 328  : 			*(u32*)dest = data32;
; 329  : 		return;
; 330  : 
; 331  : 		case 2:
; 332  : 			((u32*)dest)[0] = data32;
; 333  : 			((u32*)dest)[1] = data32;
; 334  : 		return;
; 335  : 
; 336  : 		case 3:
; 337  : 			__asm
; 338  : 			{
; 339  : 				cld;
; 340  : 				mov edi, dest;
; 341  : 				mov eax, data32;
; 342  : 				stosd;
; 343  : 				stosd;
; 344  : 				stosd;
; 345  : 			}
; 346  : 		return;
; 347  : 
; 348  : 		case 4:
; 349  : 			__asm
; 350  : 			{
; 351  : 				cld;
; 352  : 				mov edi, dest;
; 353  : 				mov eax, data32;
; 354  : 				stosd;
; 355  : 				stosd;
; 356  : 				stosd;
; 357  : 				stosd;
; 358  : 			}
; 359  : 		return;
; 360  : 
; 361  : 		case 5:
; 362  : 			__asm
; 363  : 			{
; 364  : 				cld;
; 365  : 				mov edi, dest;
; 366  : 				mov eax, data32;
; 367  : 				stosd;
; 368  : 				stosd;
; 369  : 				stosd;
; 370  : 				stosd;
; 371  : 				stosd;
; 372  : 			}
; 373  : 		return;
; 374  : 
; 375  : 		default:
; 376  : 			__asm

	mov	eax, DWORD PTR _recMem
	push	edi
	mov	DWORD PTR _dest$[esp+8], eax

; 377  : 			{
; 378  : 				cld;

	cld

; 379  : 				mov ecx, remdat;

	mov	ecx, 4194304				; 00400000H

; 380  : 				mov edi, dest;

	mov	edi, DWORD PTR _dest$[esp+8]

; 381  : 				mov eax, data32;

	mov	eax, -842150451				; cdcdcdcdH

; 382  : 				rep stosd;

	rep	 stosd

; 253  : 	if( bytes == 0 ) return;
; 254  : 
; 255  : 	if( (bytes & 0x3) != 0 )
; 256  : 	{
; 257  : 		// unaligned data length.  No point in doing an optimized inline version (too complicated!)
; 258  : 		// So fall back on the compiler implementation:
; 259  : 
; 260  : 		memset( dest, data, bytes );
; 261  : 		return;
; 262  : 	}
; 263  : 
; 264  : 	//u64 _xmm_backup[2];
; 265  : 
; 266  : 	/*static const size_t remainder = bytes & 127;
; 267  : 	static const size_t bytes128 = bytes / 128;
; 268  : 	if( bytes128 > 32 )
; 269  : 	{
; 270  : 		// This function only works on 128-bit alignments.
; 271  : 		jASSUME( (bytes & 0xf) == 0 );
; 272  : 		jASSUME( ((uptr)dest & 0xf) == 0 );
; 273  : 
; 274  : 		__asm
; 275  : 		{
; 276  : 			movups _xmm_backup,xmm0;
; 277  : 			mov eax,bytes128
; 278  : 			mov ecx,dest
; 279  : 			movss xmm0,data
; 280  : 
; 281  : 			align 16
; 282  : 
; 283  : 		_loop_8:
; 284  : 			movaps [ecx],xmm0;
; 285  : 			movaps [ecx+0x10],xmm0;
; 286  : 			movaps [ecx+0x20],xmm0;
; 287  : 			movaps [ecx+0x30],xmm0;
; 288  : 			movaps [ecx+0x40],xmm0;
; 289  : 			movaps [ecx+0x50],xmm0;
; 290  : 			movaps [ecx+0x60],xmm0;
; 291  : 			movaps [ecx+0x70],xmm0;
; 292  : 			sub ecx,-128
; 293  : 			dec eax;
; 294  : 			jnz _loop_8;
; 295  : 		}
; 296  : 		if( remainder != 0 )
; 297  : 		{
; 298  : 			// Copy the remainder in reverse (using the decrementing eax as our indexer)
; 299  : 			__asm
; 300  : 			{
; 301  : 				mov eax, remainder
; 302  : 
; 303  : 			_loop_10:
; 304  : 				movaps [ecx+eax],xmm0;
; 305  : 				sub eax,16;
; 306  : 				jnz _loop_10;
; 307  : 			}
; 308  : 		}
; 309  : 		__asm
; 310  : 		{
; 311  : 			movups xmm0,[_xmm_backup];
; 312  : 		}
; 313  : 	}*/
; 314  : 
; 315  : 	// This function only works on 32-bit alignments of data copied.
; 316  : 	jASSUME( (bytes & 0x3) == 0 );
; 317  : 
; 318  : 	enum
; 319  : 	{
; 320  : 		remdat = bytes>>2,
; 321  : 		data32 = data + (data<<8) + (data<<16) + (data<<24)
; 322  : 	};
; 323  : 
; 324  : 	// macro to execute the x86/32 "stosd" copies.
; 325  : 	switch( remdat )
; 326  : 	{
; 327  : 		case 1:
; 328  : 			*(u32*)dest = data32;
; 329  : 		return;
; 330  : 
; 331  : 		case 2:
; 332  : 			((u32*)dest)[0] = data32;
; 333  : 			((u32*)dest)[1] = data32;
; 334  : 		return;
; 335  : 
; 336  : 		case 3:
; 337  : 			__asm
; 338  : 			{
; 339  : 				cld;
; 340  : 				mov edi, dest;
; 341  : 				mov eax, data32;
; 342  : 				stosd;
; 343  : 				stosd;
; 344  : 				stosd;
; 345  : 			}
; 346  : 		return;
; 347  : 
; 348  : 		case 4:
; 349  : 			__asm
; 350  : 			{
; 351  : 				cld;
; 352  : 				mov edi, dest;
; 353  : 				mov eax, data32;
; 354  : 				stosd;
; 355  : 				stosd;
; 356  : 				stosd;
; 357  : 				stosd;
; 358  : 			}
; 359  : 		return;
; 360  : 
; 361  : 		case 5:
; 362  : 			__asm
; 363  : 			{
; 364  : 				cld;
; 365  : 				mov edi, dest;
; 366  : 				mov eax, data32;
; 367  : 				stosd;
; 368  : 				stosd;
; 369  : 				stosd;
; 370  : 				stosd;
; 371  : 				stosd;
; 372  : 			}
; 373  : 		return;
; 374  : 
; 375  : 		default:
; 376  : 			__asm

	pop	edi

; 383  : 			}
; 384  : 		return;
; 385  : 	}
; 386  : }

	pop	ecx
	ret	0
??$memset_8@$0MN@$0BAAAAAA@@@YAXPAX@Z ENDP		; memset_8<205,16777216>
_TEXT	ENDS
PUBLIC	?eeScaleBlockCycles@@YAIXZ			; eeScaleBlockCycles
; Function compile flags: /Ogtpy
; File f:\emu\ps2\src\pcsx2\x86\ix86-32\ir5900-32.cpp
_TEXT	SEGMENT
?eeScaleBlockCycles@@YAIXZ PROC				; eeScaleBlockCycles

; 1172 : 	// Note: s_nBlockCycles is 3 bit fixed point.  Divide by 8 when done!
; 1173 : 
; 1174 : 	// Let's not scale blocks under 5-ish cycles.  This fixes countless "problems"
; 1175 : 	// caused by sync hacks and such, since games seem to care a lot more about
; 1176 : 	// these small blocks having accurate cycle counts.
; 1177 : 
; 1178 : 	if( s_nBlockCycles <= (5<<3) || (CHECK_EE_CYCLERATE == 0) )

	mov	eax, DWORD PTR ?s_nBlockCycles@@3IA	; s_nBlockCycles
	cmp	eax, 40					; 00000028H
	jbe	SHORT $LN8@eeScaleBlo
	mov	ecx, DWORD PTR ?Config@@3UPcsxConfig@@A+3608
	and	ecx, 3
	je	SHORT $LN8@eeScaleBlo
	push	esi

; 1180 : 
; 1181 : 	uint scalarLow, scalarMid, scalarHigh;
; 1182 : 
; 1183 : 	// Note: larger blocks get a smaller scalar, to help keep
; 1184 : 	// them from becoming "too fat" and delaying branch tests.
; 1185 : 
; 1186 : 	switch( CHECK_EE_CYCLERATE )

	jmp	DWORD PTR $LN18@eeScaleBlo[ecx*4]
$LN5@eeScaleBlo:

; 1187 : 	{
; 1188 : 		case 0:	return s_nBlockCycles >> 3;

	shr	eax, 3
	pop	esi

; 1216 : }

	ret	0
$LN4@eeScaleBlo:

; 1189 : 
; 1190 : 		case 1:		// Sync hack x1.5!
; 1191 : 			scalarLow = 5;

	mov	edx, 5

; 1192 : 			scalarMid = 7;

	lea	ecx, DWORD PTR [edx+2]

; 1193 : 			scalarHigh = 5;
; 1194 : 		break;

	jmp	SHORT $LN17@eeScaleBlo
$LN3@eeScaleBlo:

; 1195 : 
; 1196 : 		case 2:		// Sync hack x2
; 1197 : 			scalarLow = 7;

	mov	edx, 7

; 1198 : 			scalarMid = 9;

	lea	ecx, DWORD PTR [edx+2]

; 1199 : 			scalarHigh = 7;
; 1200 : 		break;

	jmp	SHORT $LN17@eeScaleBlo
$LN2@eeScaleBlo:

; 1201 : 
; 1202 : 		case 3:		// Sync hack x3
; 1203 : 			scalarLow = 10;

	mov	edx, 10					; 0000000aH

; 1204 : 			scalarMid = 19;

	lea	ecx, DWORD PTR [edx+9]
$LN17@eeScaleBlo:

; 1205 : 			scalarHigh = 10;

	mov	esi, edx

; 1206 : 		break;
; 1207 : 
; 1208 : 		jNO_DEFAULT
; 1209 : 	}
; 1210 : 
; 1211 : 	s_nBlockCycles *= 
; 1212 : 		(s_nBlockCycles <= (10<<3)) ? scalarLow :
; 1213 : 		((s_nBlockCycles > (21<<3)) ? scalarHigh : scalarMid );

	cmp	eax, 80					; 00000050H
	ja	SHORT $LN14@eeScaleBlo
	mov	ecx, edx
	imul	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR ?s_nBlockCycles@@3IA, eax	; s_nBlockCycles

; 1214 : 
; 1215 : 	return s_nBlockCycles >> (3+2);

	shr	eax, 5
	pop	esi

; 1216 : }

	ret	0
$LN14@eeScaleBlo:

; 1206 : 		break;
; 1207 : 
; 1208 : 		jNO_DEFAULT
; 1209 : 	}
; 1210 : 
; 1211 : 	s_nBlockCycles *= 
; 1212 : 		(s_nBlockCycles <= (10<<3)) ? scalarLow :
; 1213 : 		((s_nBlockCycles > (21<<3)) ? scalarHigh : scalarMid );

	cmp	eax, 168				; 000000a8H
	jbe	SHORT $LN12@eeScaleBlo
	mov	ecx, esi
$LN12@eeScaleBlo:
	imul	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR ?s_nBlockCycles@@3IA, eax	; s_nBlockCycles

; 1214 : 
; 1215 : 	return s_nBlockCycles >> (3+2);

	shr	eax, 5
	pop	esi

; 1216 : }

	ret	0
$LN8@eeScaleBlo:

; 1179 : 		return s_nBlockCycles >> 3;

	shr	eax, 3

; 1216 : }

	ret	0
	npad	2
$LN18@eeScaleBlo:
	DD	$LN5@eeScaleBlo
	DD	$LN4@eeScaleBlo
	DD	$LN3@eeScaleBlo
	DD	$LN2@eeScaleBlo
?eeScaleBlockCycles@@YAIXZ ENDP				; eeScaleBlockCycles
_TEXT	ENDS
PUBLIC	?LoadBranchState@@YAXXZ				; LoadBranchState
_s_saveiCWstate DW 01H DUP (?)
	ALIGN	4

_s_savex86FpuState DW 01H DUP (?)
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?LoadBranchState@@YAXXZ PROC				; LoadBranchState

; 1100 : 	x86FpuState = s_savex86FpuState;

	mov	ax, WORD PTR _s_savex86FpuState

; 1101 : 	iCWstate = s_saveiCWstate;

	mov	cx, WORD PTR _s_saveiCWstate

; 1102 : 	s_nBlockCycles = s_savenBlockCycles;

	mov	edx, DWORD PTR _s_savenBlockCycles
	mov	WORD PTR ?x86FpuState@@3GA, ax		; x86FpuState

; 1103 : 
; 1104 : 	if( s_saveConstGPRreg != 0xffffffff ) {

	mov	eax, DWORD PTR ?s_saveConstGPRreg@@3IA	; s_saveConstGPRreg
	mov	WORD PTR ?iCWstate@@3GA, cx		; iCWstate
	mov	DWORD PTR ?s_nBlockCycles@@3IA, edx	; s_nBlockCycles
	cmp	eax, -1
	je	SHORT $LN2@LoadBranch

; 1105 : 		assert( s_saveConstGPRreg > 0 );
; 1106 : 
; 1107 : 		// make sure right GPR was saved
; 1108 : 		assert( g_cpuHasConstReg == s_saveHasConstReg || (g_cpuHasConstReg ^ s_saveHasConstReg) == (1<<s_saveConstGPRreg) );
; 1109 : 
; 1110 : 		// restore the GPR reg
; 1111 : 		g_cpuConstRegs[s_saveConstGPRreg] = s_ConstGPRreg;

	mov	ecx, DWORD PTR ?s_ConstGPRreg@@3TGPR_reg64@@A
	mov	edx, DWORD PTR ?s_ConstGPRreg@@3TGPR_reg64@@A+4
	shl	eax, 4
	add	eax, OFFSET ?g_cpuConstRegs@@3PATGPR_reg64@@A ; g_cpuConstRegs
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR ?s_ConstGPRreg@@3TGPR_reg64@@A+8
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR ?s_ConstGPRreg@@3TGPR_reg64@@A+12
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], edx

; 1112 : 		GPR_SET_CONST(s_saveConstGPRreg);
; 1113 : 
; 1114 : 		s_saveConstGPRreg = 0;

	mov	DWORD PTR ?s_saveConstGPRreg@@3IA, 0	; s_saveConstGPRreg
$LN2@LoadBranch:

; 1115 : 	}
; 1116 : 
; 1117 : 	g_cpuHasConstReg = s_saveHasConstReg;

	mov	eax, DWORD PTR _s_saveHasConstReg

; 1118 : 	g_cpuFlushedConstReg = s_saveFlushedConstReg;

	mov	ecx, DWORD PTR _s_saveFlushedConstReg

; 1119 : 	g_pCurInstInfo = s_psaveInstInfo;

	mov	edx, DWORD PTR _s_psaveInstInfo
	mov	DWORD PTR ?g_cpuHasConstReg@@3IA, eax	; g_cpuHasConstReg

; 1120 : 	g_cpuRegHasLive1 = g_cpuPrevRegHasLive1 = s_saveRegHasLive1;

	mov	eax, DWORD PTR _s_saveRegHasLive1
	mov	DWORD PTR ?g_cpuPrevRegHasLive1@@3IA, eax ; g_cpuPrevRegHasLive1
	mov	DWORD PTR ?g_cpuRegHasLive1@@3IA, eax	; g_cpuRegHasLive1

; 1121 : 	g_cpuRegHasSignExt = g_cpuPrevRegHasSignExt = s_saveRegHasSignExt;

	mov	eax, DWORD PTR _s_saveRegHasSignExt
	mov	DWORD PTR ?g_cpuFlushedConstReg@@3IA, ecx ; g_cpuFlushedConstReg
	mov	DWORD PTR ?g_pCurInstInfo@@3PAUEEINST@@A, edx ; g_pCurInstInfo

; 1122 : 
; 1123 : 	// restore all mmx regs
; 1124 : 	memcpy_fast(mmxregs, s_saveMMXregs, sizeof(mmxregs));

	push	48					; 00000030H
	mov	edx, OFFSET ?s_saveMMXregs@@3PAU_mmxregs@@A ; s_saveMMXregs
	mov	ecx, OFFSET ?mmxregs@@3PAU_mmxregs@@A	; mmxregs
	mov	DWORD PTR ?g_cpuPrevRegHasSignExt@@3IA, eax ; g_cpuPrevRegHasSignExt
	mov	DWORD PTR ?g_cpuRegHasSignExt@@3IA, eax	; g_cpuRegHasSignExt
	call	?memcpy_amd_@@YIXPAXPBXI@Z		; memcpy_amd_

; 1125 : 	memcpy_fast(xmmregs, s_saveXMMregs, sizeof(xmmregs));

	push	64					; 00000040H
	mov	edx, OFFSET ?s_saveXMMregs@@3PAU_xmmregs@@A ; s_saveXMMregs
	mov	ecx, OFFSET ?xmmregs@@3PAU_xmmregs@@A	; xmmregs
	call	?memcpy_amd_@@YIXPAXPBXI@Z		; memcpy_amd_

; 1126 : }

	ret	0
?LoadBranchState@@YAXXZ ENDP				; LoadBranchState
_TEXT	ENDS
PUBLIC	?SaveBranchState@@YAXXZ				; SaveBranchState
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?SaveBranchState@@YAXXZ PROC				; SaveBranchState

; 1083 : 	s_savex86FpuState = x86FpuState;
; 1084 : 	s_saveiCWstate = iCWstate;

	mov	cx, WORD PTR ?iCWstate@@3GA		; iCWstate
	mov	ax, WORD PTR ?x86FpuState@@3GA		; x86FpuState

; 1085 : 	s_savenBlockCycles = s_nBlockCycles;

	mov	edx, DWORD PTR ?s_nBlockCycles@@3IA	; s_nBlockCycles
	mov	WORD PTR _s_saveiCWstate, cx

; 1086 : 	s_saveConstGPRreg = 0xffffffff; // indicate searching
; 1087 : 	s_saveHasConstReg = g_cpuHasConstReg;
; 1088 : 	s_saveFlushedConstReg = g_cpuFlushedConstReg;

	mov	ecx, DWORD PTR ?g_cpuFlushedConstReg@@3IA ; g_cpuFlushedConstReg
	mov	WORD PTR _s_savex86FpuState, ax
	mov	eax, DWORD PTR ?g_cpuHasConstReg@@3IA	; g_cpuHasConstReg
	mov	DWORD PTR _s_savenBlockCycles, edx

; 1089 : 	s_psaveInstInfo = g_pCurInstInfo;

	mov	edx, DWORD PTR ?g_pCurInstInfo@@3PAUEEINST@@A ; g_pCurInstInfo
	mov	DWORD PTR _s_saveFlushedConstReg, ecx

; 1090 : 	s_saveRegHasLive1 = g_cpuRegHasLive1;
; 1091 : 	s_saveRegHasSignExt = g_cpuRegHasSignExt;

	mov	ecx, DWORD PTR ?g_cpuRegHasSignExt@@3IA	; g_cpuRegHasSignExt
	mov	DWORD PTR _s_saveHasConstReg, eax
	mov	eax, DWORD PTR ?g_cpuRegHasLive1@@3IA	; g_cpuRegHasLive1
	mov	DWORD PTR _s_psaveInstInfo, edx
	mov	DWORD PTR _s_saveRegHasSignExt, ecx

; 1092 : 
; 1093 : 	// save all mmx regs
; 1094 : 	memcpy_fast(s_saveMMXregs, mmxregs, sizeof(mmxregs));

	push	48					; 00000030H
	mov	edx, OFFSET ?mmxregs@@3PAU_mmxregs@@A	; mmxregs
	mov	ecx, OFFSET ?s_saveMMXregs@@3PAU_mmxregs@@A ; s_saveMMXregs
	mov	DWORD PTR ?s_saveConstGPRreg@@3IA, -1	; s_saveConstGPRreg
	mov	DWORD PTR _s_saveRegHasLive1, eax
	call	?memcpy_amd_@@YIXPAXPBXI@Z		; memcpy_amd_

; 1095 : 	memcpy_fast(s_saveXMMregs, xmmregs, sizeof(xmmregs));

	push	64					; 00000040H
	mov	edx, OFFSET ?xmmregs@@3PAU_xmmregs@@A	; xmmregs
	mov	ecx, OFFSET ?s_saveXMMregs@@3PAU_xmmregs@@A ; s_saveXMMregs
	call	?memcpy_amd_@@YIXPAXPBXI@Z		; memcpy_amd_

; 1096 : }

	ret	0
?SaveBranchState@@YAXXZ ENDP				; SaveBranchState
_TEXT	ENDS
PUBLIC	?recRecompile@@YAXI@Z				; recRecompile
; Function compile flags: /Odtpy
_TEXT	SEGMENT
?DispatcherClear@@YAXXZ PROC				; DispatcherClear

; 704  : 	// EDX contains the current pc
; 705  : 	__asm mov cpuRegs.pc, edx

	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+680, edx

; 706  : 	__asm push edx

	push	edx

; 707  : 
; 708  : 	// calc PC_GETBLOCK
; 709  : 	s_pDispatchBlock = PC_GETBLOCK(cpuRegs.pc);

	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+680
	shr	eax, 16					; 00000010H
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+680
	and	ecx, 65535				; 0000ffffH
	mov	edx, DWORD PTR ?recLUT@@3PAIA		; recLUT
	mov	eax, DWORD PTR [edx+eax*4]
	lea	ecx, DWORD PTR [eax+ecx*2]
	mov	DWORD PTR ?s_pDispatchBlock@@3PBUBASEBLOCK@@B, ecx ; s_pDispatchBlock

; 710  : 
; 711  : 	if( s_pDispatchBlock != NULL && s_pDispatchBlock->startpc == cpuRegs.pc )

	cmp	DWORD PTR ?s_pDispatchBlock@@3PBUBASEBLOCK@@B, 0 ; s_pDispatchBlock
	je	SHORT $LN1@Dispatcher
	mov	edx, DWORD PTR ?s_pDispatchBlock@@3PBUBASEBLOCK@@B ; s_pDispatchBlock
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+680
	jne	SHORT $LN1@Dispatcher

; 712  : 	{
; 713  : 		assert( s_pDispatchBlock->GetFnptr() != 0 );
; 714  : 
; 715  : 		// already modded the code, jump to the new place
; 716  : 		__asm {
; 717  : 			pop edx

	pop	edx

; 718  : 			mov eax, s_pDispatchBlock

	mov	eax, DWORD PTR ?s_pDispatchBlock@@3PBUBASEBLOCK@@B ; s_pDispatchBlock

; 719  : 			add esp, 4 // ignore stack

	add	esp, 4

; 720  : 			mov eax, dword ptr [eax]

	mov	eax, DWORD PTR [eax]

; 721  : 			//and eax, 0x0fffffff
; 722  : 			shl eax, 4

	shl	eax, 4

; 723  : 			jmp eax

	jmp	eax
$LN1@Dispatcher:

; 724  : 		}
; 725  : 	}
; 726  : 
; 727  : 	__asm {
; 728  : 		call recRecompile

	call	?recRecompile@@YAXI@Z			; recRecompile

; 729  : 		add esp, 4 // pop old param

	add	esp, 4

; 730  : 		mov eax, s_pDispatchBlock

	mov	eax, DWORD PTR ?s_pDispatchBlock@@3PBUBASEBLOCK@@B ; s_pDispatchBlock

; 731  : 		mov eax, dword ptr [eax]

	mov	eax, DWORD PTR [eax]

; 732  : 
; 733  : 		pop ecx // old fnptr

	pop	ecx

; 734  : 
; 735  : 		//and eax, 0x0fffffff
; 736  : 		shl eax, 4

	shl	eax, 4

; 737  : 		mov byte ptr [ecx], 0xe9 // jmp32

	mov	BYTE PTR [ecx], -23			; ffffffe9H

; 738  : 		mov edx, eax

	mov	edx, eax

; 739  : 		sub edx, ecx

	sub	edx, ecx

; 740  : 		sub edx, 5

	sub	edx, 5

; 741  : 		mov dword ptr [ecx+1], edx

	mov	DWORD PTR [ecx+1], edx

; 742  : 
; 743  : 		jmp eax

	jmp	eax
?DispatcherClear@@YAXXZ ENDP				; DispatcherClear
; Function compile flags: /Odtpy
?Dispatcher@@YAXXZ PROC				; Dispatcher

; 667  : 	// EDX contains the jump addr to modify
; 668  : 	__asm push edx

	push	edx

; 669  : 
; 670  : 	// calc PC_GETBLOCK
; 671  : 	s_pDispatchBlock = PC_GETBLOCK(cpuRegs.pc);

	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+680
	shr	eax, 16					; 00000010H
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+680
	and	ecx, 65535				; 0000ffffH
	mov	edx, DWORD PTR ?recLUT@@3PAIA		; recLUT
	mov	eax, DWORD PTR [edx+eax*4]
	lea	ecx, DWORD PTR [eax+ecx*2]
	mov	DWORD PTR ?s_pDispatchBlock@@3PBUBASEBLOCK@@B, ecx ; s_pDispatchBlock

; 672  : 	
; 673  : 	if( s_pDispatchBlock->startpc != cpuRegs.pc )

	mov	edx, DWORD PTR ?s_pDispatchBlock@@3PBUBASEBLOCK@@B ; s_pDispatchBlock
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+680
	je	SHORT $LN1@Dispatcher@2

; 674  : 		recRecompile(cpuRegs.pc);

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+680
	push	ecx
	call	?recRecompile@@YAXI@Z			; recRecompile
	add	esp, 4
$LN1@Dispatcher@2:

; 675  : 
; 676  : 	__asm
; 677  : 	{
; 678  : 		mov eax, s_pDispatchBlock

	mov	eax, DWORD PTR ?s_pDispatchBlock@@3PBUBASEBLOCK@@B ; s_pDispatchBlock

; 679  : 		mov eax, dword ptr [eax]

	mov	eax, DWORD PTR [eax]

; 680  : 	}
; 681  : 
; 682  : #ifdef _DEBUG
; 683  : 	__asm mov g_EEDispatchTemp, eax
; 684  : 	assert( g_EEDispatchTemp );
; 685  : #endif
; 686  : 
; 687  : 	__asm {
; 688  : 		//and eax, 0x0fffffff
; 689  : 		shl eax, 4

	shl	eax, 4

; 690  : 		pop ecx // x86Ptr to mod

	pop	ecx

; 691  : 		mov edx, eax

	mov	edx, eax

; 692  : 		sub edx, ecx

	sub	edx, ecx

; 693  : 		sub edx, 4

	sub	edx, 4

; 694  : 		mov dword ptr [ecx], edx

	mov	DWORD PTR [ecx], edx

; 695  : 
; 696  : 		jmp eax

	jmp	eax
?Dispatcher@@YAXXZ ENDP					; Dispatcher
; Function compile flags: /Ogtpy
?recStep@@YAXXZ PROC					; recStep

; 636  : }

	ret	0
?recStep@@YAXXZ ENDP					; recStep
_TEXT	ENDS
PUBLIC	?recAllocStackMem@@YAPAIHH@Z			; recAllocStackMem
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?recAllocStackMem@@YAPAIHH@Z PROC			; recAllocStackMem
; _align$ = ecx

; 464  : {

	push	esi

; 465  : 	// write to a temp loc, trick
; 466  : 	if( (u32)recStackPtr % align ) recStackPtr += align - ((u32)recStackPtr%align);

	mov	esi, DWORD PTR _recStackPtr
	xor	edx, edx
	mov	eax, esi
	div	ecx
	test	edx, edx
	je	SHORT $LN1@recAllocSt
	sub	ecx, edx
	add	esi, ecx
$LN1@recAllocSt:

; 467  : 	recStackPtr += size;

	add	esi, 8
	mov	DWORD PTR _recStackPtr, esi

; 468  : 	return (u32*)(recStackPtr-size);

	lea	eax, DWORD PTR [esi-8]
	pop	esi

; 469  : }

	ret	0
?recAllocStackMem@@YAPAIHH@Z ENDP			; recAllocStackMem
; Function compile flags: /Ogtpy
; File f:\emu\ps2\src\pcsx2\x86\baseblockex.h
_TEXT	ENDS
;	COMDAT ?SetFnptr@BASEBLOCK@@QAEXI@Z
_TEXT	SEGMENT
?SetFnptr@BASEBLOCK@@QAEXI@Z PROC			; BASEBLOCK::SetFnptr, COMDAT
; _this$ = ecx
; _ptr$ = eax

; 38   : 		// 16 byte alignments only, please!
; 39   : 		jASSUME( (ptr & 0xf) == 0 );
; 40   : 		m_pFnptr = ptr>>4;

	mov	edx, DWORD PTR [ecx]
	shr	eax, 4
	and	edx, -268435456				; f0000000H
	or	eax, edx
	mov	DWORD PTR [ecx], eax

; 41   : 	}

	ret	0
?SetFnptr@BASEBLOCK@@QAEXI@Z ENDP			; BASEBLOCK::SetFnptr
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetFnptr@BASEBLOCK@@QBE?BIXZ
_TEXT	SEGMENT
?GetFnptr@BASEBLOCK@@QBE?BIXZ PROC			; BASEBLOCK::GetFnptr, COMDAT
; _this$ = eax

; 35   : 	const uptr GetFnptr() const { return ((u32)m_pFnptr)<<4; }

	mov	eax, DWORD PTR [eax]
	shl	eax, 4
	ret	0
?GetFnptr@BASEBLOCK@@QBE?BIXZ ENDP			; BASEBLOCK::GetFnptr
_TEXT	ENDS
PUBLIC	?_flushMMXunused@@YAHXZ				; _flushMMXunused
; Function compile flags: /Ogtpy
; File f:\emu\ps2\src\pcsx2\x86\ix86-32\ir5900-32.cpp
_TEXT	SEGMENT
?_flushMMXunused@@YAHXZ PROC				; _flushMMXunused

; 427  : {

	push	ebx

; 428  : 	int i;
; 429  : 	for (i=0; i<MMXREGS; i++) {

	mov	ebx, DWORD PTR ?pc@@3IA			; pc
	push	ebp
	mov	ebp, DWORD PTR _s_nEndBlock
	push	esi
	push	edi
	xor	edi, edi
	mov	esi, OFFSET ?mmxregs@@3PAU_mmxregs@@A+3
$LL7@flushMMXun:

; 430  : 		if (!mmxregs[i].inuse || mmxregs[i].needed || !(mmxregs[i].mode&MODE_WRITE) ) continue;

	cmp	BYTE PTR [esi-3], 0
	je	SHORT $LN6@flushMMXun
	cmp	BYTE PTR [esi], 0
	jne	SHORT $LN6@flushMMXun
	test	BYTE PTR [esi-1], 2
	je	SHORT $LN6@flushMMXun

; 431  : 		
; 432  : 		if( MMX_ISGPR(mmxregs[i].reg) ) {

	mov	al, BYTE PTR [esi-2]
	cmp	al, 34					; 00000022H
	jae	SHORT $LN6@flushMMXun

; 433  : 			//if( !(g_pCurInstInfo->regs[mmxregs[i].reg-MMX_GPR]&EEINST_USED) ) {
; 434  : 			if( !_recIsRegWritten(g_pCurInstInfo+1, (s_nEndBlock-pc)/4, XMMTYPE_GPRREG, mmxregs[i].reg-MMX_GPR) ) {

	mov	edx, DWORD PTR ?g_pCurInstInfo@@3PAUEEINST@@A ; g_pCurInstInfo
	mov	ecx, ebp
	sub	ecx, ebx
	shr	ecx, 2
	push	5
	push	ecx
	add	edx, 112				; 00000070H
	call	?_recIsRegWritten@@YAIPAUEEINST@@HEE@Z	; _recIsRegWritten
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@flushMMXun
$LN6@flushMMXun:

; 428  : 	int i;
; 429  : 	for (i=0; i<MMXREGS; i++) {

	add	esi, 6
	inc	edi
	cmp	esi, OFFSET ?mmxregs@@3PAU_mmxregs@@A+51
	jl	SHORT $LL7@flushMMXun
	pop	edi
	pop	esi
	pop	ebp

; 438  : 			}
; 439  : 		}
; 440  : 	}
; 441  : 
; 442  : 	return 0;

	xor	eax, eax
	pop	ebx

; 443  : }

	ret	0
$LN11@flushMMXun:

; 435  : 				_freeMMXreg(i);

	mov	edx, edi
	call	?_freeMMXreg@@YAXH@Z			; _freeMMXreg

; 436  : 				mmxregs[i].inuse = 1;

	lea	edx, DWORD PTR [edi+edi*2]
	pop	edi
	pop	esi
	pop	ebp
	mov	BYTE PTR ?mmxregs@@3PAU_mmxregs@@A[edx*2], 1

; 437  : 				return 1;

	mov	eax, 1
	pop	ebx

; 443  : }

	ret	0
?_flushMMXunused@@YAHXZ ENDP				; _flushMMXunused
_TEXT	ENDS
PUBLIC	?_eeGetConstReg@@YAPAIH@Z			; _eeGetConstReg
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_reg$ = 8						; size = 4
?_eeGetConstReg@@YAPAIH@Z PROC				; _eeGetConstReg

; 326  : {

	push	ebx
	mov	ebx, DWORD PTR _reg$[esp]

; 327  : 	assert( GPR_IS_CONST1( reg ) );
; 328  : 
; 329  : 	if( g_cpuFlushedConstReg & (1<<reg) )

	mov	eax, 1
	mov	ecx, ebx
	shl	eax, cl
	test	DWORD PTR ?g_cpuFlushedConstReg@@3IA, eax ; g_cpuFlushedConstReg

; 330  : 		return &cpuRegs.GPR.r[ reg ].UL[0];

	jne	SHORT $LN8@eeGetConst

; 331  : 
; 332  : 	// if written in the future, don't flush
; 333  : 	if( _recIsRegWritten(g_pCurInstInfo+1, (s_nEndBlock-pc)/4, XMMTYPE_GPRREG, reg) ) {

	mov	ecx, DWORD PTR _s_nEndBlock
	sub	ecx, DWORD PTR ?pc@@3IA			; pc
	mov	edx, DWORD PTR ?g_pCurInstInfo@@3PAUEEINST@@A ; g_pCurInstInfo
	shr	ecx, 2
	push	5
	push	ecx
	add	edx, 112				; 00000070H
	mov	al, bl
	call	?_recIsRegWritten@@YAIPAUEEINST@@HEE@Z	; _recIsRegWritten
	add	esp, 8
	test	eax, eax
	je	SHORT $LN1@eeGetConst

; 334  : 		u32* ptempmem;
; 335  : 		ptempmem = recAllocStackMem(8, 4);

	mov	eax, DWORD PTR _recStackPtr
	mov	ecx, eax
	and	ecx, 3
	je	SHORT $LN5@eeGetConst
	mov	edx, 4
	sub	edx, ecx
	add	eax, edx
$LN5@eeGetConst:
	add	eax, 8
	mov	DWORD PTR _recStackPtr, eax
	add	eax, -8					; fffffff8H

; 336  : 		ptempmem[0] = g_cpuConstRegs[ reg ].UL[0];

	shl	ebx, 4
	mov	ecx, DWORD PTR ?g_cpuConstRegs@@3PATGPR_reg64@@A[ebx]
	mov	DWORD PTR [eax], ecx

; 337  : 		ptempmem[1] = g_cpuConstRegs[ reg ].UL[1];

	mov	edx, DWORD PTR ?g_cpuConstRegs@@3PATGPR_reg64@@A[ebx+4]
	mov	DWORD PTR [eax+4], edx
	pop	ebx

; 343  : }

	ret	0
$LN1@eeGetConst:

; 338  : 		return ptempmem;
; 339  : 	}
; 340  : 	
; 341  : 	_flushConstReg(reg);

	mov	ecx, ebx
	call	?_flushConstReg@@YAXH@Z			; _flushConstReg
$LN8@eeGetConst:

; 342  : 	return &cpuRegs.GPR.r[ reg ].UL[0];

	mov	eax, ebx
	shl	eax, 4
	add	eax, OFFSET ?cpuRegs@@3UcpuRegisters@@A	; cpuRegs
	pop	ebx

; 343  : }

	ret	0
?_eeGetConstReg@@YAPAIH@Z ENDP				; _eeGetConstReg
_TEXT	ENDS
PUBLIC	?CheckForBIOSEnd@@YAXXZ				; CheckForBIOSEnd
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?CheckForBIOSEnd@@YAXXZ PROC				; CheckForBIOSEnd

; 1005 : 
; 1006 : 	// return
; 1007 : 	j8Ptr[2] = JMP8(0);

	push	ebx

; 1008 : 
; 1009 : 	x86SetJ8( j8Ptr[0] );

	push	esi
	push	edi

; 998  : 	MOV32MtoR(EAX, (int)&cpuRegs.pc);

	mov	eax, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
	mov	BYTE PTR [eax], 139			; 0000008bH
	mov	BYTE PTR [eax+1], 5
	inc	eax
	mov	DWORD PTR [eax+1], OFFSET ?cpuRegs@@3UcpuRegisters@@A+680
	inc	eax

; 999  : 
; 1000 : 	CMP32ItoR(EAX, 0x00200008);

	mov	BYTE PTR [eax+4], 61			; 0000003dH
	add	eax, 4
	mov	DWORD PTR [eax+1], 2097160		; 00200008H
	inc	eax

; 1001 : 	j8Ptr[0] = JE8(0);

	mov	BYTE PTR [eax+4], 116			; 00000074H
	add	eax, 4
	mov	BYTE PTR [eax+1], 0
	inc	eax
	inc	eax
	lea	ecx, DWORD PTR [eax-1]
	mov	DWORD PTR ?j8Ptr@@3PAPAEA, ecx

; 1002 : 
; 1003 : 	CMP32ItoR(EAX, 0x00100008);

	mov	BYTE PTR [eax], 61			; 0000003dH
	mov	DWORD PTR [eax+1], 1048584		; 00100008H
	inc	eax

; 1004 : 	j8Ptr[1] = JE8(0);

	mov	BYTE PTR [eax+4], 116			; 00000074H
	add	eax, 4
	mov	BYTE PTR [eax+1], 0
	inc	eax
	inc	eax
	lea	edx, DWORD PTR [eax-1]
	mov	DWORD PTR ?j8Ptr@@3PAPAEA+4, edx

; 1005 : 
; 1006 : 	// return
; 1007 : 	j8Ptr[2] = JMP8(0);

	mov	BYTE PTR [eax], 235			; 000000ebH
	inc	eax
	mov	BYTE PTR [eax], 0
	inc	eax
	lea	ecx, DWORD PTR [eax-1]
	mov	DWORD PTR ?j8Ptr@@3PAPAEA+8, ecx

; 1008 : 
; 1009 : 	x86SetJ8( j8Ptr[0] );

	mov	ecx, DWORD PTR ?j8Ptr@@3PAPAEA
	mov	ebx, eax
	sub	ebx, ecx
	dec	ebx
	mov	DWORD PTR ?x86Ptr@@3PAEA, eax		; x86Ptr
	mov	edi, ecx
	cmp	ebx, 127				; 0000007fH
	jbe	SHORT $LN69@CheckForBI
	mov	esi, OFFSET ??_C@_0BH@PGICDMIF@j8?5greater?5than?50x7f?$CB?$CB?$AA@
	call	?Error@Console@@YA_NPBD@Z		; Console::Error
	mov	eax, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
$LN69@CheckForBI:
	mov	BYTE PTR [edi], bl

; 1010 : 	x86SetJ8( j8Ptr[1] );

	mov	ecx, DWORD PTR ?j8Ptr@@3PAPAEA+4
	mov	ebx, eax
	sub	ebx, ecx
	dec	ebx
	mov	edi, ecx
	cmp	ebx, 127				; 0000007fH
	jbe	SHORT $LN72@CheckForBI
	mov	esi, OFFSET ??_C@_0BH@PGICDMIF@j8?5greater?5than?50x7f?$CB?$CB?$AA@
	call	?Error@Console@@YA_NPBD@Z		; Console::Error
	mov	eax, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
$LN72@CheckForBI:
	mov	BYTE PTR [edi], bl

; 1011 : 
; 1012 : 	// bios end
; 1013 : 	RET2();

	mov	edx, 50163				; 0000c3f3H
	mov	WORD PTR [eax], dx

; 1014 : 
; 1015 : 	x86SetJ8( j8Ptr[2] );

	mov	ecx, DWORD PTR ?j8Ptr@@3PAPAEA+8
	add	eax, 2
	mov	DWORD PTR ?x86Ptr@@3PAEA, eax		; x86Ptr
	sub	eax, ecx
	dec	eax
	mov	ebx, eax
	mov	edi, ecx
	cmp	ebx, 127				; 0000007fH
	jbe	SHORT $LN82@CheckForBI
	mov	esi, OFFSET ??_C@_0BH@PGICDMIF@j8?5greater?5than?50x7f?$CB?$CB?$AA@
	call	?Error@Console@@YA_NPBD@Z		; Console::Error
$LN82@CheckForBI:
	mov	BYTE PTR [edi], bl
	pop	edi
	pop	esi
	pop	ebx

; 1016 : }

	ret	0
?CheckForBIOSEnd@@YAXXZ ENDP				; CheckForBIOSEnd
_TEXT	ENDS
PUBLIC	?_flushXMMunused@@YAHXZ				; _flushXMMunused
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?_flushXMMunused@@YAHXZ PROC				; _flushXMMunused

; 408  : {

	push	ebx

; 409  : 	int i;
; 410  : 	for (i=0; i<XMMREGS; i++) {

	mov	ebx, DWORD PTR ?g_pCurInstInfo@@3PAUEEINST@@A ; g_pCurInstInfo
	push	ebp
	mov	ebp, DWORD PTR ?pc@@3IA			; pc
	push	esi
	push	edi
	mov	edi, DWORD PTR _s_nEndBlock
	xor	esi, esi
	npad	8
$LL7@flushXMMun:

; 411  : 		if (!xmmregs[i].inuse || xmmregs[i].needed || !(xmmregs[i].mode&MODE_WRITE) ) continue;

	cmp	BYTE PTR ?xmmregs@@3PAU_xmmregs@@A[esi*8], 0
	je	SHORT $LN6@flushXMMun
	cmp	BYTE PTR ?xmmregs@@3PAU_xmmregs@@A[esi*8+4], 0
	jne	SHORT $LN6@flushXMMun
	test	BYTE PTR ?xmmregs@@3PAU_xmmregs@@A[esi*8+3], 2
	je	SHORT $LN6@flushXMMun

; 412  : 		
; 413  : 		if (xmmregs[i].type == XMMTYPE_GPRREG ) {

	cmp	BYTE PTR ?xmmregs@@3PAU_xmmregs@@A[esi*8+2], 5
	jne	SHORT $LN6@flushXMMun

; 414  : 			//if( !(g_pCurInstInfo->regs[xmmregs[i].reg]&EEINST_USED) ) {
; 415  : 			if( !_recIsRegWritten(g_pCurInstInfo+1, (s_nEndBlock-pc)/4, XMMTYPE_GPRREG, xmmregs[i].reg) ) {

	mov	eax, edi
	sub	eax, ebp
	shr	eax, 2
	push	5
	push	eax
	mov	al, BYTE PTR ?xmmregs@@3PAU_xmmregs@@A[esi*8+1]
	lea	edx, DWORD PTR [ebx+112]
	call	?_recIsRegWritten@@YAIPAUEEINST@@HEE@Z	; _recIsRegWritten
	add	esp, 8
	test	eax, eax
	je	SHORT $LN11@flushXMMun
$LN6@flushXMMun:

; 409  : 	int i;
; 410  : 	for (i=0; i<XMMREGS; i++) {

	inc	esi
	cmp	esi, 8
	jl	SHORT $LL7@flushXMMun
	pop	edi
	pop	esi
	pop	ebp

; 419  : 			}
; 420  : 		}
; 421  : 	}
; 422  : 
; 423  : 	return 0;

	xor	eax, eax
	pop	ebx

; 424  : }

	ret	0
$LN11@flushXMMun:

; 416  : 				_freeXMMreg(i);

	mov	eax, esi
	call	?_freeXMMreg@@YAXH@Z			; _freeXMMreg
	pop	edi

; 417  : 				xmmregs[i].inuse = 1;

	mov	BYTE PTR ?xmmregs@@3PAU_xmmregs@@A[esi*8], 1
	pop	esi
	pop	ebp

; 418  : 				return 1;

	mov	eax, 1
	pop	ebx

; 424  : }

	ret	0
?_flushXMMunused@@YAHXZ ENDP				; _flushXMMunused
_TEXT	ENDS
PUBLIC	?_eeMoveGPRtoRm@@YAXHH@Z			; _eeMoveGPRtoRm
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?_eeMoveGPRtoRm@@YAXHH@Z PROC				; _eeMoveGPRtoRm
; _fromgpr$ = eax

; 387  : {

	push	esi
	mov	esi, eax

; 388  : 	if( GPR_IS_CONST1(fromgpr) )

	cmp	esi, 32					; 00000020H
	jge	SHORT $LN6@eeMoveGPRt
	mov	eax, 1
	mov	ecx, esi
	shl	eax, cl
	test	DWORD PTR ?g_cpuHasConstReg@@3IA, eax	; g_cpuHasConstReg
	je	SHORT $LN6@eeMoveGPRt

; 389  : 		MOV32ItoRmOffset( to, g_cpuConstRegs[fromgpr].UL[0], 0 );

	mov	eax, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
	shl	esi, 4
	mov	esi, DWORD PTR ?g_cpuConstRegs@@3PATGPR_reg64@@A[esi]
	mov	BYTE PTR [eax], 199			; 000000c7H
	inc	eax
	mov	BYTE PTR [eax], 4
	inc	eax
	mov	BYTE PTR [eax], 36			; 00000024H
	inc	eax
	mov	DWORD PTR [eax], esi
	add	eax, 4

; 402  : 			MOV32RtoRm(to, EAX );

	mov	DWORD PTR ?x86Ptr@@3PAEA, eax		; x86Ptr
	pop	esi

; 403  : 		}
; 404  : 	}
; 405  : }

	ret	0
$LN6@eeMoveGPRt:

; 390  : 	else {
; 391  : 		int mmreg;
; 392  : 		
; 393  : 		if( (mmreg = _checkXMMreg(XMMTYPE_GPRREG, fromgpr, MODE_READ)) >= 0 ) {

	push	1
	push	5
	mov	ecx, esi
	call	?_checkXMMreg@@YAHHHH@Z			; _checkXMMreg
	add	esp, 8
	test	eax, eax
	jl	SHORT $LN4@eeMoveGPRt

; 394  : 			SSEX_MOVD_XMM_to_Rm(to, mmreg);

	cmp	DWORD PTR ?g_xmmtypes@@3PAW4XMMSSEType@@A[eax*4], 0
	mov	ecx, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
	jne	SHORT $LN74@eeMoveGPRt
	mov	BYTE PTR [ecx], 102			; 00000066H
	mov	edx, 32271				; 00007e0fH
	jmp	SHORT $LN150@eeMoveGPRt
$LN74@eeMoveGPRt:
	mov	BYTE PTR [ecx], 243			; 000000f3H
	mov	edx, 4367				; 0000110fH
$LN150@eeMoveGPRt:
	and	al, 7
	add	al, al
	add	al, al
	inc	ecx
	mov	WORD PTR [ecx], dx
	add	al, al
	add	ecx, 2
	or	al, 4
	mov	BYTE PTR [ecx], al
	inc	ecx
	mov	DWORD PTR ?x86Ptr@@3PAEA, ecx		; x86Ptr
	pop	esi

; 403  : 		}
; 404  : 	}
; 405  : }

	ret	0
$LN4@eeMoveGPRt:

; 395  : 		}
; 396  : 		else if( (mmreg = _checkMMXreg(MMX_GPR+fromgpr, MODE_READ)) >= 0 ) {

	push	1
	mov	eax, esi
	call	?_checkMMXreg@@YAHHH@Z			; _checkMMXreg
	add	esp, 4
	test	eax, eax
	jl	SHORT $LN2@eeMoveGPRt

; 397  : 			MOVD32MMXtoRm(to, mmreg);

	mov	ecx, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
	and	al, 7
	add	al, al
	add	al, al
	add	al, al
	mov	edx, 32271				; 00007e0fH
	mov	WORD PTR [ecx], dx
	add	ecx, 2
	or	al, 4
	mov	BYTE PTR [ecx], al
	inc	ecx
	mov	BYTE PTR [ecx], 36			; 00000024H
	inc	ecx

; 398  : 			SetMMXstate();

	mov	eax, 1
	mov	DWORD PTR ?x86Ptr@@3PAEA, ecx		; x86Ptr
	mov	WORD PTR ?x86FpuState@@3GA, ax		; x86FpuState
	pop	esi

; 403  : 		}
; 404  : 	}
; 405  : }

	ret	0
$LN2@eeMoveGPRt:

; 399  : 		}
; 400  : 		else {
; 401  : 			MOV32MtoR(EAX, (int)&cpuRegs.GPR.r[ fromgpr ].UL[ 0 ] );

	mov	eax, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
	mov	BYTE PTR [eax], 139			; 0000008bH
	mov	BYTE PTR [eax+1], 5
	inc	eax
	inc	eax
	shl	esi, 4
	add	esi, OFFSET ?cpuRegs@@3UcpuRegisters@@A	; cpuRegs
	mov	DWORD PTR [eax], esi
	add	eax, 4

; 402  : 			MOV32RtoRm(to, EAX );

	mov	BYTE PTR [eax], 137			; 00000089H
	inc	eax
	mov	BYTE PTR [eax], 4
	inc	eax
	mov	BYTE PTR [eax], 36			; 00000024H
	inc	eax
	mov	DWORD PTR ?x86Ptr@@3PAEA, eax		; x86Ptr
	pop	esi

; 403  : 		}
; 404  : 	}
; 405  : }

	ret	0
?_eeMoveGPRtoRm@@YAXHH@Z ENDP				; _eeMoveGPRtoRm
_TEXT	ENDS
PUBLIC	?_eeMoveGPRtoM@@YAXIH@Z				; _eeMoveGPRtoM
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?_eeMoveGPRtoM@@YAXIH@Z PROC				; _eeMoveGPRtoM
; _to$ = edi
; _fromgpr$ = eax

; 366  : {

	push	esi
	mov	esi, eax

; 367  : 	if( GPR_IS_CONST1(fromgpr) )

	cmp	esi, 32					; 00000020H
	jge	SHORT $LN6@eeMoveGPRt@2
	mov	eax, 1
	mov	ecx, esi
	shl	eax, cl
	test	DWORD PTR ?g_cpuHasConstReg@@3IA, eax	; g_cpuHasConstReg
	je	SHORT $LN6@eeMoveGPRt@2

; 368  : 		MOV32ItoM( to, g_cpuConstRegs[fromgpr].UL[0] );

	mov	eax, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
	shl	esi, 4
	mov	esi, DWORD PTR ?g_cpuConstRegs@@3PATGPR_reg64@@A[esi]
	mov	BYTE PTR [eax], 199			; 000000c7H
	inc	eax
	mov	BYTE PTR [eax], 5
	inc	eax
	mov	DWORD PTR [eax], edi
	add	eax, 4
	mov	DWORD PTR [eax], esi

; 381  : 			MOV32RtoM(to, EAX );

	add	eax, 4
	mov	DWORD PTR ?x86Ptr@@3PAEA, eax		; x86Ptr
	pop	esi

; 382  : 		}
; 383  : 	}
; 384  : }

	ret	0
$LN6@eeMoveGPRt@2:

; 369  : 	else {
; 370  : 		int mmreg;
; 371  : 		
; 372  : 		if( (mmreg = _checkXMMreg(XMMTYPE_GPRREG, fromgpr, MODE_READ)) >= 0 ) {

	push	1
	push	5
	mov	ecx, esi
	call	?_checkXMMreg@@YAHHHH@Z			; _checkXMMreg
	add	esp, 8
	test	eax, eax
	jl	SHORT $LN4@eeMoveGPRt@2

; 373  : 			SSEX_MOVD_XMM_to_M32(to, mmreg);

	cmp	DWORD PTR ?g_xmmtypes@@3PAW4XMMSSEType@@A[eax*4], 0
	mov	ecx, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
	jne	SHORT $LN22@eeMoveGPRt@2
	mov	BYTE PTR [ecx], 102			; 00000066H
	mov	edx, 32271				; 00007e0fH
	jmp	SHORT $LN91@eeMoveGPRt@2
$LN22@eeMoveGPRt@2:
	mov	BYTE PTR [ecx], 243			; 000000f3H
	mov	edx, 4367				; 0000110fH
$LN91@eeMoveGPRt@2:
	and	al, 7
	add	al, al
	inc	ecx
	add	al, al
	mov	WORD PTR [ecx], dx
	add	al, al
	add	ecx, 2
	or	al, 5
	mov	BYTE PTR [ecx], al
	inc	ecx
	mov	DWORD PTR [ecx], edi
	add	ecx, 4
	mov	DWORD PTR ?x86Ptr@@3PAEA, ecx		; x86Ptr
	pop	esi

; 382  : 		}
; 383  : 	}
; 384  : }

	ret	0
$LN4@eeMoveGPRt@2:

; 374  : 		}
; 375  : 		else if( (mmreg = _checkMMXreg(MMX_GPR+fromgpr, MODE_READ)) >= 0 ) {

	push	1
	mov	eax, esi
	call	?_checkMMXreg@@YAHHH@Z			; _checkMMXreg
	add	esp, 4
	test	eax, eax
	jl	SHORT $LN2@eeMoveGPRt@2

; 376  : 			MOVDMMXtoM(to, mmreg);

	mov	ecx, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
	and	al, 7
	add	al, al
	add	al, al
	add	al, al
	mov	edx, 32271				; 00007e0fH
	mov	WORD PTR [ecx], dx
	add	ecx, 2
	or	al, 5
	mov	BYTE PTR [ecx], al
	inc	ecx
	mov	DWORD PTR [ecx], edi
	add	ecx, 4

; 377  : 			SetMMXstate();

	mov	eax, 1
	mov	DWORD PTR ?x86Ptr@@3PAEA, ecx		; x86Ptr
	mov	WORD PTR ?x86FpuState@@3GA, ax		; x86FpuState
	pop	esi

; 382  : 		}
; 383  : 	}
; 384  : }

	ret	0
$LN2@eeMoveGPRt@2:

; 378  : 		}
; 379  : 		else {
; 380  : 			MOV32MtoR(EAX, (int)&cpuRegs.GPR.r[ fromgpr ].UL[ 0 ] );

	mov	eax, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
	mov	BYTE PTR [eax], 139			; 0000008bH
	mov	BYTE PTR [eax+1], 5
	inc	eax
	inc	eax
	shl	esi, 4
	add	esi, OFFSET ?cpuRegs@@3UcpuRegisters@@A	; cpuRegs
	mov	DWORD PTR [eax], esi
	add	eax, 4

; 381  : 			MOV32RtoM(to, EAX );

	mov	BYTE PTR [eax], 137			; 00000089H
	inc	eax
	mov	BYTE PTR [eax], 5
	inc	eax
	mov	DWORD PTR [eax], edi
	add	eax, 4
	mov	DWORD PTR ?x86Ptr@@3PAEA, eax		; x86Ptr
	pop	esi

; 382  : 		}
; 383  : 	}
; 384  : }

	ret	0
?_eeMoveGPRtoM@@YAXIH@Z ENDP				; _eeMoveGPRtoM
_TEXT	ENDS
PUBLIC	?_eeMoveGPRtoR@@YAXHH@Z				; _eeMoveGPRtoR
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_to$ = 8						; size = 4
?_eeMoveGPRtoR@@YAXHH@Z PROC				; _eeMoveGPRtoR
; _fromgpr$ = eax

; 346  : {

	push	ebx
	mov	bl, BYTE PTR _to$[esp]
	push	esi
	mov	esi, eax

; 347  : 	if( GPR_IS_CONST1(fromgpr) )

	cmp	esi, 32					; 00000020H
	jge	SHORT $LN6@eeMoveGPRt@3
	mov	eax, 1
	mov	ecx, esi
	shl	eax, cl
	test	DWORD PTR ?g_cpuHasConstReg@@3IA, eax	; g_cpuHasConstReg
	je	SHORT $LN6@eeMoveGPRt@3

; 348  : 		MOV32ItoR( to, g_cpuConstRegs[fromgpr].UL[0] );

	mov	eax, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
	and	bl, 7
	shl	esi, 4
	mov	esi, DWORD PTR ?g_cpuConstRegs@@3PATGPR_reg64@@A[esi]
	or	bl, 184					; 000000b8H

; 358  : 		}
; 359  : 		else {
; 360  : 			MOV32MtoR(to, (int)&cpuRegs.GPR.r[ fromgpr ].UL[ 0 ] );

	mov	BYTE PTR [eax], bl
	inc	eax
	mov	DWORD PTR [eax], esi
	add	eax, 4
	pop	esi
	mov	DWORD PTR ?x86Ptr@@3PAEA, eax		; x86Ptr
	pop	ebx

; 361  : 		}
; 362  : 	}
; 363  : }

	ret	0
$LN6@eeMoveGPRt@3:

; 349  : 	else {
; 350  : 		int mmreg;
; 351  : 		
; 352  : 		if( (mmreg = _checkXMMreg(XMMTYPE_GPRREG, fromgpr, MODE_READ)) >= 0 && (xmmregs[mmreg].mode&MODE_WRITE)) {

	push	1
	push	5
	mov	ecx, esi
	call	?_checkXMMreg@@YAHHHH@Z			; _checkXMMreg
	add	esp, 8
	test	eax, eax
	jl	SHORT $LN4@eeMoveGPRt@3
	test	BYTE PTR ?xmmregs@@3PAU_xmmregs@@A[eax*8+3], 2
	je	SHORT $LN4@eeMoveGPRt@3

; 353  : 			SSE2_MOVD_XMM_to_R(to, mmreg);

	mov	ecx, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
	or	al, 248					; 000000f8H
	add	al, al
	mov	BYTE PTR [ecx], 102			; 00000066H
	add	al, al
	inc	ecx
	and	bl, 7
	mov	edx, 32271				; 00007e0fH
	mov	WORD PTR [ecx], dx
	add	al, al
	or	al, bl
	add	ecx, 2
	mov	BYTE PTR [ecx], al
	inc	ecx
	pop	esi
	mov	DWORD PTR ?x86Ptr@@3PAEA, ecx		; x86Ptr
	pop	ebx

; 361  : 		}
; 362  : 	}
; 363  : }

	ret	0
$LN4@eeMoveGPRt@3:

; 354  : 		}
; 355  : 		else if( (mmreg = _checkMMXreg(MMX_GPR+fromgpr, MODE_READ)) >= 0 && (mmxregs[mmreg].mode&MODE_WRITE) ) {

	push	1
	mov	eax, esi
	call	?_checkMMXreg@@YAHHH@Z			; _checkMMXreg
	add	esp, 4
	test	eax, eax
	jl	SHORT $LN2@eeMoveGPRt@3
	lea	ecx, DWORD PTR [eax+eax*2]
	test	BYTE PTR ?mmxregs@@3PAU_mmxregs@@A[ecx*2+2], 2
	je	SHORT $LN2@eeMoveGPRt@3

; 356  : 			MOVD32MMXtoR(to, mmreg);

	mov	ecx, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
	or	al, 248					; 000000f8H
	add	al, al
	add	al, al
	add	al, al
	and	bl, 7
	mov	edx, 32271				; 00007e0fH
	mov	WORD PTR [ecx], dx
	or	al, bl
	add	ecx, 2
	mov	BYTE PTR [ecx], al
	inc	ecx

; 357  : 			SetMMXstate();

	mov	eax, 1
	pop	esi
	mov	DWORD PTR ?x86Ptr@@3PAEA, ecx		; x86Ptr
	mov	WORD PTR ?x86FpuState@@3GA, ax		; x86FpuState
	pop	ebx

; 361  : 		}
; 362  : 	}
; 363  : }

	ret	0
$LN2@eeMoveGPRt@3:

; 358  : 		}
; 359  : 		else {
; 360  : 			MOV32MtoR(to, (int)&cpuRegs.GPR.r[ fromgpr ].UL[ 0 ] );

	mov	eax, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
	and	bl, 7
	add	bl, bl
	add	bl, bl
	mov	BYTE PTR [eax], 139			; 0000008bH
	add	bl, bl
	inc	eax
	or	bl, 5
	mov	BYTE PTR [eax], bl
	shl	esi, 4
	add	esi, OFFSET ?cpuRegs@@3UcpuRegisters@@A	; cpuRegs
	inc	eax
	mov	DWORD PTR [eax], esi
	add	eax, 4
	pop	esi
	mov	DWORD PTR ?x86Ptr@@3PAEA, eax		; x86Ptr
	pop	ebx

; 361  : 		}
; 362  : 	}
; 363  : }

	ret	0
?_eeMoveGPRtoR@@YAXHH@Z ENDP				; _eeMoveGPRtoR
_TEXT	ENDS
PUBLIC	?_eeFlushAllUnused@@YAXXZ			; _eeFlushAllUnused
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?_eeFlushAllUnused@@YAXXZ PROC				; _eeFlushAllUnused

; 301  : {

	push	ebp

; 302  : 	int i;
; 303  : 	for(i = 0; i < 34; ++i) {

	mov	ebp, DWORD PTR ?g_pCurInstInfo@@3PAUEEINST@@A ; g_pCurInstInfo
	push	esi
	push	edi
	xor	esi, esi
	mov	edi, OFFSET ?cpuRegs@@3UcpuRegisters@@A	; cpuRegs
$LL13@eeFlushAll:

; 304  : 		if( pc < s_nEndBlock ) {

	mov	eax, DWORD PTR _s_nEndBlock
	cmp	DWORD PTR ?pc@@3IA, eax			; pc
	jae	SHORT $LN10@eeFlushAll

; 305  : 			if( (g_pCurInstInfo[1].regs[i]&EEINST_USED) )

	test	BYTE PTR [esi+ebp+112], 64		; 00000040H

; 306  : 				continue;
; 307  : 		}

	jmp	SHORT $LN71@eeFlushAll
$LN10@eeFlushAll:

; 308  : 		else if( (g_pCurInstInfo[0].regs[i]&EEINST_USED) )

	test	BYTE PTR [esi+ebp], 64			; 00000040H
$LN71@eeFlushAll:
	jne	$LN12@eeFlushAll

; 309  : 			continue;
; 310  : 
; 311  : 		if( i < 32 && GPR_IS_CONST1(i) ) _flushConstReg(i);

	cmp	esi, 32					; 00000020H
	jge	SHORT $LN68@eeFlushAll
	mov	eax, DWORD PTR ?g_cpuHasConstReg@@3IA	; g_cpuHasConstReg
	mov	edx, 1
	mov	ecx, esi
	shl	edx, cl
	test	edx, eax
	je	SHORT $LN68@eeFlushAll
	call	?_flushConstReg@@YAXH@Z			; _flushConstReg

; 312  : 		else {	

	jmp	$LN12@eeFlushAll
$LN68@eeFlushAll:

; 313  : 			_deleteMMXreg(MMX_GPR+i, 1);

	push	1
	mov	ecx, esi
	call	?_deleteMMXreg@@YAXHH@Z			; _deleteMMXreg
	add	esp, 4

; 314  : 			_deleteGPRtoXMMreg(i, 1);

	xor	ecx, ecx
	npad	3
$LL25@eeFlushAll:
	cmp	BYTE PTR ?xmmregs@@3PAU_xmmregs@@A[ecx*8], 0
	je	SHORT $LN24@eeFlushAll
	cmp	BYTE PTR ?xmmregs@@3PAU_xmmregs@@A[ecx*8+2], 5
	jne	SHORT $LN24@eeFlushAll
	movzx	edx, BYTE PTR ?xmmregs@@3PAU_xmmregs@@A[ecx*8+1]
	cmp	edx, esi
	je	SHORT $LN61@eeFlushAll
$LN24@eeFlushAll:
	inc	ecx
	cmp	ecx, 8
	jl	SHORT $LL25@eeFlushAll
	jmp	SHORT $LN12@eeFlushAll
$LN61@eeFlushAll:
	test	BYTE PTR ?xmmregs@@3PAU_xmmregs@@A[ecx*8+3], 2
	je	SHORT $LN12@eeFlushAll
	cmp	DWORD PTR ?g_xmmtypes@@3PAW4XMMSSEType@@A[ecx*4], 0
	mov	eax, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
	jne	SHORT $LN29@eeFlushAll
	mov	BYTE PTR [eax], 102			; 00000066H
	inc	eax
	mov	edx, 32527				; 00007f0fH
	jmp	SHORT $LN72@eeFlushAll
$LN29@eeFlushAll:
	mov	edx, 10511				; 0000290fH
$LN72@eeFlushAll:
	mov	WORD PTR [eax], dx
	mov	dl, cl
	and	dl, 7
	add	dl, dl
	add	dl, dl
	add	eax, 2
	add	dl, dl
	or	dl, 5
	mov	BYTE PTR [eax], dl
	inc	eax
	mov	DWORD PTR [eax], edi
	add	eax, 4
	mov	DWORD PTR ?x86Ptr@@3PAEA, eax		; x86Ptr
	mov	al, BYTE PTR ?xmmregs@@3PAU_xmmregs@@A[ecx*8+3]
	and	al, 253					; 000000fdH
	or	al, 1
	mov	BYTE PTR ?xmmregs@@3PAU_xmmregs@@A[ecx*8+3], al
$LN12@eeFlushAll:
	inc	esi
	add	edi, 16					; 00000010H
	cmp	esi, 34					; 00000022H
	jl	$LL13@eeFlushAll

; 315  : 		}
; 316  : 	}
; 317  : 
; 318  : 	//TODO when used info is done for FPU and VU0
; 319  : 	for(i = 0; i < XMMREGS; ++i) {

	xor	esi, esi
$LL4@eeFlushAll:

; 320  : 		if( xmmregs[i].inuse && xmmregs[i].type != XMMTYPE_GPRREG )

	cmp	BYTE PTR ?xmmregs@@3PAU_xmmregs@@A[esi*8], 0
	je	SHORT $LN3@eeFlushAll
	cmp	BYTE PTR ?xmmregs@@3PAU_xmmregs@@A[esi*8+2], 5
	je	SHORT $LN3@eeFlushAll

; 321  : 			_freeXMMreg(i);

	mov	eax, esi
	call	?_freeXMMreg@@YAXH@Z			; _freeXMMreg
$LN3@eeFlushAll:
	inc	esi
	cmp	esi, 8
	jl	SHORT $LL4@eeFlushAll
	pop	edi
	pop	esi
	pop	ebp

; 322  : 	}
; 323  : }

	ret	0
?_eeFlushAllUnused@@YAXXZ ENDP				; _eeFlushAllUnused
_TEXT	ENDS
PUBLIC	?PC_GETBLOCKEX@@YAPAUBASEBLOCKEX@@PAUBASEBLOCK@@@Z ; PC_GETBLOCKEX
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?PC_GETBLOCKEX@@YAPAUBASEBLOCKEX@@PAUBASEBLOCK@@@Z PROC	; PC_GETBLOCKEX
; _p$ = eax

; 126  : //	BASEBLOCKEX* pex = *(BASEBLOCKEX**)(p+1);
; 127  : //	if( pex >= recBlocks && pex < recBlocks+EE_NUMBLOCKS )
; 128  : //		return pex;
; 129  : 
; 130  : 	// otherwise, use the sorted list
; 131  : 	return GetBaseBlockEx(p->startpc, 0);

	mov	eax, DWORD PTR [eax+4]
	push	esi
	push	eax
	push	OFFSET _s_vecBaseBlocksEx
	call	?Get@BASEBLOCKS@@QAEHI@Z		; BASEBLOCKS::Get
	mov	ecx, DWORD PTR _s_vecBaseBlocksEx+16
	mov	esi, eax
	mov	eax, DWORD PTR _s_vecBaseBlocksEx+12
	sub	ecx, eax
	sar	ecx, 2
	cmp	esi, ecx
	jb	SHORT $LN13@PC_GETBLOC
	call	__invalid_parameter_noinfo
	mov	edx, DWORD PTR _s_vecBaseBlocksEx+12
	mov	eax, DWORD PTR [edx+esi*4]
	pop	esi

; 132  : }

	ret	0
$LN13@PC_GETBLOC:

; 126  : //	BASEBLOCKEX* pex = *(BASEBLOCKEX**)(p+1);
; 127  : //	if( pex >= recBlocks && pex < recBlocks+EE_NUMBLOCKS )
; 128  : //		return pex;
; 129  : 
; 130  : 	// otherwise, use the sorted list
; 131  : 	return GetBaseBlockEx(p->startpc, 0);

	mov	eax, DWORD PTR [eax+esi*4]
	pop	esi

; 132  : }

	ret	0
?PC_GETBLOCKEX@@YAPAUBASEBLOCKEX@@PAUBASEBLOCK@@@Z ENDP	; PC_GETBLOCKEX
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1HardwareDeficiency@Exception@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1HardwareDeficiency@Exception@@UAE@XZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1HardwareDeficiency@Exception@@UAE@XZ$1
__ehfuncinfo$??1HardwareDeficiency@Exception@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1HardwareDeficiency@Exception@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??1HardwareDeficiency@Exception@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1HardwareDeficiency@Exception@@UAE@XZ PROC		; Exception::HardwareDeficiency::~HardwareDeficiency, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??1HardwareDeficiency@Exception@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	DWORD PTR _this$[esp+16], ecx
	or	eax, -1
	mov	DWORD PTR __$EHRec$[esp+24], eax
	mov	DWORD PTR [ecx], OFFSET ??_7RuntimeError@Exception@@6B@
	mov	DWORD PTR __$EHRec$[esp+24], eax
	call	??1BaseException@Exception@@UAE@XZ	; Exception::BaseException::~BaseException
	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1HardwareDeficiency@Exception@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1RuntimeError@Exception@@UAE@XZ	; Exception::RuntimeError::~RuntimeError
__unwindfunclet$??1HardwareDeficiency@Exception@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1BaseException@Exception@@UAE@XZ	; Exception::BaseException::~BaseException
__ehhandler$??1HardwareDeficiency@Exception@@UAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1HardwareDeficiency@Exception@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1HardwareDeficiency@Exception@@UAE@XZ ENDP		; Exception::HardwareDeficiency::~HardwareDeficiency
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_GHardwareDeficiency@Exception@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_GHardwareDeficiency@Exception@@UAEPAXI@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??_GHardwareDeficiency@Exception@@UAEPAXI@Z$1
__ehfuncinfo$??_GHardwareDeficiency@Exception@@UAEPAXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??_GHardwareDeficiency@Exception@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??_GHardwareDeficiency@Exception@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_GHardwareDeficiency@Exception@@UAEPAXI@Z PROC	; Exception::HardwareDeficiency::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??_GHardwareDeficiency@Exception@@UAEPAXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	or	eax, -1
	mov	DWORD PTR __$EHRec$[esp+28], eax
	mov	DWORD PTR [esi], OFFSET ??_7RuntimeError@Exception@@6B@
	mov	DWORD PTR __$EHRec$[esp+28], eax
	call	??1BaseException@Exception@@UAE@XZ	; Exception::BaseException::~BaseException
	test	BYTE PTR ___flags$[esp+16], 1
	je	SHORT $LN10@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN10@scalar:
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_GHardwareDeficiency@Exception@@UAEPAXI@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1RuntimeError@Exception@@UAE@XZ	; Exception::RuntimeError::~RuntimeError
__unwindfunclet$??_GHardwareDeficiency@Exception@@UAEPAXI@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1BaseException@Exception@@UAE@XZ	; Exception::BaseException::~BaseException
__ehhandler$??_GHardwareDeficiency@Exception@@UAEPAXI@Z:
	mov	eax, OFFSET __ehfuncinfo$??_GHardwareDeficiency@Exception@@UAEPAXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??_GHardwareDeficiency@Exception@@UAEPAXI@Z ENDP	; Exception::HardwareDeficiency::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_newpc$ = 8						; size = 4
_ptr$ = 12						; size = 4
_noDispatch$ = 12					; size = 1
?iBranchTest@@YAXI_N@Z PROC				; iBranchTest

; 1230 : #ifdef _DEBUG
; 1231 : 	//CALLFunc((uptr)testfpu);
; 1232 : #endif
; 1233 : 	u32* ptr;
; 1234 : 
; 1235 : 	if( bExecBIOS ) CheckForBIOSEnd();

	cmp	DWORD PTR ?bExecBIOS@@3IA, 0		; bExecBIOS
	push	ebx
	mov	bl, BYTE PTR _noDispatch$[esp]
	push	ebp
	mov	ebp, DWORD PTR _newpc$[esp+4]
	push	esi
	push	edi
	je	SHORT $LN5@iBranchTes
	call	?CheckForBIOSEnd@@YAXXZ			; CheckForBIOSEnd
$LN5@iBranchTes:

; 1236 : 
; 1237 : 	MOV32MtoR(EAX, (uptr)&cpuRegs.cycle);

	mov	esi, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
	mov	BYTE PTR [esi], 139			; 0000008bH
	inc	esi
	mov	BYTE PTR [esi], 5
	inc	esi
	mov	DWORD PTR [esi], OFFSET ?cpuRegs@@3UcpuRegisters@@A+960
	add	esi, 4

; 1238 : 	if( !noDispatch && newpc != 0xffffffff )

	test	bl, bl
	jne	SHORT $LN106@iBranchTes
	cmp	ebp, -1
	je	SHORT $LN106@iBranchTes

; 1239 : 	{
; 1240 : 		// Optimization note: Instructions order to pair EDX with EAX's load above.
; 1241 : 
; 1242 : 		// Load EDX with the address of the JS32 jump below.
; 1243 : 		// We do this because the the Dispatcher will use this info to modify
; 1244 : 		// the JS instruction later on with the address of the block it's jumping
; 1245 : 		// to; creating a static link of blocks that doesn't require the overhead
; 1246 : 		// of a dispatcher.
; 1247 : 		MOV32ItoR(EDX, 0);

	mov	BYTE PTR [esi], 186			; 000000baH
	inc	esi
	mov	DWORD PTR [esi], 0
	add	esi, 4

; 1248 : 		ptr = (u32*)(x86Ptr-4);

	lea	edi, DWORD PTR [esi-4]
	jmp	SHORT $LN4@iBranchTes
$LN106@iBranchTes:
	mov	edi, DWORD PTR _ptr$[esp+12]
$LN4@iBranchTes:

; 1249 : 	}
; 1250 : 
; 1251 : 	// Check the Event scheduler if our "cycle target" has been reached.
; 1252 : 	// Equiv code to:
; 1253 : 	//    cpuRegs.cycle += blockcycles;
; 1254 : 	//    if( cpuRegs.cycle > g_nextBranchCycle ) { DoEvents(); }
; 1255 : 	ADD32ItoR(EAX, eeScaleBlockCycles());

	call	?eeScaleBlockCycles@@YAIXZ		; eeScaleBlockCycles
	cmp	eax, 128				; 00000080H
	jae	SHORT $LN31@iBranchTes
	mov	BYTE PTR [esi], 131			; 00000083H
	inc	esi
	mov	BYTE PTR [esi], 192			; 000000c0H
	inc	esi
	mov	BYTE PTR [esi], al
	inc	esi
	jmp	SHORT $LN56@iBranchTes
$LN31@iBranchTes:
	mov	BYTE PTR [esi], 5
	inc	esi
	mov	DWORD PTR [esi], eax
	add	esi, 4
$LN56@iBranchTes:

; 1256 : 	MOV32RtoM((uptr)&cpuRegs.cycle, EAX); // update cycles

	mov	BYTE PTR [esi], 137			; 00000089H
	inc	esi
	mov	BYTE PTR [esi], 5
	inc	esi
	mov	DWORD PTR [esi], OFFSET ?cpuRegs@@3UcpuRegisters@@A+960
	add	esi, 4

; 1257 : 	SUB32MtoR(EAX, (uptr)&g_nextBranchCycle);

	mov	BYTE PTR [esi], 43			; 0000002bH
	inc	esi
	mov	BYTE PTR [esi], 5
	inc	esi
	mov	DWORD PTR [esi], OFFSET ?g_nextBranchCycle@@3IA ; g_nextBranchCycle
	add	esi, 4

; 1258 : 
; 1259 : 	if( newpc != 0xffffffff )

	cmp	ebp, -1
	je	SHORT $LN3@iBranchTes

; 1260 : 	{
; 1261 : 		// This is the jump instruction which gets modified by Dispatcher.
; 1262 : 		*ptr = (u32)JS32((u32)Dispatcher - ( (u32)x86Ptr + 6 ));

	mov	BYTE PTR [esi], 15			; 0000000fH
	mov	eax, OFFSET ?Dispatcher@@YAXXZ		; Dispatcher
	sub	eax, esi
	inc	esi
	mov	BYTE PTR [esi], 136			; 00000088H
	sub	eax, 6
	inc	esi
	mov	DWORD PTR [esi], eax
	add	esi, 4
	lea	eax, DWORD PTR [esi-4]
	mov	DWORD PTR [edi], eax
	jmp	SHORT $LN100@iBranchTes
$LN3@iBranchTes:

; 1263 : 	}
; 1264 : 	else if( !noDispatch )

	test	bl, bl
	jne	SHORT $LN100@iBranchTes

; 1265 : 	{
; 1266 : 		// This instruction is a dynamic link, so it's never modified.
; 1267 : 		JS32((uptr)DispatcherReg - ( (uptr)x86Ptr + 6 ));

	mov	BYTE PTR [esi], 15			; 0000000fH
	mov	eax, OFFSET ?DispatcherReg@@YAXXZ	; DispatcherReg
	sub	eax, esi
	inc	esi
	mov	BYTE PTR [esi], 136			; 00000088H
	sub	eax, 6
	inc	esi
	mov	DWORD PTR [esi], eax
	add	esi, 4
$LN100@iBranchTes:

; 1268 : 	}
; 1269 : 
; 1270 : 	RET2();

	mov	ecx, 50163				; 0000c3f3H
	mov	WORD PTR [esi], cx
	add	esi, 2
	pop	edi
	mov	DWORD PTR ?x86Ptr@@3PAEA, esi		; x86Ptr
	pop	esi
	pop	ebp
	pop	ebx

; 1271 : }

	ret	0
?iBranchTest@@YAXI_N@Z ENDP				; iBranchTest
_TEXT	ENDS
PUBLIC	?iFlushCall@@YAXH@Z				; iFlushCall
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_flushtype$ = 8						; size = 4
?iFlushCall@@YAXH@Z PROC				; iFlushCall

; 1129 : {

	push	ebx
	mov	bl, BYTE PTR _flushtype$[esp]

; 1130 : 	_freeX86regs();

	call	?_freeX86regs@@YAXXZ			; _freeX86regs

; 1131 : 
; 1132 : 	if( flushtype & FLUSH_FREE_XMM )

	test	bl, 4
	je	SHORT $LN10@iFlushCall
	push	esi

; 1133 : 		_freeXMMregs();

	xor	esi, esi
$LL16@iFlushCall:
	cmp	BYTE PTR ?xmmregs@@3PAU_xmmregs@@A[esi*8], 0
	je	SHORT $LN15@iFlushCall
	mov	eax, esi
	call	?_freeXMMreg@@YAXH@Z			; _freeXMMreg
$LN15@iFlushCall:
	inc	esi
	cmp	esi, 8
	jl	SHORT $LL16@iFlushCall
	pop	esi
	jmp	SHORT $LN46@iFlushCall
$LN10@iFlushCall:

; 1134 : 	else if( flushtype & FLUSH_FLUSH_XMM)

	test	bl, 2
	je	SHORT $LN46@iFlushCall

; 1135 : 		_flushXMMregs();

	call	?_flushXMMregs@@YAXXZ			; _flushXMMregs
$LN46@iFlushCall:

; 1136 : 
; 1137 : 	if( flushtype & FLUSH_FREE_MMX )

	test	bl, 16					; 00000010H
	je	SHORT $LN7@iFlushCall

; 1138 : 		_freeMMXregs();

	call	?_freeMMXregs@@YAXXZ			; _freeMMXregs
	jmp	SHORT $LN5@iFlushCall
$LN7@iFlushCall:

; 1139 : 	else if( flushtype & FLUSH_FLUSH_MMX)

	test	bl, 8
	je	SHORT $LN5@iFlushCall

; 1140 : 		_flushMMXregs();

	call	?_flushMMXregs@@YAXXZ			; _flushMMXregs
$LN5@iFlushCall:

; 1141 : 
; 1142 : 	if( flushtype & FLUSH_CACHED_REGS )

	test	bl, 1
	pop	ebx
	je	SHORT $LN4@iFlushCall

; 1143 : 		_flushConstRegs();

	call	?_flushConstRegs@@YAXXZ			; _flushConstRegs
$LN4@iFlushCall:

; 1144 : 
; 1145 : 	LoadCW();

	mov	ax, WORD PTR ?iCWstate@@3GA		; iCWstate
	test	ax, ax
	je	SHORT $LN45@iFlushCall
	test	al, 1
	mov	eax, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
	je	SHORT $LN32@iFlushCall
	mov	BYTE PTR [eax], 217			; 000000d9H
	inc	eax
	mov	BYTE PTR [eax], 45			; 0000002dH
	inc	eax
	mov	DWORD PTR [eax], OFFSET _fpucws
	add	eax, 4
	mov	DWORD PTR ?x86Ptr@@3PAEA, eax		; x86Ptr
$LN32@iFlushCall:
	xor	ecx, ecx
	mov	WORD PTR ?iCWstate@@3GA, cx		; iCWstate
	jmp	SHORT $LN22@iFlushCall
$LN45@iFlushCall:
	mov	eax, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
$LN22@iFlushCall:

; 1146 : 	
; 1147 : 	if (x86FpuState==MMX_STATE) {

	cmp	WORD PTR ?x86FpuState@@3GA, 1		; x86FpuState
	jne	SHORT $LN3@iFlushCall

; 1148 : 		if (cpucaps.has3DNOWInstructionExtensions) FEMMS();

	cmp	DWORD PTR ?cpucaps@@3UCAPABILITIES@@A+136, 0
	je	SHORT $LN2@iFlushCall
	mov	edx, 3599				; 00000e0fH
	mov	WORD PTR [eax], dx

; 1149 : 		else EMMS();

	add	eax, 2

; 1150 : 		x86FpuState=FPU_STATE;

	xor	edx, edx
	mov	DWORD PTR ?x86Ptr@@3PAEA, eax		; x86Ptr
	mov	WORD PTR ?x86FpuState@@3GA, dx		; x86FpuState

; 1151 : 	}
; 1152 : }

	ret	0
$LN2@iFlushCall:

; 1149 : 		else EMMS();

	mov	ecx, 30479				; 0000770fH
	mov	WORD PTR [eax], cx
	add	eax, 2

; 1150 : 		x86FpuState=FPU_STATE;

	xor	edx, edx
	mov	DWORD PTR ?x86Ptr@@3PAEA, eax		; x86Ptr
	mov	WORD PTR ?x86FpuState@@3GA, dx		; x86FpuState
$LN3@iFlushCall:

; 1151 : 	}
; 1152 : }

	ret	0
?iFlushCall@@YAXH@Z ENDP				; iFlushCall
_TEXT	ENDS
PUBLIC	?SetBranchImm@@YAXI@Z				; SetBranchImm
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?SetBranchImm@@YAXI@Z PROC				; SetBranchImm
; _imm$ = esi

; 1070 : 	branch = 1;
; 1071 : 
; 1072 : 	assert( imm );
; 1073 : 
; 1074 : 	// end the current block
; 1075 : 	MOV32ItoM( (uptr)&cpuRegs.pc, imm );

	mov	eax, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
	mov	BYTE PTR [eax], 199			; 000000c7H
	inc	eax
	mov	BYTE PTR [eax], 5
	inc	eax
	mov	DWORD PTR [eax], OFFSET ?cpuRegs@@3UcpuRegisters@@A+680
	add	eax, 4
	mov	DWORD PTR [eax], esi
	add	eax, 4

; 1076 : 	iFlushCall(FLUSH_EVERYTHING);

	push	4095					; 00000fffH
	mov	DWORD PTR ?branch@@3HA, 1		; branch
	mov	DWORD PTR ?x86Ptr@@3PAEA, eax		; x86Ptr
	call	?iFlushCall@@YAXH@Z			; iFlushCall

; 1077 : 
; 1078 : 	iBranchTest(imm);

	push	0
	push	esi
	call	?iBranchTest@@YAXI_N@Z			; iBranchTest
	add	esp, 12					; 0000000cH

; 1079 : }

	ret	0
?SetBranchImm@@YAXI@Z ENDP				; SetBranchImm
_TEXT	ENDS
PUBLIC	?recClearMem@@YAXPAUBASEBLOCK@@@Z		; recClearMem
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_p$ = 8							; size = 4
?recClearMem@@YAXPAUBASEBLOCK@@@Z PROC			; recClearMem

; 925  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 926  : 	BASEBLOCKEX* pexblock;
; 927  : 	BASEBLOCK* pstart;
; 928  : 	int lastdelay;
; 929  : 
; 930  : 	// necessary since recompiler doesn't call femms/emms
; 931  : #ifdef _MSC_VER
; 932  : 	if (cpucaps.has3DNOWInstructionExtensions) __asm femms;

	cmp	DWORD PTR ?cpucaps@@3UCAPABILITIES@@A+136, 0
	push	esi
	push	edi
	je	SHORT $LN7@recClearMe
	femms
	jmp	SHORT $LN6@recClearMe
$LN7@recClearMe:

; 933  : 	else __asm emms;

	emms
$LN6@recClearMe:

; 934  : #else
; 935  :     if( cpucaps.has3DNOWInstructionExtensions )__asm__("femms");
; 936  :     else __asm__("emms");
; 937  : #endif
; 938  : 		
; 939  : 	assert( p != NULL );
; 940  : 
; 941  : 	if( p->uType & BLOCKTYPE_DELAYSLOT ) {

	mov	esi, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [esi]
	test	eax, 268435456				; 10000000H
	je	SHORT $LN4@recClearMe

; 942  : 		recClearMem(p-1);

	lea	eax, DWORD PTR [esi-8]
	push	eax
	call	?recClearMem@@YAXPAUBASEBLOCK@@@Z	; recClearMem

; 943  : 		if( p->GetFnptr() == 0 )

	mov	eax, DWORD PTR [esi]
	add	esp, 4
	test	eax, 268435455				; 0fffffffH
	je	$LN8@recClearMe
$LN4@recClearMe:

; 944  : 			return;
; 945  : 	}
; 946  : 
; 947  : 	assert( p->GetFnptr() != 0 );
; 948  : 	assert( p->startpc );
; 949  : 
; 950  : 	x86Ptr = (u8*)p->GetFnptr();
; 951  : 
; 952  : 	// there is a small problem: mem can be ored with 0xa<<28 or 0x8<<28, and don't know which
; 953  : 	MOV32ItoR(EDX, p->startpc);

	mov	ecx, DWORD PTR [esi+4]
	shl	eax, 4
	mov	BYTE PTR [eax], 186			; 000000baH
	mov	DWORD PTR [eax+1], ecx

; 954  : 	PUSH32I((u32)x86Ptr); // will be replaced by JMP32
; 955  : 	JMP32((u32)DispatcherClear - ( (u32)x86Ptr + 5 ));
; 956  : 	assert( x86Ptr == (u8*)p->GetFnptr() + EE_MIN_BLOCK_BYTES );
; 957  : 
; 958  : 	pstart = PC_GETBLOCK(p->startpc);

	mov	edx, DWORD PTR ?recLUT@@3PAIA		; recLUT
	inc	eax
	add	eax, 4
	mov	BYTE PTR [eax], 104			; 00000068H
	mov	ecx, eax
	mov	DWORD PTR [eax+1], ecx
	inc	eax
	add	eax, 4
	mov	BYTE PTR [eax], 233			; 000000e9H
	mov	ecx, OFFSET ?DispatcherClear@@YAXXZ	; DispatcherClear
	sub	ecx, eax
	inc	eax
	sub	ecx, 5
	mov	DWORD PTR [eax], ecx
	add	eax, 4
	mov	DWORD PTR ?x86Ptr@@3PAEA, eax		; x86Ptr
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, eax
	shr	ecx, 16					; 00000010H
	mov	ecx, DWORD PTR [edx+ecx*4]
	and	eax, 65535				; 0000ffffH
	lea	esi, DWORD PTR [ecx+eax*2]

; 959  : 	pexblock = PC_GETBLOCKEX(pstart);

	mov	eax, DWORD PTR [esi+4]
	push	eax
	push	OFFSET _s_vecBaseBlocksEx
	call	?Get@BASEBLOCKS@@QAEHI@Z		; BASEBLOCKS::Get
	mov	edx, DWORD PTR _s_vecBaseBlocksEx+16
	sub	edx, DWORD PTR _s_vecBaseBlocksEx+12
	mov	edi, eax
	sar	edx, 2
	cmp	edi, edx
	jb	SHORT $LN40@recClearMe
	call	__invalid_parameter_noinfo
$LN40@recClearMe:
	mov	eax, DWORD PTR _s_vecBaseBlocksEx+12
	mov	edi, DWORD PTR [eax+edi*4]

; 960  : 	assert( pexblock->startpc == pstart->startpc );
; 961  : 
; 962  :     if( pexblock->startpc != pstart->startpc ) {

	mov	ecx, DWORD PTR [edi+4]
	cmp	ecx, DWORD PTR [esi+4]
	je	SHORT $LN3@recClearMe

; 963  :         // some bug with ffx after beating a big snake in sewers
; 964  :         RemoveBaseBlockEx(pexblock, 0);

	mov	eax, edi
	mov	ecx, OFFSET _s_vecBaseBlocksEx
	call	?Remove@BASEBLOCKS@@QAEXPAUBASEBLOCKEX@@@Z ; BASEBLOCKS::Remove

; 965  : 	    pexblock->size = 0;

	xor	edx, edx
	mov	WORD PTR [edi], dx

; 966  : 	    pexblock->startpc = 0;

	mov	DWORD PTR [edi+4], edx

; 985  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@recClearMe:

; 967  :         return;
; 968  :     }
; 969  : 
; 970  : 	// don't delete if last is delay
; 971  : 	lastdelay = pexblock->size;

	movzx	eax, WORD PTR [edi]

; 972  : 	if( pstart[pexblock->size-1].uType & BLOCKTYPE_DELAYSLOT ) {

	mov	ecx, DWORD PTR [esi+eax*8-8]
	test	ecx, 268435456				; 10000000H
	je	SHORT $LN1@recClearMe

; 973  : 		assert( pstart[pexblock->size-1].GetFnptr() != pstart->GetFnptr() );
; 974  : 		if( pstart[pexblock->size-1].GetFnptr() != 0 ) {

	test	ecx, 268435455				; 0fffffffH
	je	SHORT $LN1@recClearMe

; 975  : 			pstart[pexblock->size-1].uType = 0;

	and	DWORD PTR [esi+eax*8-8], 268435455	; 0fffffffH

; 976  : 			--lastdelay;

	dec	eax
$LN1@recClearMe:

; 977  : 		}
; 978  : 	}
; 979  : 
; 980  : 	memset(pstart, 0, lastdelay*sizeof(BASEBLOCK));

	add	eax, eax
	add	eax, eax
	add	eax, eax
	push	eax
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH

; 981  : 
; 982  : 	RemoveBaseBlockEx(pexblock, 0);

	mov	eax, edi
	mov	ecx, OFFSET _s_vecBaseBlocksEx
	call	?Remove@BASEBLOCKS@@QAEXPAUBASEBLOCKEX@@@Z ; BASEBLOCKS::Remove

; 983  : 	pexblock->size = 0;

	xor	ecx, ecx
	mov	WORD PTR [edi], cx

; 984  : 	pexblock->startpc = 0;

	mov	DWORD PTR [edi+4], ecx
$LN8@recClearMe:

; 985  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?recClearMem@@YAXPAUBASEBLOCK@@@Z ENDP			; recClearMem
_TEXT	ENDS
PUBLIC	?REC_CLEARM@@YAXI@Z				; REC_CLEARM
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?REC_CLEARM@@YAXI@Z PROC				; REC_CLEARM
; _mem$ = eax

; 989  : 	if ((mem) < maxrecmem && recLUT[(mem) >> 16]) {

	cmp	eax, DWORD PTR ?maxrecmem@@3IA		; maxrecmem
	jae	SHORT $LN1@REC_CLEARM
	mov	edx, DWORD PTR ?recLUT@@3PAIA		; recLUT
	mov	ecx, eax
	shr	ecx, 16					; 00000010H
	mov	ecx, DWORD PTR [edx+ecx*4]
	test	ecx, ecx
	je	SHORT $LN1@REC_CLEARM

; 990  : 		BASEBLOCK* p = PC_GETBLOCK(mem);

	and	eax, 65535				; 0000ffffH

; 991  : 		if( *(u32*)p ) recClearMem(p);

	cmp	DWORD PTR [ecx+eax*2], 0
	lea	eax, DWORD PTR [ecx+eax*2]
	je	SHORT $LN1@REC_CLEARM
	push	eax
	call	?recClearMem@@YAXPAUBASEBLOCK@@@Z	; recClearMem
	pop	ecx
$LN1@REC_CLEARM:

; 992  : 	}
; 993  : }

	ret	0
?REC_CLEARM@@YAXI@Z ENDP				; REC_CLEARM
; Function compile flags: /Ogtpy
_Addr$ = 8						; size = 4
_Size$ = 12						; size = 4
?recClear@@YAXII@Z PROC					; recClear

; 916  : 	u32 i;
; 917  : 	for(i = 0; i < Size; ++i, Addr+=4) {

	mov	eax, DWORD PTR _Size$[esp-4]
	test	eax, eax
	jbe	SHORT $LN1@recClear
	push	esi
	mov	esi, DWORD PTR _Addr$[esp]
	push	edi
	mov	edi, eax
$LL3@recClear:

; 918  : 		REC_CLEARM(Addr);

	cmp	esi, DWORD PTR ?maxrecmem@@3IA		; maxrecmem
	jae	SHORT $LN2@recClear
	mov	ecx, DWORD PTR ?recLUT@@3PAIA		; recLUT
	mov	eax, esi
	shr	eax, 16					; 00000010H
	mov	eax, DWORD PTR [ecx+eax*4]
	test	eax, eax
	je	SHORT $LN2@recClear
	mov	edx, esi
	and	edx, 65535				; 0000ffffH
	cmp	DWORD PTR [eax+edx*2], 0
	lea	eax, DWORD PTR [eax+edx*2]
	je	SHORT $LN2@recClear
	push	eax
	call	?recClearMem@@YAXPAUBASEBLOCK@@@Z	; recClearMem
	add	esp, 4
$LN2@recClear:
	add	esi, 4
	sub	edi, 1
	jne	SHORT $LL3@recClear
	pop	edi
	pop	esi
$LN1@recClear:

; 919  : 	}
; 920  : }

	ret	0
?recClear@@YAXII@Z ENDP					; recClear
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0HardwareDeficiency@Exception@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0HardwareDeficiency@Exception@@QAE@ABV01@@Z$0
__ehfuncinfo$??0HardwareDeficiency@Exception@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0HardwareDeficiency@Exception@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0HardwareDeficiency@Exception@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0HardwareDeficiency@Exception@@QAE@ABV01@@Z PROC	; Exception::HardwareDeficiency::HardwareDeficiency, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0HardwareDeficiency@Exception@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	eax, DWORD PTR ___that$[esp+12]
	push	esi
	mov	esi, ecx
	push	eax
	mov	DWORD PTR _this$[esp+24], esi
	call	??0RuntimeError@Exception@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[esp+28], 0
	mov	DWORD PTR [esi], OFFSET ??_7HardwareDeficiency@Exception@@6B@
	mov	DWORD PTR __$EHRec$[esp+28], -1
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0HardwareDeficiency@Exception@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1RuntimeError@Exception@@UAE@XZ	; Exception::RuntimeError::~RuntimeError
__ehhandler$??0HardwareDeficiency@Exception@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0HardwareDeficiency@Exception@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0HardwareDeficiency@Exception@@QAE@ABV01@@Z ENDP	; Exception::HardwareDeficiency::HardwareDeficiency
;	COMDAT xdata$x
; File f:\emu\ps2\src\pcsx2\exceptions.h
xdata$x	SEGMENT
__unwindtable$??0HardwareDeficiency@Exception@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0HardwareDeficiency@Exception@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0
__ehfuncinfo$??0HardwareDeficiency@Exception@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0HardwareDeficiency@Exception@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0HardwareDeficiency@Exception@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_msg$ = 12						; size = 4
??0HardwareDeficiency@Exception@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Exception::HardwareDeficiency::HardwareDeficiency, COMDAT

; 141  : 			RuntimeError( msg ) {}

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??0HardwareDeficiency@Exception@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	push	eax
	mov	eax, DWORD PTR _msg$[esp+8]
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, DWORD PTR _this$[esp+12]
	push	eax
	push	esi
	call	??0RuntimeError@Exception@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Exception::RuntimeError::RuntimeError
	mov	DWORD PTR __$EHRec$[esp+24], 0
	mov	DWORD PTR [esi], OFFSET ??_7HardwareDeficiency@Exception@@6B@
	mov	DWORD PTR __$EHRec$[esp+24], -1
	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	eax, esi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0HardwareDeficiency@Exception@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp-4]
	jmp	??1RuntimeError@Exception@@UAE@XZ	; Exception::RuntimeError::~RuntimeError
__ehhandler$??0HardwareDeficiency@Exception@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0HardwareDeficiency@Exception@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0HardwareDeficiency@Exception@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Exception::HardwareDeficiency::HardwareDeficiency
; Function compile flags: /Ogtpy
; File f:\emu\ps2\src\pcsx2\x86\ix86-32\ir5900-32.cpp
_TEXT	SEGMENT
?dyna_block_discard@@YIXII@Z PROC			; dyna_block_discard
; _start$ = ecx
; _sz$ = edx

; 1528 : {

	push	ecx
	push	esi
	push	edi
	mov	esi, edx

; 1529 : 	DevCon::WriteLn("dyna_block_discard %08X , count %d", params start,sz);

	push	esi
	mov	edi, ecx
	push	edi
	push	0
	push	OFFSET ??_C@_0CD@COAJMALJ@dyna_block_discard?5?$CF08X?5?0?5count?5@
	call	?WriteLn@Console@@YA_NPBDPBU_VARG_PARAM@@ZZ ; Console::WriteLn

; 1530 : 	Cpu->Clear(start,sz);

	mov	eax, DWORD PTR ?Cpu@@3PAUR5900cpu@@A	; Cpu
	mov	ecx, DWORD PTR [eax+20]
	push	esi
	push	edi
	call	ecx
	add	esp, 24					; 00000018H

; 1531 : }

	pop	edi
	pop	esi
	pop	ecx
	ret	0
?dyna_block_discard@@YIXII@Z ENDP			; dyna_block_discard
; Function compile flags: /Ogtpy
?recShutdown@@YAXXZ PROC				; recShutdown

; 615  : {

	push	esi

; 616  : 	ProfilerTerminateSource( "EERec" );

	push	OFFSET ??_C@_05OAHDOEDM@EERec?$AA@
	call	?ProfilerTerminateSource@@YAXPBD@Z	; ProfilerTerminateSource
	add	esp, 4

; 617  : 	ResetBaseBlockEx(0);

	mov	eax, OFFSET _s_vecBaseBlocksEx
	call	?resize@?$vector@PAUBASEBLOCKEX@@V?$allocator@PAUBASEBLOCKEX@@@std@@@std@@QAEXIPAUBASEBLOCKEX@@@Z ; std::vector<BASEBLOCKEX *,std::allocator<BASEBLOCKEX *> >::resize
	mov	ecx, OFFSET _s_vecBaseBlocksEx
	call	?reserve@?$vector@PAUBASEBLOCKEX@@V?$allocator@PAUBASEBLOCKEX@@@std@@@std@@QAEXI@Z ; std::vector<BASEBLOCKEX *,std::allocator<BASEBLOCKEX *> >::reserve

; 618  : 
; 619  : 	SafeSysMunmap( recMem, REC_CACHEMEM );

	mov	eax, DWORD PTR _recMem
	xor	esi, esi
	cmp	eax, esi
	je	SHORT $LN4@recShutdow
	push	ebx
	mov	ebx, DWORD PTR __imp__VirtualFree@12
	push	edi
	push	16384					; 00004000H
	push	16777216				; 01000000H
	push	eax
	mov	edi, eax
	call	ebx
	push	32768					; 00008000H
	push	esi
	push	edi
	call	ebx
	pop	edi
	mov	DWORD PTR _recMem, esi
	pop	ebx
$LN4@recShutdow:

; 620  : 	safe_aligned_free( recLUT );

	mov	eax, DWORD PTR ?recLUT@@3PAIA		; recLUT
	cmp	eax, esi
	je	SHORT $LN3@recShutdow
	push	eax
	call	__aligned_free
	add	esp, 4
	mov	DWORD PTR ?recLUT@@3PAIA, esi		; recLUT
$LN3@recShutdow:

; 621  : 	safe_aligned_free( m_recBlockAlloc );

	mov	eax, DWORD PTR _m_recBlockAlloc
	cmp	eax, esi
	je	SHORT $LN2@recShutdow
	push	eax
	call	__aligned_free
	add	esp, 4
	mov	DWORD PTR _m_recBlockAlloc, esi
$LN2@recShutdow:

; 622  : 	recRAM = recROM = recROM1 = NULL;
; 623  : 	recBlocks = NULL;
; 624  : 	recStack = NULL;
; 625  : 
; 626  : 	safe_free( s_pInstCache );

	mov	eax, DWORD PTR _s_pInstCache
	mov	DWORD PTR _recROM1, esi
	mov	DWORD PTR _recROM, esi
	mov	DWORD PTR _recRAM, esi
	mov	DWORD PTR _recBlocks, esi
	mov	DWORD PTR _recStack, esi
	cmp	eax, esi
	je	SHORT $LN18@recShutdow
	push	eax
	call	_free
	add	esp, 4
	mov	DWORD PTR _s_pInstCache, esi
$LN18@recShutdow:

; 627  : 	s_nInstCacheSize = 0;

	mov	DWORD PTR _s_nInstCacheSize, esi
	pop	esi

; 628  : 
; 629  : 	x86Shutdown();
; 630  : }

	ret	0
?recShutdown@@YAXXZ ENDP				; recShutdown
; Function compile flags: /Ogtpy
__xmm_backup$756152 = -24				; size = 16
__xmm_backup$756107 = -24				; size = 16
$T756172 = -4						; size = 4
$T756127 = -4						; size = 4
$T756098 = -4						; size = 4
?recResetEE@@YAXXZ PROC					; recResetEE

; 547  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 548  : 	DbgCon::Status( "iR5900-32 > Resetting recompiler memory and structures." );
; 549  : 
; 550  : 	s_nNextBlock = 0;
; 551  : 	maxrecmem = 0;
; 552  : 
; 553  : 	memset_8<0xcd, REC_CACHEMEM>(recMem);

	mov	eax, DWORD PTR _recMem
	push	esi
	push	edi
	mov	DWORD PTR _s_nNextBlock, 0
	mov	DWORD PTR ?maxrecmem@@3IA, 0		; maxrecmem
	mov	DWORD PTR $T756098[ebp], eax
	cld
	mov	ecx, 4194304				; 00400000H
	mov	edi, DWORD PTR $T756098[ebp]
	mov	eax, -842150451				; cdcdcdcdH
	rep	 stosd

; 554  : 	memzero_ptr<m_recBlockAllocSize>( m_recBlockAlloc );

	mov	eax, DWORD PTR _m_recBlockAlloc
	mov	DWORD PTR $T756127[ebp], eax
	test	al, 15					; 0000000fH
	je	SHORT $LN38@recResetEE
	movups	XMMWORD PTR __xmm_backup$756107[ebp], xmm0
	mov	ecx, DWORD PTR $T756127[ebp]
	pxor	xmm0, xmm0
	mov	eax, 600576				; 00092a00H
$_loop_6$756110:
	movups	XMMWORD PTR [ecx], xmm0
	movups	XMMWORD PTR [ecx+16], xmm0
	movups	XMMWORD PTR [ecx+32], xmm0
	movups	XMMWORD PTR [ecx+48], xmm0
	movups	XMMWORD PTR [ecx+64], xmm0
	movups	XMMWORD PTR [ecx+80], xmm0
	movups	XMMWORD PTR [ecx+96], xmm0
	movups	XMMWORD PTR [ecx+112], xmm0
	sub	ecx, -128				; ffffff80H
	dec	eax
	jne	SHORT $_loop_6$756110
	movups	xmm0, XMMWORD PTR __xmm_backup$756107[ebp]
	jmp	SHORT $LN31@recResetEE
$LN38@recResetEE:
	movups	XMMWORD PTR __xmm_backup$756107[ebp], xmm0
	mov	ecx, DWORD PTR $T756127[ebp]
	pxor	xmm0, xmm0
	mov	eax, 600576				; 00092a00H
	npad	5
$_loop_8$756115:
	movaps	XMMWORD PTR [ecx], xmm0
	movaps	XMMWORD PTR [ecx+16], xmm0
	movaps	XMMWORD PTR [ecx+32], xmm0
	movaps	XMMWORD PTR [ecx+48], xmm0
	movaps	XMMWORD PTR [ecx+64], xmm0
	movaps	XMMWORD PTR [ecx+80], xmm0
	movaps	XMMWORD PTR [ecx+96], xmm0
	movaps	XMMWORD PTR [ecx+112], xmm0
	sub	ecx, -128				; ffffff80H
	dec	eax
	jne	SHORT $_loop_8$756115
	movups	xmm0, XMMWORD PTR __xmm_backup$756107[ebp]
$LN31@recResetEE:

; 555  : 
; 556  : 	if( s_pInstCache )

	mov	eax, DWORD PTR _s_pInstCache
	test	eax, eax
	je	SHORT $LN10@recResetEE

; 557  : 		memset( s_pInstCache, 0, sizeof(EEINST)*s_nInstCacheSize );

	mov	ecx, DWORD PTR _s_nInstCacheSize
	imul	ecx, 112				; 00000070H
	push	ecx
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$LN10@recResetEE:

; 558  : 
; 559  : 	ResetBaseBlockEx(0);

	mov	eax, OFFSET _s_vecBaseBlocksEx
	call	?resize@?$vector@PAUBASEBLOCKEX@@V?$allocator@PAUBASEBLOCKEX@@@std@@@std@@QAEXIPAUBASEBLOCKEX@@@Z ; std::vector<BASEBLOCKEX *,std::allocator<BASEBLOCKEX *> >::resize
	mov	ecx, OFFSET _s_vecBaseBlocksEx
	call	?reserve@?$vector@PAUBASEBLOCKEX@@V?$allocator@PAUBASEBLOCKEX@@@std@@@std@@QAEXI@Z ; std::vector<BASEBLOCKEX *,std::allocator<BASEBLOCKEX *> >::reserve

; 560  : 	mmap_ResetBlockTracking();

	call	?mmap_ResetBlockTracking@@YAXXZ		; mmap_ResetBlockTracking

; 561  : 
; 562  : #ifdef _MSC_VER
; 563  : 	__asm emms;

	emms

; 564  : #else
; 565  :     __asm__("emms");
; 566  : #endif
; 567  : 
; 568  : 	memzero_ptr<0x010000 * sizeof(uptr)>( recLUT );

	mov	eax, DWORD PTR ?recLUT@@3PAIA		; recLUT
	mov	DWORD PTR $T756172[ebp], eax
	test	al, 15					; 0000000fH
	je	SHORT $LN63@recResetEE
	movups	XMMWORD PTR __xmm_backup$756152[ebp], xmm0
	mov	ecx, DWORD PTR $T756172[ebp]
	pxor	xmm0, xmm0
	mov	eax, 2048				; 00000800H
	npad	2
$_loop_6$756155:
	movups	XMMWORD PTR [ecx], xmm0
	movups	XMMWORD PTR [ecx+16], xmm0
	movups	XMMWORD PTR [ecx+32], xmm0
	movups	XMMWORD PTR [ecx+48], xmm0
	movups	XMMWORD PTR [ecx+64], xmm0
	movups	XMMWORD PTR [ecx+80], xmm0
	movups	XMMWORD PTR [ecx+96], xmm0
	movups	XMMWORD PTR [ecx+112], xmm0
	sub	ecx, -128				; ffffff80H
	dec	eax
	jne	SHORT $_loop_6$756155
	movups	xmm0, XMMWORD PTR __xmm_backup$756152[ebp]
	jmp	SHORT $LN56@recResetEE
$LN63@recResetEE:
	movups	XMMWORD PTR __xmm_backup$756152[ebp], xmm0
	mov	ecx, DWORD PTR $T756172[ebp]
	pxor	xmm0, xmm0
	mov	eax, 2048				; 00000800H
	npad	5
$_loop_8$756160:
	movaps	XMMWORD PTR [ecx], xmm0
	movaps	XMMWORD PTR [ecx+16], xmm0
	movaps	XMMWORD PTR [ecx+32], xmm0
	movaps	XMMWORD PTR [ecx+48], xmm0
	movaps	XMMWORD PTR [ecx+64], xmm0
	movaps	XMMWORD PTR [ecx+80], xmm0
	movaps	XMMWORD PTR [ecx+96], xmm0
	movaps	XMMWORD PTR [ecx+112], xmm0
	sub	ecx, -128				; ffffff80H
	dec	eax
	jne	SHORT $_loop_8$756160
	movups	xmm0, XMMWORD PTR __xmm_backup$756152[ebp]
$LN56@recResetEE:

; 569  : 
; 570  : 	for ( int i = 0x0000; i < 0x0200; i++ )

	mov	edx, DWORD PTR ?recLUT@@3PAIA		; recLUT
	mov	ecx, DWORD PTR _recRAM
	lea	eax, DWORD PTR [edx+49152]
	mov	esi, 512				; 00000200H
$LL9@recResetEE:

; 571  : 	{
; 572  : 		recLUT[ i + 0x0000 ] = (uptr)&recRAM[ i << 14 ];

	mov	DWORD PTR [eax-49152], ecx

; 573  : 		recLUT[ i + 0x2000 ] = (uptr)&recRAM[ i << 14 ];

	mov	DWORD PTR [eax-16384], ecx

; 574  : 		recLUT[ i + 0x3000 ] = (uptr)&recRAM[ i << 14 ];

	mov	DWORD PTR [eax], ecx
	add	eax, 4
	add	ecx, 131072				; 00020000H
	sub	esi, 1
	jne	SHORT $LL9@recResetEE

; 575  : 	}
; 576  : 
; 577  : 	for ( int i = 0x0000; i < 0x0040; i++ )

	mov	ecx, DWORD PTR _recROM
	lea	eax, DWORD PTR [edx+163584]
	mov	esi, 64					; 00000040H
	npad	3
$LL6@recResetEE:

; 578  : 	{
; 579  : 		recLUT[ i + 0x1fc0 ] = (uptr)&recROM[ i << 14 ];

	mov	DWORD PTR [eax-131072], ecx

; 580  : 		recLUT[ i + 0x9fc0 ] = (uptr)&recROM[ i << 14 ];

	mov	DWORD PTR [eax], ecx

; 581  : 		recLUT[ i + 0xbfc0 ] = (uptr)&recROM[ i << 14 ];

	mov	DWORD PTR [eax+32768], ecx
	add	eax, 4
	add	ecx, 131072				; 00020000H
	sub	esi, 1
	jne	SHORT $LL6@recResetEE

; 582  : 	}
; 583  : 
; 584  : 	for ( int i = 0x0000; i < 0x0004; i++ )
; 585  : 	{
; 586  : 		recLUT[ i + 0x1e00 ] = (uptr)&recROM1[ i << 14 ];

	mov	eax, DWORD PTR _recROM1
	lea	ecx, DWORD PTR [eax+131072]
	mov	DWORD PTR [edx+30724], ecx

; 587  : 		recLUT[ i + 0x9e00 ] = (uptr)&recROM1[ i << 14 ];

	mov	DWORD PTR [edx+161796], ecx

; 588  : 		recLUT[ i + 0xbe00 ] = (uptr)&recROM1[ i << 14 ];

	mov	DWORD PTR [edx+194564], ecx
	lea	ecx, DWORD PTR [eax+262144]
	mov	DWORD PTR [edx+30720], eax
	mov	DWORD PTR [edx+161792], eax
	mov	DWORD PTR [edx+194560], eax
	add	eax, 393216				; 00060000H
	mov	DWORD PTR [edx+30728], ecx
	mov	DWORD PTR [edx+161800], ecx
	mov	DWORD PTR [edx+194568], ecx

; 589  : 	}
; 590  : 
; 591  : 	memcpy_fast( recLUT + 0x8000, recLUT, 0x2000 * sizeof(uptr) );

	push	32768					; 00008000H
	lea	ecx, DWORD PTR [edx+131072]
	mov	DWORD PTR [edx+30732], eax
	mov	DWORD PTR [edx+161804], eax
	mov	DWORD PTR [edx+194572], eax
	call	?memcpy_amd_@@YIXPAXPBXI@Z		; memcpy_amd_

; 592  : 	memcpy_fast( recLUT + 0xa000, recLUT, 0x2000 * sizeof(uptr) );

	mov	edx, DWORD PTR ?recLUT@@3PAIA		; recLUT
	push	32768					; 00008000H
	lea	ecx, DWORD PTR [edx+163840]
	call	?memcpy_amd_@@YIXPAXPBXI@Z		; memcpy_amd_

; 593  : 	
; 594  : 	// drk||Raziel says this is useful but I'm not sure why.  Something to do with forward jumps.
; 595  : 	// Anyways, it causes random crashing for some reasom, possibly because of memory
; 596  : 	// corrupition elsewhere in the recs.  I can't reproduce the problem here though,
; 597  : 	// so a fix will have to wait until later. -_- (air)
; 598  : 
; 599  : 	//x86SetPtr(recMem+REC_CACHEMEM);
; 600  : 	//dyna_block_discard_recmem=(u8*)x86Ptr;
; 601  : 	//JMP32( (uptr)&dyna_block_discard - ( (u32)x86Ptr + 5 ));
; 602  : 
; 603  : 	x86SetPtr(recMem);

	mov	eax, DWORD PTR _recMem

; 604  : 
; 605  : 	recPtr = recMem;
; 606  : 	recStackPtr = recStack;

	mov	edx, DWORD PTR _recStack
	mov	DWORD PTR ?x86Ptr@@3PAEA, eax		; x86Ptr
	mov	DWORD PTR _recPtr, eax

; 607  : 	x86FpuState = FPU_STATE;

	xor	eax, eax

; 608  : 	iCWstate = 0;

	xor	ecx, ecx
	mov	WORD PTR ?x86FpuState@@3GA, ax		; x86FpuState
	mov	WORD PTR ?iCWstate@@3GA, cx		; iCWstate

; 609  : 
; 610  : 	branch = 0;
; 611  : 	SetCPUState(Config.sseMXCSR, Config.sseVUMXCSR);

	movzx	ecx, WORD PTR ?Config@@3UPcsxConfig@@A+3632
	mov	DWORD PTR ?branch@@3HA, eax		; branch
	movzx	eax, WORD PTR ?Config@@3UPcsxConfig@@A+3628
	mov	DWORD PTR _recStackPtr, edx
	cmp	DWORD PTR ?cpucaps@@3UCAPABILITIES@@A+92, esi
	jne	SHORT $LN71@recResetEE
	and	eax, -65				; ffffffbfH
	and	ecx, -65				; ffffffbfH
$LN71@recResetEE:
	mov	DWORD PTR ?g_sseMXCSR@@3IA, eax		; g_sseMXCSR
	mov	DWORD PTR ?g_sseVUMXCSR@@3IA, ecx	; g_sseVUMXCSR
	ldmxcsr	DWORD PTR ?g_sseMXCSR@@3IA		; g_sseMXCSR

; 612  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?recResetEE@@YAXXZ ENDP					; recResetEE
_TEXT	ENDS
PUBLIC	?recompileNextInstruction@@YAXH@Z		; recompileNextInstruction
	ALIGN	4

_s_pCode DD	01H DUP (?)
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
_delayslot$ = 8						; size = 4
?recompileNextInstruction@@YAXH@Z PROC			; recompileNextInstruction

; 1313 : 	static u8 s_bFlushReg = 1;
; 1314 : 	int i, count;
; 1315 : 
; 1316 : 	BASEBLOCK* pblock = PC_GETBLOCK(pc);

	movzx	eax, WORD PTR ?pc@@3IA+2
	mov	edx, DWORD PTR ?recLUT@@3PAIA		; recLUT
	mov	eax, DWORD PTR [edx+eax*4]
	push	ebx
	mov	ebx, DWORD PTR _delayslot$[esp]
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR ?pc@@3IA			; pc
	mov	ecx, edi
	and	ecx, 65535				; 0000ffffH

; 1317 : 
; 1318 : 	// need *ppblock != s_pCurBlock because of branches
; 1319 : 	if( pblock->GetFnptr() != 0 && pblock->startpc != s_pCurBlock->startpc ) {

	test	DWORD PTR [eax+ecx*2], 268435455	; 0fffffffH
	lea	esi, DWORD PTR [eax+ecx*2]
	je	$LN28@recompileN
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR _s_pCurBlock
	cmp	eax, DWORD PTR [ecx+4]
	je	$LN28@recompileN

; 1320 : 
; 1321 : 		if( !delayslot && pc == pblock->startpc ) {

	test	ebx, ebx
	jne	SHORT $LN129@recompileN
	cmp	edi, eax
	jne	SHORT $LN29@recompileN

; 1322 : 			// code already in place, so jump to it and exit recomp
; 1323 : 			assert( PC_GETBLOCKEX(pblock)->startpc == pblock->startpc );
; 1324 : 			
; 1325 : 			iFlushCall(FLUSH_EVERYTHING);

	push	4095					; 00000fffH
	call	?iFlushCall@@YAXH@Z			; iFlushCall

; 1326 : 			MOV32ItoM((uptr)&cpuRegs.pc, pc);

	mov	eax, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
	mov	BYTE PTR [eax], 199			; 000000c7H
	mov	BYTE PTR [eax+1], 5
	inc	eax
	mov	DWORD PTR [eax+1], OFFSET ?cpuRegs@@3UcpuRegisters@@A+680
	inc	eax
	add	eax, 4
	mov	DWORD PTR [eax], edi

; 1327 : 				
; 1328 : //			if( pexblock->pOldFnptr ) {
; 1329 : //				// code already in place, so jump to it and exit recomp
; 1330 : //				JMP32((u32)pexblock->pOldFnptr - ((u32)x86Ptr + 5));
; 1331 : //				branch = 3;
; 1332 : //				return;
; 1333 : //			}
; 1334 : 			
; 1335 : 			JMP32((uptr)pblock->GetFnptr() - ((uptr)x86Ptr + 5));

	mov	ecx, DWORD PTR [esi]
	add	eax, 4
	shl	ecx, 4
	sub	ecx, eax
	mov	BYTE PTR [eax], 233			; 000000e9H
	sub	ecx, 5
	inc	eax
	add	esp, 4
	mov	DWORD PTR [eax], ecx
	add	eax, 4
	mov	DWORD PTR ?x86Ptr@@3PAEA, eax		; x86Ptr

; 1336 : 			branch = 3;

	mov	DWORD PTR ?branch@@3HA, 3		; branch

; 1490 : 
; 1491 : //	_freeXMMregs();
; 1492 : //	_freeMMXregs();
; 1493 : //	_flushCachedRegs();
; 1494 : //	g_cpuHasConstReg = 1;
; 1495 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	0
$LN129@recompileN:

; 1337 : 			return;
; 1338 : 		}
; 1339 : 		else {
; 1340 : 
; 1341 : 			if( !(delayslot && pblock->startpc == pc) ) {

	cmp	eax, edi
	je	SHORT $LN28@recompileN
$LN29@recompileN:

; 1342 : 				u8* oldX86 = x86Ptr;

	mov	edi, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr

; 1343 : 				//__Log("clear block %x\n", pblock->startpc);
; 1344 : 				recClearMem(pblock);

	push	esi
	call	?recClearMem@@YAXPAUBASEBLOCK@@@Z	; recClearMem
	add	esp, 4

; 1345 : 				x86Ptr = oldX86;

	mov	DWORD PTR ?x86Ptr@@3PAEA, edi		; x86Ptr

; 1346 : 				if( delayslot )

	test	ebx, ebx
	je	SHORT $LN133@recompileN

; 1347 : 					Console::Notice("delay slot %x", params pc);

	mov	edx, DWORD PTR ?pc@@3IA			; pc
	push	edx
	push	0
	push	OFFSET ??_C@_0O@HOCNDIGO@delay?5slot?5?$CFx?$AA@
	call	?Notice@Console@@YA_NPBDPBU_VARG_PARAM@@ZZ ; Console::Notice
	mov	edi, DWORD PTR ?pc@@3IA			; pc
	add	esp, 12					; 0000000cH
$LN28@recompileN:

; 1348 : 			}
; 1349 : 		}
; 1350 : 	}
; 1351 : 
; 1352 : 	if( delayslot )

	test	ebx, ebx
	je	SHORT $LN27@recompileN

; 1353 : 		pblock->uType = BLOCKTYPE_DELAYSLOT;

	mov	eax, DWORD PTR [esi]
	and	eax, 268435455				; 0fffffffH
	or	eax, 268435456				; 10000000H
	mov	DWORD PTR [esi], eax
	jmp	SHORT $LN27@recompileN
$LN133@recompileN:
	mov	edi, DWORD PTR ?pc@@3IA			; pc
$LN27@recompileN:

; 1354 : 		
; 1355 : 	s_pCode = (int *)PSM( pc );

	mov	eax, edi
	and	eax, 536870911				; 1fffffffH
	cmp	eax, 536870912				; 20000000H
	jae	SHORT $LN59@recompileN
	mov	ecx, eax
	shr	ecx, 12					; 0000000cH
	mov	ecx, DWORD PTR ?pmap@vtlb_private@@3PAHA[ecx*4]
	test	ecx, ecx
	jl	SHORT $LN59@recompileN
	and	eax, 4095				; 00000fffH
	add	eax, ecx
	jmp	SHORT $LN58@recompileN
$LN59@recompileN:
	xor	eax, eax
$LN58@recompileN:

; 1356 : 	assert(s_pCode);
; 1357 : 
; 1358 : #ifdef _DEBUG
; 1359 : 	MOV32ItoR(EAX, pc);
; 1360 : #endif
; 1361 : 
; 1362 : 	cpuRegs.code = *(int *)s_pCode;
; 1363 : 	pc += 4;
; 1364 : 	
; 1365 : //#ifdef _DEBUG
; 1366 : //	CMP32ItoM((u32)s_pCode, cpuRegs.code);
; 1367 : //	j8Ptr[0] = JE8(0);
; 1368 : //	MOV32ItoR(EAX, pc);
; 1369 : //	CALLFunc((uptr)checkcodefn);
; 1370 : //	x86SetJ8( j8Ptr[ 0 ] );
; 1371 : //
; 1372 : //	if( !delayslot ) {
; 1373 : //		CMP32ItoM((u32)&cpuRegs.pc, s_pCurBlockEx->startpc);
; 1374 : //		j8Ptr[0] = JB8(0);
; 1375 : //		CMP32ItoM((u32)&cpuRegs.pc, pc);
; 1376 : //		j8Ptr[1] = JA8(0);
; 1377 : //		j8Ptr[2] = JMP8(0);
; 1378 : //		x86SetJ8( j8Ptr[ 0 ] );
; 1379 : //		x86SetJ8( j8Ptr[ 1 ] );
; 1380 : //		PUSH32I(s_pCurBlockEx->startpc);
; 1381 : //		ADD32ItoR(ESP, 4);
; 1382 : //		x86SetJ8( j8Ptr[ 2 ] );	
; 1383 : //	}
; 1384 : //#endif
; 1385 : 
; 1386 : 	g_pCurInstInfo++;

	mov	ebp, DWORD PTR ?g_pCurInstInfo@@3PAUEEINST@@A ; g_pCurInstInfo
	mov	edx, DWORD PTR [eax]
	mov	ebx, DWORD PTR _s_nEndBlock
	add	edi, 4
	add	ebp, 112				; 00000070H
	mov	DWORD PTR _s_pCode, eax
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+684, edx
	mov	DWORD PTR ?pc@@3IA, edi			; pc
	mov	DWORD PTR ?g_pCurInstInfo@@3PAUEEINST@@A, ebp ; g_pCurInstInfo
	mov	esi, OFFSET ?mmxregs@@3PAU_mmxregs@@A+4
	npad	3
$LL26@recompileN:

; 1387 : 
; 1388 : 	// reorder register priorities
; 1389 : //	for(i = 0; i < X86REGS; ++i) {
; 1390 : //		if( x86regs[i].inuse ) {
; 1391 : //			if( count > 0 ) mmxregs[i].counter = 1000-count;
; 1392 : //			else mmxregs[i].counter = 0;
; 1393 : //		}
; 1394 : //	}
; 1395 : 
; 1396 : 	for(i = 0; i < MMXREGS; ++i) {
; 1397 : 		if( mmxregs[i].inuse ) {

	cmp	BYTE PTR [esi-4], 0
	je	SHORT $LN25@recompileN

; 1398 : 			assert( MMX_ISGPR(mmxregs[i].reg) );
; 1399 : 			count = _recIsRegWritten(g_pCurInstInfo, (s_nEndBlock-pc)/4 + 1, XMMTYPE_GPRREG, mmxregs[i].reg-MMX_GPR);

	mov	eax, ebx
	sub	eax, edi
	shr	eax, 2
	inc	eax
	push	5
	push	eax
	mov	al, BYTE PTR [esi-3]
	mov	edx, ebp
	call	?_recIsRegWritten@@YAIPAUEEINST@@HEE@Z	; _recIsRegWritten
	add	esp, 8

; 1400 : 			if( count > 0 ) mmxregs[i].counter = 1000-count;

	test	eax, eax
	jle	SHORT $LN22@recompileN
	mov	ecx, 1000				; 000003e8H
	sub	ecx, eax
	mov	WORD PTR [esi], cx
	jmp	SHORT $LN25@recompileN
$LN22@recompileN:

; 1401 : 			else mmxregs[i].counter = 0;

	xor	edx, edx
	mov	WORD PTR [esi], dx
$LN25@recompileN:
	add	esi, 6
	cmp	esi, OFFSET ?mmxregs@@3PAU_mmxregs@@A+52
	jl	SHORT $LL26@recompileN

; 1402 : 		}
; 1403 : 	}
; 1404 : 
; 1405 : 	for(i = 0; i < XMMREGS; ++i) {

	mov	esi, OFFSET ?xmmregs@@3PAU_xmmregs@@A+1
$LL20@recompileN:

; 1406 : 		if( xmmregs[i].inuse ) {

	cmp	BYTE PTR [esi-1], 0
	je	SHORT $LN19@recompileN

; 1407 : 			count = _recIsRegWritten(g_pCurInstInfo, (s_nEndBlock-pc)/4 + 1, xmmregs[i].type, xmmregs[i].reg);

	movzx	eax, BYTE PTR [esi+1]
	mov	ecx, ebx
	sub	ecx, edi
	shr	ecx, 2
	push	eax
	mov	al, BYTE PTR [esi]
	inc	ecx
	push	ecx
	mov	edx, ebp
	call	?_recIsRegWritten@@YAIPAUEEINST@@HEE@Z	; _recIsRegWritten
	add	esp, 8

; 1408 : 			if( count > 0 ) xmmregs[i].counter = 1000-count;

	test	eax, eax
	jle	SHORT $LN16@recompileN
	mov	edx, 1000				; 000003e8H
	sub	edx, eax
	mov	WORD PTR [esi+5], dx
	jmp	SHORT $LN19@recompileN
$LN16@recompileN:

; 1409 : 			else xmmregs[i].counter = 0;

	xor	eax, eax
	mov	WORD PTR [esi+5], ax
$LN19@recompileN:
	add	esi, 8
	cmp	esi, OFFSET ?xmmregs@@3PAU_xmmregs@@A+65
	jl	SHORT $LL20@recompileN

; 1410 : 		}
; 1411 : 	}
; 1412 : 
; 1413 : 	const OPCODE& opcode = GetCurrentInstruction();

	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+684
	shr	eax, 26					; 0000001aH
	lea	esi, DWORD PTR [eax+eax*8]
	mov	eax, DWORD PTR ?tbl_Standard@OpcodeTables@R5900@@3QBUOPCODE@2@B[esi*4+20]
	lea	esi, DWORD PTR ?tbl_Standard@OpcodeTables@R5900@@3QBUOPCODE@2@B[esi*4]
	test	eax, eax
	je	SHORT $LN63@recompileN
$LL64@recompileN:
	call	eax
	mov	esi, eax
	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	jne	SHORT $LL64@recompileN
$LN63@recompileN:

; 1414 : 
; 1415 : 	// peephole optimizations
; 1416 : #ifdef PCSX2_VM_COISSUE
; 1417 : 	if( g_pCurInstInfo->info & EEINSTINFO_COREC ) {
; 1418 : 
; 1419 : 		if( g_pCurInstInfo->numpeeps > 1 ) {
; 1420 : 			switch(_Opcode_) {
; 1421 : 				case 30: recLQ_coX(g_pCurInstInfo->numpeeps); break;
; 1422 : 				case 31: recSQ_coX(g_pCurInstInfo->numpeeps); break;
; 1423 : 				case 49: recLWC1_coX(g_pCurInstInfo->numpeeps); break;
; 1424 : 				case 57: recSWC1_coX(g_pCurInstInfo->numpeeps); break;
; 1425 : 				case 55: recLD_coX(g_pCurInstInfo->numpeeps); break;
; 1426 : 				case 63: recSD_coX(g_pCurInstInfo->numpeeps, 1); break; //not sure if should be set to 1 or 0; looks like "1" handles alignment, so i'm going with that for now
; 1427 : 
; 1428 : 				jNO_DEFAULT
; 1429 : 			}
; 1430 : 			pc += g_pCurInstInfo->numpeeps*4;
; 1431 : 			s_nBlockCycles += (g_pCurInstInfo->numpeeps+1) * opcode.cycles;
; 1432 : 			g_pCurInstInfo += g_pCurInstInfo->numpeeps;
; 1433 : 		}
; 1434 : 		else {
; 1435 : 			recBSC_co[_Opcode_]();
; 1436 : 			pc += 4;
; 1437 : 			g_pCurInstInfo++;
; 1438 : 			s_nBlockCycles += opcode.cycles*2;
; 1439 : 		}
; 1440 : 	}
; 1441 : 	else
; 1442 : #endif
; 1443 : 	{
; 1444 : 	 	//assert( !(g_pCurInstInfo->info & EEINSTINFO_NOREC) );
; 1445 : 
; 1446 : 		// if this instruction is a jump or a branch, exit right away
; 1447 : 		if( delayslot ) {

	mov	edi, DWORD PTR _delayslot$[esp+12]
	test	edi, edi
	je	$LN12@recompileN

; 1448 : 			switch(_Opcode_) {

	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+684
	mov	ecx, eax
	shr	ecx, 26					; 0000001aH
	dec	ecx
	cmp	ecx, 22					; 00000016H
	ja	$LN12@recompileN
	movzx	edx, BYTE PTR $LN131@recompileN[ecx]
	jmp	DWORD PTR $LN137@recompileN[edx*4]
$LN11@recompileN:

; 1449 : 				case 1:
; 1450 : 					switch(_Rt_) {

	movzx	ecx, WORD PTR ?cpuRegs@@3UcpuRegisters@@A+686
	and	ecx, 31					; 0000001fH
	cmp	ecx, 19					; 00000013H
	ja	$LN12@recompileN
	movzx	ecx, BYTE PTR $LN132@recompileN[ecx]
	jmp	DWORD PTR $LN138@recompileN[ecx*4]
$LN8@recompileN:

; 1451 : 						case 0: case 1: case 2: case 3: case 0x10: case 0x11: case 0x12: case 0x13:
; 1452 : 							Console::Notice("branch %x in delay slot!", params cpuRegs.code);

	push	eax
	push	0
	push	OFFSET ??_C@_0BJ@BNOPKFMB@branch?5?$CFx?5in?5delay?5slot?$CB?$AA@
	call	?Notice@Console@@YA_NPBDPBU_VARG_PARAM@@ZZ ; Console::Notice
	add	esp, 12					; 0000000cH

; 1453 : 							_clearNeededX86regs();

	call	?_clearNeededX86regs@@YAXXZ		; _clearNeededX86regs

; 1454 : 							_clearNeededMMXregs();

	call	?_clearNeededMMXregs@@YAXXZ		; _clearNeededMMXregs

; 1490 : 
; 1491 : //	_freeXMMregs();
; 1492 : //	_freeMMXregs();
; 1493 : //	_flushCachedRegs();
; 1494 : //	g_cpuHasConstReg = 1;
; 1495 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1455 : 							_clearNeededXMMregs();

	jmp	?_clearNeededXMMregs@@YAXXZ		; _clearNeededXMMregs
$LN7@recompileN:

; 1456 : 							return;
; 1457 : 					}
; 1458 : 					break;
; 1459 : 
; 1460 : 				case 2: case 3: case 4: case 5: case 6: case 7: case 0x14: case 0x15: case 0x16: case 0x17:
; 1461 : 					Console::Notice("branch %x in delay slot!", params cpuRegs.code);

	push	eax
	push	0
	push	OFFSET ??_C@_0BJ@BNOPKFMB@branch?5?$CFx?5in?5delay?5slot?$CB?$AA@
	call	?Notice@Console@@YA_NPBDPBU_VARG_PARAM@@ZZ ; Console::Notice
	add	esp, 12					; 0000000cH
	mov	eax, OFFSET ?x86regs@@3PAU_x86regs@@A+2

; 1462 : 					_clearNeededX86regs();

$LL71@recompileN:
	cmp	BYTE PTR [eax+1], 0
	je	SHORT $LN67@recompileN
	cmp	BYTE PTR [eax-2], 0
	je	SHORT $LN67@recompileN
	mov	cl, BYTE PTR [eax]
	test	cl, 2
	je	SHORT $LN67@recompileN
	or	cl, 1
	mov	BYTE PTR [eax], cl
$LN67@recompileN:
	mov	BYTE PTR [eax+1], 0
	add	eax, 12					; 0000000cH
	cmp	eax, OFFSET ?x86regs@@3PAU_x86regs@@A+98
	jl	SHORT $LL71@recompileN

; 1463 : 					_clearNeededMMXregs();

	mov	eax, OFFSET ?mmxregs@@3PAU_mmxregs@@A+2
	npad	1
$LL78@recompileN:
	cmp	BYTE PTR [eax+1], 0
	je	SHORT $LN77@recompileN
	cmp	BYTE PTR [eax-2], 0
	je	SHORT $LN74@recompileN
	mov	cl, BYTE PTR [eax]
	test	cl, 2
	je	SHORT $LN74@recompileN
	or	cl, 1
	mov	BYTE PTR [eax], cl
$LN74@recompileN:
	mov	BYTE PTR [eax+1], 0
$LN77@recompileN:
	add	eax, 6
	cmp	eax, OFFSET ?mmxregs@@3PAU_mmxregs@@A+50
	jl	SHORT $LL78@recompileN

; 1464 : 					_clearNeededXMMregs();

	mov	eax, OFFSET ?xmmregs@@3PAU_xmmregs@@A+3
	npad	5
$LL86@recompileN:
	cmp	BYTE PTR [eax+1], 0
	je	SHORT $LN85@recompileN
	cmp	BYTE PTR [eax-3], 0
	je	SHORT $LN82@recompileN
	mov	cl, BYTE PTR [eax]
	test	cl, 2
	je	SHORT $LN82@recompileN
	or	cl, 1
	mov	BYTE PTR [eax], cl
$LN82@recompileN:
	mov	BYTE PTR [eax+1], 0
$LN85@recompileN:
	add	eax, 8
	cmp	eax, OFFSET ?xmmregs@@3PAU_xmmregs@@A+67
	jl	SHORT $LL86@recompileN

; 1490 : 
; 1491 : //	_freeXMMregs();
; 1492 : //	_freeMMXregs();
; 1493 : //	_flushCachedRegs();
; 1494 : //	g_cpuHasConstReg = 1;
; 1495 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	0
$LN12@recompileN:

; 1465 : 					return;
; 1466 : 			}
; 1467 : 		}
; 1468 : 		opcode.recompile();

	mov	edx, DWORD PTR [esi+28]
	call	edx

; 1469 : 		s_nBlockCycles += opcode.cycles;

	movzx	eax, BYTE PTR [esi+16]
	add	DWORD PTR ?s_nBlockCycles@@3IA, eax	; s_nBlockCycles

; 1470 : 	}
; 1471 : 
; 1472 : 	if( !delayslot ) {

	test	edi, edi
	jne	SHORT $LN6@recompileN

; 1473 : 		if( s_bFlushReg ) {

	cmp	BYTE PTR ?s_bFlushReg@?1??recompileNextInstruction@@YAXH@Z@4EA, 0
	je	SHORT $LN6@recompileN

; 1474 : 			//if( !_flushUnusedConstReg() ) {
; 1475 : 				int flushed = 0;

	xor	esi, esi

; 1476 : 				if( _getNumMMXwrite() > 3 ) flushed = _flushMMXunused();

	call	?_getNumMMXwrite@@YAHXZ			; _getNumMMXwrite
	cmp	eax, 3
	jle	SHORT $LN130@recompileN
	call	?_flushMMXunused@@YAHXZ			; _flushMMXunused
	mov	esi, eax

; 1477 : 				if( !flushed && _getNumXMMwrite() > 2 ) _flushXMMunused();

	test	esi, esi
	jne	SHORT $LN136@recompileN
$LN130@recompileN:
	call	?_getNumXMMwrite@@YAHXZ			; _getNumXMMwrite
	cmp	eax, 2
	jle	SHORT $LN3@recompileN
	call	?_flushXMMunused@@YAHXZ			; _flushXMMunused
$LN3@recompileN:

; 1478 : 				s_bFlushReg = !flushed;

	test	esi, esi
$LN136@recompileN:
	sete	cl
	mov	BYTE PTR ?s_bFlushReg@?1??recompileNextInstruction@@YAXH@Z@4EA, cl
	jmp	SHORT $LN1@recompileN
$LN6@recompileN:

; 1479 : //			}
; 1480 : //			else s_bFlushReg = 0;
; 1481 : 		}
; 1482 : 		else s_bFlushReg = 1;
; 1483 : 	}
; 1484 : 	else s_bFlushReg = 1;

	mov	BYTE PTR ?s_bFlushReg@?1??recompileNextInstruction@@YAXH@Z@4EA, 1
$LN1@recompileN:

; 1485 : 
; 1486 : 	//CHECK_XMMCHANGED();
; 1487 : 	_clearNeededX86regs();

	mov	eax, OFFSET ?x86regs@@3PAU_x86regs@@A+2
$LL93@recompileN:
	cmp	BYTE PTR [eax+1], 0
	je	SHORT $LN89@recompileN
	cmp	BYTE PTR [eax-2], 0
	je	SHORT $LN89@recompileN
	mov	cl, BYTE PTR [eax]
	test	cl, 2
	je	SHORT $LN89@recompileN
	or	cl, 1
	mov	BYTE PTR [eax], cl
$LN89@recompileN:
	mov	BYTE PTR [eax+1], 0
	add	eax, 12					; 0000000cH
	cmp	eax, OFFSET ?x86regs@@3PAU_x86regs@@A+98
	jl	SHORT $LL93@recompileN

; 1488 : 	_clearNeededMMXregs();

	mov	eax, OFFSET ?mmxregs@@3PAU_mmxregs@@A+2
$LL100@recompileN:
	cmp	BYTE PTR [eax+1], 0
	je	SHORT $LN99@recompileN
	cmp	BYTE PTR [eax-2], 0
	je	SHORT $LN96@recompileN
	mov	cl, BYTE PTR [eax]
	test	cl, 2
	je	SHORT $LN96@recompileN
	or	cl, 1
	mov	BYTE PTR [eax], cl
$LN96@recompileN:
	mov	BYTE PTR [eax+1], 0
$LN99@recompileN:
	add	eax, 6
	cmp	eax, OFFSET ?mmxregs@@3PAU_mmxregs@@A+50
	jl	SHORT $LL100@recompileN

; 1489 : 	_clearNeededXMMregs();

	mov	eax, OFFSET ?xmmregs@@3PAU_xmmregs@@A+3
	npad	4
$LL108@recompileN:
	cmp	BYTE PTR [eax+1], 0
	je	SHORT $LN107@recompileN
	cmp	BYTE PTR [eax-3], 0
	je	SHORT $LN104@recompileN
	mov	cl, BYTE PTR [eax]
	test	cl, 2
	je	SHORT $LN104@recompileN
	or	cl, 1
	mov	BYTE PTR [eax], cl
$LN104@recompileN:
	mov	BYTE PTR [eax+1], 0
$LN107@recompileN:
	add	eax, 8
	cmp	eax, OFFSET ?xmmregs@@3PAU_xmmregs@@A+67
	jl	SHORT $LL108@recompileN

; 1490 : 
; 1491 : //	_freeXMMregs();
; 1492 : //	_freeMMXregs();
; 1493 : //	_flushCachedRegs();
; 1494 : //	g_cpuHasConstReg = 1;
; 1495 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	0
	npad	1
$LN137@recompileN:
	DD	$LN11@recompileN
	DD	$LN7@recompileN
	DD	$LN12@recompileN
$LN131@recompileN:
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	1
	DB	1
	DB	1
	DB	1
	npad	1
$LN138@recompileN:
	DD	$LN8@recompileN
	DD	$LN12@recompileN
$LN132@recompileN:
	DB	0
	DB	0
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	0
	DB	0
	DB	0
?recompileNextInstruction@@YAXH@Z ENDP			; recompileNextInstruction
_TEXT	ENDS
PUBLIC	?SetBranchReg@@YAXI@Z				; SetBranchReg
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?SetBranchReg@@YAXI@Z PROC				; SetBranchReg
; _reg$ = eax

; 1021 : {

	push	esi
	mov	esi, eax

; 1022 : 	branch = 1;

	mov	DWORD PTR ?branch@@3HA, 1		; branch

; 1023 : 
; 1024 : 	if( reg != 0xffffffff ) {

	cmp	esi, -1
	je	SHORT $LN40@SetBranchR

; 1025 : //		if( GPR_IS_CONST1(reg) )
; 1026 : //			MOV32ItoM( (uptr)&cpuRegs.pc, g_cpuConstRegs[reg].UL[0] );
; 1027 : //		else {
; 1028 : //			int mmreg;
; 1029 : //			
; 1030 : //			if( (mmreg = _checkXMMreg(XMMTYPE_GPRREG, reg, MODE_READ)) >= 0 ) {
; 1031 : //				SSE_MOVSS_XMM_to_M32((u32)&cpuRegs.pc, mmreg);
; 1032 : //			}
; 1033 : //			else if( (mmreg = _checkMMXreg(MMX_GPR+reg, MODE_READ)) >= 0 ) {
; 1034 : //				MOVDMMXtoM((u32)&cpuRegs.pc, mmreg);
; 1035 : //				SetMMXstate();
; 1036 : //			}
; 1037 : //			else {
; 1038 : //				MOV32MtoR(EAX, (int)&cpuRegs.GPR.r[ reg ].UL[ 0 ] );
; 1039 : //				MOV32RtoM((u32)&cpuRegs.pc, EAX);
; 1040 : //			}
; 1041 : //		}
; 1042 : 		_allocX86reg(ESI, X86TYPE_PCWRITEBACK, 0, MODE_WRITE);

	push	2
	push	0
	push	10					; 0000000aH
	push	6
	call	?_allocX86reg@@YAHHHHH@Z		; _allocX86reg

; 1043 : 		_eeMoveGPRtoR(ESI, reg);

	push	6
	mov	eax, esi
	call	?_eeMoveGPRtoR@@YAXHH@Z			; _eeMoveGPRtoR

; 1044 : 
; 1045 : 		recompileNextInstruction(1);

	push	1
	call	?recompileNextInstruction@@YAXH@Z	; recompileNextInstruction

; 1046 : 
; 1047 : 		if( x86regs[ESI].inuse ) {
; 1048 : 			assert( x86regs[ESI].type == X86TYPE_PCWRITEBACK );
; 1049 : 			MOV32RtoM((int)&cpuRegs.pc, ESI);

	mov	eax, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
	add	esp, 24					; 00000018H
	cmp	BYTE PTR ?x86regs@@3PAU_x86regs@@A+72, 0
	je	SHORT $LN2@SetBranchR
	mov	BYTE PTR [eax], 137			; 00000089H
	inc	eax
	mov	BYTE PTR [eax], 53			; 00000035H
	inc	eax
	mov	DWORD PTR [eax], OFFSET ?cpuRegs@@3UcpuRegisters@@A+680

; 1050 : 			x86regs[ESI].inuse = 0;

	mov	BYTE PTR ?x86regs@@3PAU_x86regs@@A+72, 0

; 1051 : 		}
; 1052 : 		else {

	jmp	SHORT $LN147@SetBranchR
$LN2@SetBranchR:

; 1053 : 			MOV32MtoR(EAX, (u32)&g_recWriteback);

	mov	BYTE PTR [eax], 139			; 0000008bH
	mov	BYTE PTR [eax+1], 5
	inc	eax
	inc	eax
	mov	DWORD PTR [eax], OFFSET ?g_recWriteback@@3IA ; g_recWriteback
	add	eax, 4

; 1054 : 			MOV32RtoM((int)&cpuRegs.pc, EAX);

	mov	BYTE PTR [eax], 137			; 00000089H
	inc	eax
	mov	BYTE PTR [eax], 5
	inc	eax
	mov	DWORD PTR [eax], OFFSET ?cpuRegs@@3UcpuRegisters@@A+680
$LN147@SetBranchR:
	add	eax, 4
	mov	DWORD PTR ?x86Ptr@@3PAEA, eax		; x86Ptr
$LN40@SetBranchR:

; 1055 : 		}
; 1056 : 	}
; 1057 : 
; 1058 : //	CMP32ItoM((u32)&cpuRegs.pc, 0);
; 1059 : //	j8Ptr[5] = JNE8(0);
; 1060 : //	CALLFunc((uptr)tempfn);
; 1061 : //	x86SetJ8( j8Ptr[5] );
; 1062 : 
; 1063 : 	iFlushCall(FLUSH_EVERYTHING);

	push	4095					; 00000fffH
	call	?iFlushCall@@YAXH@Z			; iFlushCall
	add	esp, 4

; 1064 : 
; 1065 : 	iBranchTest(0xffffffff);

	cmp	DWORD PTR ?bExecBIOS@@3IA, 0		; bExecBIOS
	je	SHORT $LN46@SetBranchR
	call	?CheckForBIOSEnd@@YAXXZ			; CheckForBIOSEnd
$LN46@SetBranchR:
	mov	esi, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
	mov	BYTE PTR [esi], 139			; 0000008bH
	inc	esi
	mov	BYTE PTR [esi], 5
	inc	esi
	mov	DWORD PTR [esi], OFFSET ?cpuRegs@@3UcpuRegisters@@A+960
	add	esi, 4
	call	?eeScaleBlockCycles@@YAIXZ		; eeScaleBlockCycles
	cmp	eax, 128				; 00000080H
	jae	SHORT $LN72@SetBranchR
	mov	BYTE PTR [esi], 131			; 00000083H
	inc	esi
	mov	BYTE PTR [esi], 192			; 000000c0H
	inc	esi
	mov	BYTE PTR [esi], al
	inc	esi
	jmp	SHORT $LN97@SetBranchR
$LN72@SetBranchR:
	mov	BYTE PTR [esi], 5
	inc	esi
	mov	DWORD PTR [esi], eax
	add	esi, 4
$LN97@SetBranchR:
	mov	BYTE PTR [esi], 137			; 00000089H
	mov	BYTE PTR [esi+1], 5
	inc	esi
	mov	DWORD PTR [esi+1], OFFSET ?cpuRegs@@3UcpuRegisters@@A+960
	inc	esi
	mov	BYTE PTR [esi+4], 43			; 0000002bH
	add	esi, 4
	mov	BYTE PTR [esi+1], 5
	inc	esi
	mov	DWORD PTR [esi+1], OFFSET ?g_nextBranchCycle@@3IA ; g_nextBranchCycle
	inc	esi
	add	esi, 4
	mov	BYTE PTR [esi], 15			; 0000000fH
	mov	eax, OFFSET ?DispatcherReg@@YAXXZ	; DispatcherReg
	sub	eax, esi
	inc	esi
	mov	BYTE PTR [esi], 136			; 00000088H
	inc	esi
	sub	eax, 6
	mov	DWORD PTR [esi], eax
	add	esi, 4
	mov	eax, 50163				; 0000c3f3H
	mov	WORD PTR [esi], ax
	add	esi, 2
	mov	DWORD PTR ?x86Ptr@@3PAEA, esi		; x86Ptr
	pop	esi

; 1066 : }

	ret	0
?SetBranchReg@@YAXI@Z ENDP				; SetBranchReg
; Function compile flags: /Ogtpy
_inpage_ptr$ = -56					; size = 4
_usecop2$ = -56						; size = 4
_i$ = -56						; size = 4
tv2359 = -52						; size = 4
_inpage_sz$ = -52					; size = 4
$T800812 = -48						; size = 4
$T800811 = -48						; size = 4
_pgsz$89622 = -48					; size = 4
_pcur$89591 = -48					; size = 4
_willbranch3$ = -44					; size = 4
tv1415 = -40						; size = 4
tv1418 = -36						; size = 4
tv1605 = -32						; size = 4
_ptr$ = -28						; size = 4
_tmp$800830 = -24					; size = 4
_tmp$800835 = -20					; size = 4
_tmp$800855 = -16					; size = 4
_tmp$800860 = -12					; size = 4
_bsc$89600 = -8						; size = 8
_startpc$ = 8						; size = 4
?recRecompile@@YAXI@Z PROC				; recRecompile

; 1534 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 60					; 0000003cH
	mov	ecx, DWORD PTR _startpc$[ebp]
	mov	eax, ecx
	shr	eax, 16					; 00000010H
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv1415[esp+60], eax
	mov	eax, ecx
	and	eax, 65535				; 0000ffffH
	push	ebx
	add	eax, eax
	push	esi
	and	ecx, 4095				; 00000fffH
	push	edi
	mov	DWORD PTR tv1418[esp+72], eax

; 1737 : 			cpuRegs.code = *(int *)PSM(i-4);

	mov	DWORD PTR tv1605[esp+72], ecx
$LL690@recRecompi:
	mov	eax, DWORD PTR _recPtr
	sub	eax, DWORD PTR _recMem
	mov	edi, DWORD PTR __imp__WriteConsoleA@20
	xor	ebx, ebx
	mov	DWORD PTR _willbranch3$[esp+72], ebx
	cmp	eax, 16515072				; 00fc0000H
	jb	SHORT $LN89@recRecompi
	mov	eax, DWORD PTR _hConsole
	cmp	eax, ebx
	je	SHORT $LN95@recRecompi
	push	ebx
	lea	ecx, DWORD PTR _tmp$800830[esp+76]
	push	ecx
	push	24					; 00000018H
	push	OFFSET ??_C@_0BJ@KGMIHJML@EE?5Recompiler?5data?5reset?$AA@
	push	eax
	call	edi
	mov	eax, DWORD PTR _hConsole
$LN95@recRecompi:
	mov	ecx, DWORD PTR ?emuLog@@3PAU_iobuf@@A	; emuLog
	cmp	ecx, ebx
	je	SHORT $LN94@recRecompi
	push	ecx
	push	OFFSET ??_C@_0BJ@KGMIHJML@EE?5Recompiler?5data?5reset?$AA@
	call	_fputs
	mov	eax, DWORD PTR _hConsole
	mov	ecx, DWORD PTR ?emuLog@@3PAU_iobuf@@A	; emuLog
	add	esp, 8
$LN94@recRecompi:

; 1535 : 	u32 i = 0;
; 1536 : 	u32 branchTo;
; 1537 : 	u32 willbranch3 = 0;
; 1538 : 	u32* ptr;
; 1539 : 	u32 usecop2;
; 1540 : 
; 1541 : #ifdef _DEBUG
; 1542 :     //dumplog |= 4;
; 1543 :     if( dumplog & 4 )
; 1544 : 		iDumpRegisters(startpc, 0);	
; 1545 : #endif
; 1546 : 
; 1547 : 	assert( startpc );
; 1548 : 
; 1549 : 	// if recPtr reached the mem limit reset whole mem
; 1550 : 	if ( ( (uptr)recPtr - (uptr)recMem ) >= REC_CACHEMEM-0x40000 || dumplog == 0xffffffff) {
; 1551 : 		DevCon::WriteLn( "EE Recompiler data reset" );

	cmp	eax, ebx
	je	SHORT $LN99@recRecompi
	push	ebx
	lea	edx, DWORD PTR _tmp$800835[esp+76]
	push	edx
	push	2
	push	OFFSET ??_C@_02PCIJFNDE@?$AN?6?$AA@
	push	eax
	call	edi
	mov	ecx, DWORD PTR ?emuLog@@3PAU_iobuf@@A	; emuLog
$LN99@recRecompi:
	cmp	ecx, ebx
	je	SHORT $LN98@recRecompi
	push	ecx
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	_fputs
	mov	eax, DWORD PTR ?emuLog@@3PAU_iobuf@@A	; emuLog
	push	eax
	call	_fflush
	add	esp, 12					; 0000000cH
$LN98@recRecompi:

; 1552 : 		recResetEE();

	call	?recResetEE@@YAXXZ			; recResetEE
$LN89@recRecompi:

; 1553 : 	}
; 1554 : 	if ( ( (uptr)recStackPtr - (uptr)recStack ) >= RECSTACK_SIZE-0x100 ) {

	mov	ecx, DWORD PTR _recStackPtr
	sub	ecx, DWORD PTR _recStack
	cmp	ecx, 65280				; 0000ff00H
	jb	SHORT $LN87@recRecompi

; 1555 : 		DevCon::WriteLn("EE recompiler stack reset");

	mov	eax, DWORD PTR _hConsole
	cmp	eax, ebx
	je	SHORT $LN105@recRecompi
	push	ebx
	lea	edx, DWORD PTR _tmp$800855[esp+76]
	push	edx
	push	25					; 00000019H
	push	OFFSET ??_C@_0BK@FEKONKNL@EE?5recompiler?5stack?5reset?$AA@
	push	eax
	call	edi
	mov	eax, DWORD PTR _hConsole
$LN105@recRecompi:
	mov	ecx, DWORD PTR ?emuLog@@3PAU_iobuf@@A	; emuLog
	cmp	ecx, ebx
	je	SHORT $LN104@recRecompi
	push	ecx
	push	OFFSET ??_C@_0BK@FEKONKNL@EE?5recompiler?5stack?5reset?$AA@
	call	_fputs
	mov	eax, DWORD PTR _hConsole
	mov	ecx, DWORD PTR ?emuLog@@3PAU_iobuf@@A	; emuLog
	add	esp, 8
$LN104@recRecompi:
	cmp	eax, ebx
	je	SHORT $LN109@recRecompi
	push	ebx
	lea	ecx, DWORD PTR _tmp$800860[esp+76]
	push	ecx
	push	2
	push	OFFSET ??_C@_02PCIJFNDE@?$AN?6?$AA@
	push	eax
	call	edi
	mov	ecx, DWORD PTR ?emuLog@@3PAU_iobuf@@A	; emuLog
$LN109@recRecompi:
	cmp	ecx, ebx
	je	SHORT $LN108@recRecompi
	push	ecx
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	_fputs
	mov	edx, DWORD PTR ?emuLog@@3PAU_iobuf@@A	; emuLog
	push	edx
	call	_fflush
	add	esp, 12					; 0000000cH
$LN108@recRecompi:

; 1556 : 		recResetEE();

	call	?recResetEE@@YAXXZ			; recResetEE
$LN87@recRecompi:

; 1557 : 	}
; 1558 : 
; 1559 : 	s_pCurBlock = PC_GETBLOCK(startpc);

	mov	eax, DWORD PTR tv1415[esp+72]
	mov	ecx, DWORD PTR ?recLUT@@3PAIA		; recLUT
	mov	ecx, DWORD PTR [eax+ecx]
	add	ecx, DWORD PTR tv1418[esp+72]

; 1560 : 	
; 1561 : 	if( s_pCurBlock->GetFnptr() ) {

	test	DWORD PTR [ecx], 268435455		; 0fffffffH
	mov	DWORD PTR _s_pCurBlock, ecx
	je	SHORT $LN86@recRecompi

; 1562 : 		// clear if already taken
; 1563 : 		assert( s_pCurBlock->startpc < startpc );
; 1564 : 		recClearMem(s_pCurBlock);	

	push	ecx
	call	?recClearMem@@YAXPAUBASEBLOCK@@@Z	; recClearMem
	mov	ecx, DWORD PTR _s_pCurBlock
	add	esp, 4
$LN86@recRecompi:

; 1565 : 	}
; 1566 : 
; 1567 : 	if( s_pCurBlock->startpc == startpc ) {

	mov	eax, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR _startpc$[ebp]
	cmp	eax, esi
	jne	SHORT $LN85@recRecompi

; 1568 : 		s_pCurBlockEx = PC_GETBLOCKEX(s_pCurBlock);

	push	eax
	push	OFFSET _s_vecBaseBlocksEx
	call	?Get@BASEBLOCKS@@QAEHI@Z		; BASEBLOCKS::Get
	mov	edx, DWORD PTR _s_vecBaseBlocksEx+16
	sub	edx, DWORD PTR _s_vecBaseBlocksEx+12
	mov	edi, eax
	sar	edx, 2
	cmp	edi, edx
	jb	SHORT $LN120@recRecompi
	call	__invalid_parameter_noinfo
$LN120@recRecompi:
	mov	eax, DWORD PTR _s_vecBaseBlocksEx+12
	mov	ecx, DWORD PTR [eax+edi*4]
	mov	DWORD PTR _s_pCurBlockEx, ecx

; 1569 : 		assert( s_pCurBlockEx->startpc == startpc );
; 1570 : 	}
; 1571 : 	else {

	mov	ecx, DWORD PTR _s_pCurBlock
	jmp	$LN84@recRecompi
$LN85@recRecompi:

; 1572 : 		s_pCurBlockEx = NULL;
; 1573 : 		for(i = 0; i < EE_NUMBLOCKS; ++i) {

	mov	edi, DWORD PTR _recBlocks
	mov	DWORD PTR _s_pCurBlockEx, ebx
	mov	ebx, DWORD PTR _s_nNextBlock
	xor	edx, edx
	npad	6
$LL83@recRecompi:

; 1574 : 			if( recBlocks[(i+s_nNextBlock)%EE_NUMBLOCKS].size == 0 ) {

	lea	eax, DWORD PTR [ebx+edx]
	and	eax, 32767				; 00007fffH
	lea	eax, DWORD PTR [eax+eax*2]
	cmp	WORD PTR [edi+eax*8], 0
	je	SHORT $LN715@recRecompi
	inc	edx
	cmp	edx, 32768				; 00008000H
	jb	SHORT $LL83@recRecompi

; 2044 : 
; 2045 : 		if( pcurblock->startpc == startpc ) {

	jmp	SHORT $LN742@recRecompi
$LN715@recRecompi:

; 1575 : 				s_pCurBlockEx = recBlocks+(i+s_nNextBlock)%EE_NUMBLOCKS;

	add	edx, ebx
	mov	eax, edx
	and	eax, 32767				; 00007fffH
	lea	eax, DWORD PTR [eax+eax*2]

; 1576 : 				s_nNextBlock = (i+s_nNextBlock+1)%EE_NUMBLOCKS;

	inc	edx
	lea	eax, DWORD PTR [edi+eax*8]
	and	edx, 32767				; 00007fffH
	mov	DWORD PTR _s_pCurBlockEx, eax
	mov	DWORD PTR _s_nNextBlock, edx

; 1577 : 				break;
; 1578 : 			}
; 1579 : 		}
; 1580 : 
; 1581 : 		if( s_pCurBlockEx == NULL ) {

	test	eax, eax
	jne	SHORT $LN79@recRecompi
$LN742@recRecompi:

; 1582 : 			//SysPrintf("ee reset (blocks)\n");
; 1583 : 			recResetEE();

	call	?recResetEE@@YAXXZ			; recResetEE

; 1584 : 			s_nNextBlock = 0;
; 1585 : 			s_pCurBlockEx = recBlocks;

	mov	eax, DWORD PTR _recBlocks
	mov	ecx, DWORD PTR _s_pCurBlock
	mov	DWORD PTR _s_nNextBlock, 0
	mov	DWORD PTR _s_pCurBlockEx, eax
$LN79@recRecompi:

; 1586 : 		}
; 1587 : 
; 1588 : 		s_pCurBlockEx->startpc = startpc;

	mov	DWORD PTR [eax+4], esi
	xor	ebx, ebx
$LN84@recRecompi:

; 1589 : 	}
; 1590 : 
; 1591 : 	x86SetPtr( recPtr );
; 1592 : 	x86Align(16);

	mov	eax, DWORD PTR _recPtr

; 1593 : 	recPtr = x86Ptr;
; 1594 : 	s_pCurBlock->SetFnptr( (uptr)x86Ptr );

	mov	edx, DWORD PTR [ecx]
	add	eax, 15					; 0000000fH
	and	eax, -16				; fffffff0H
	mov	DWORD PTR ?x86Ptr@@3PAEA, eax		; x86Ptr
	mov	DWORD PTR _recPtr, eax
	shr	eax, 4
	and	edx, -268435456				; f0000000H
	or	edx, eax

; 1595 : 	s_pCurBlock->startpc = startpc;
; 1596 : 
; 1597 : 	branch = 0;
; 1598 : 
; 1599 : 	// reset recomp state variables
; 1600 : 	s_nBlockCycles = 0;
; 1601 : 	pc = startpc;
; 1602 : 	x86FpuState = FPU_STATE;

	xor	eax, eax
	mov	WORD PTR ?x86FpuState@@3GA, ax		; x86FpuState

; 1603 : 	iCWstate = 0;
; 1604 : 	s_saveConstGPRreg = 0;
; 1605 : 	g_cpuHasConstReg = g_cpuFlushedConstReg = 1;

	mov	eax, 1
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR ?g_cpuFlushedConstReg@@3IA, eax ; g_cpuFlushedConstReg
	mov	DWORD PTR ?g_cpuHasConstReg@@3IA, eax	; g_cpuHasConstReg

; 1606 : 	g_cpuPrevRegHasLive1 = g_cpuRegHasLive1 = 0xffffffff;

	or	eax, -1
	xor	ecx, ecx
	mov	DWORD PTR ?branch@@3HA, ebx		; branch
	mov	DWORD PTR ?s_nBlockCycles@@3IA, ebx	; s_nBlockCycles
	mov	DWORD PTR ?pc@@3IA, esi			; pc
	mov	WORD PTR ?iCWstate@@3GA, cx		; iCWstate
	mov	DWORD PTR ?s_saveConstGPRreg@@3IA, ebx	; s_saveConstGPRreg
	mov	DWORD PTR ?g_cpuRegHasLive1@@3IA, eax	; g_cpuRegHasLive1
	mov	DWORD PTR ?g_cpuPrevRegHasLive1@@3IA, eax ; g_cpuPrevRegHasLive1

; 1607 : 	g_cpuPrevRegHasSignExt = g_cpuRegHasSignExt = 0;

	mov	DWORD PTR ?g_cpuRegHasSignExt@@3IA, ebx	; g_cpuRegHasSignExt
	mov	DWORD PTR ?g_cpuPrevRegHasSignExt@@3IA, ebx ; g_cpuPrevRegHasSignExt

; 1608 : 	assert( g_cpuConstRegs[0].UD[0] == 0 );
; 1609 : 
; 1610 : 	_initX86regs();

	cld
	mov	ecx, 24					; 00000018H
	mov	edi, OFFSET ?x86regs@@3PAU_x86regs@@A	; x86regs
	xor	eax, eax
	rep	 stosd
	xor	edx, edx
	mov	WORD PTR ?g_x86AllocCounter@@3GA, dx	; g_x86AllocCounter
	mov	DWORD PTR ?g_x86checknext@@3HA, ebx	; g_x86checknext

; 1611 : 	_initXMMregs();

	cld
	mov	ecx, 16					; 00000010H
	mov	edi, OFFSET ?xmmregs@@3PAU_xmmregs@@A	; xmmregs
	xor	eax, eax
	rep	 stosd
	xor	eax, eax
	mov	WORD PTR ?g_xmmAllocCounter@@3GA, ax	; g_xmmAllocCounter
	mov	DWORD PTR _s_xmmchecknext, ebx

; 1612 : 	_initMMXregs();

	cld
	mov	ecx, 12					; 0000000cH
	mov	edi, OFFSET ?mmxregs@@3PAU_mmxregs@@A	; mmxregs
	xor	eax, eax
	rep	 stosd

; 1613 : 
; 1614 : #ifdef _DEBUG
; 1615 : 	// for debugging purposes
; 1616 : 	MOV32ItoM((uptr)&g_lastpc, pc);
; 1617 : 	CALLFunc((uptr)printfn);
; 1618 : 
; 1619 : //	CMP32MtoR(EBP, (uptr)&s_uSaveEBP);
; 1620 : //	j8Ptr[0] = JE8(0);
; 1621 : //	CALLFunc((uptr)badespfn);
; 1622 : //	x86SetJ8(j8Ptr[0]);
; 1623 : #endif
; 1624 : 
; 1625 : 	// go until the next branch
; 1626 : 	i = startpc;
; 1627 : 	s_nEndBlock = 0xffffffff;
; 1628 : 	s_nHasDelay = 0;

	mov	edi, DWORD PTR ?recLUT@@3PAIA		; recLUT
	xor	ecx, ecx
	mov	WORD PTR ?g_mmxAllocCounter@@3GA, cx	; g_mmxAllocCounter
	mov	DWORD PTR _s_mmxchecknext, ebx
	mov	edx, esi
	mov	DWORD PTR _s_nHasDelay, ebx
$LL78@recRecompi:

; 1629 : 	
; 1630 : 	while(1) {
; 1631 : 		BASEBLOCK* pblock = PC_GETBLOCK(i);

	mov	eax, edx
	shr	eax, 16					; 00000010H
	mov	eax, DWORD PTR [edi+eax*4]
	mov	ecx, edx
	and	ecx, 65535				; 0000ffffH

; 1632 : 		if( pblock->GetFnptr() != 0 && pblock->startpc != s_pCurBlock->startpc ) {

	test	DWORD PTR [eax+ecx*2], 268435455	; 0fffffffH
	lea	eax, DWORD PTR [eax+ecx*2]
	je	SHORT $LN75@recRecompi
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _s_pCurBlock
	cmp	eax, DWORD PTR [ecx+4]
	je	SHORT $LN75@recRecompi

; 1633 : 
; 1634 : 			if( i == pblock->startpc ) {

	cmp	edx, eax
	je	$LN716@recRecompi
$LN75@recRecompi:

; 1638 : 				break;
; 1639 : 			}
; 1640 : 		}
; 1641 : 		//HUH ? PSM ? whut ? THIS IS VIRTUAL ACCESS GOD DAMMIT
; 1642 : 		cpuRegs.code = *(int *)PSM(i);

	mov	eax, edx
	and	eax, 536870911				; 1fffffffH
	cmp	eax, 536870912				; 20000000H
	jae	SHORT $LN204@recRecompi
	mov	ecx, eax
	shr	ecx, 12					; 0000000cH
	mov	ecx, DWORD PTR ?pmap@vtlb_private@@3PAHA[ecx*4]
	cmp	ecx, ebx
	jl	SHORT $LN204@recRecompi
	and	eax, 4095				; 00000fffH
	add	eax, ecx
	jmp	SHORT $LN203@recRecompi
$LN204@recRecompi:
	xor	eax, eax
$LN203@recRecompi:
	mov	eax, DWORD PTR [eax]

; 1643 : 
; 1644 : 		switch(cpuRegs.code >> 26) {

	mov	ecx, eax
	shr	ecx, 26					; 0000001aH
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+684, eax
	cmp	ecx, 23					; 00000017H
	ja	$LN46@recRecompi
	movzx	ecx, BYTE PTR $LN743@recRecompi[ecx]
	jmp	DWORD PTR $LN781@recRecompi[ecx*4]
$LN72@recRecompi:

; 1645 : 			case 0: // special
; 1646 : 
; 1647 : 				if( _Funct_ == 8 || _Funct_ == 9 ) { // JR, JALR

	and	eax, 63					; 0000003fH
	cmp	eax, 8
	je	SHORT $LN717@recRecompi
	cmp	eax, 9
	jne	$LN46@recRecompi
$LN717@recRecompi:

; 1648 : 					s_nEndBlock = i + 8;
; 1649 : 					s_nHasDelay = 1;

	mov	DWORD PTR _s_nHasDelay, 1
	jmp	$LN43@recRecompi
$LN68@recRecompi:

; 1650 : 					goto StartRecomp;
; 1651 : 				}
; 1652 : 
; 1653 : 				break;
; 1654 : 			case 1: // regimm
; 1655 : 				
; 1656 : 				if( _Rt_ < 4 || (_Rt_ >= 16 && _Rt_ < 20) ) {

	mov	ecx, eax
	shr	ecx, 16					; 00000010H
	and	ecx, 31					; 0000001fH
	cmp	ecx, 4
	jb	SHORT $LN718@recRecompi
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN46@recRecompi
	cmp	ecx, 20					; 00000014H
	jae	SHORT $LN46@recRecompi
$LN718@recRecompi:

; 1657 : 					// branches
; 1658 : 					if( _Rt_ == 2 || _Rt_ == 3 || _Rt_ == 18 || _Rt_ == 19 ) s_nHasDelay = 1;

	mov	ecx, eax
	shr	ecx, 16					; 00000010H
	and	ecx, 31					; 0000001fH
	cmp	ecx, 2
	je	SHORT $LN64@recRecompi
	cmp	ecx, 3
	je	SHORT $LN64@recRecompi
	cmp	ecx, 18					; 00000012H
	je	SHORT $LN64@recRecompi

; 1659 : 					else s_nHasDelay = 2;

	mov	DWORD PTR _s_nHasDelay, 2
	cmp	ecx, 19					; 00000013H
	jne	SHORT $LN63@recRecompi
$LN64@recRecompi:

; 1657 : 					// branches
; 1658 : 					if( _Rt_ == 2 || _Rt_ == 3 || _Rt_ == 18 || _Rt_ == 19 ) s_nHasDelay = 1;

	mov	DWORD PTR _s_nHasDelay, 1

; 1718 : 
; 1719 : StartRecomp:

	jmp	SHORT $LN63@recRecompi
$LN51@recRecompi:

; 1681 : 				else s_nHasDelay = 2;
; 1682 : 
; 1683 : 				branchTo = _Imm_ * 4 + i + 4;
; 1684 : 				if( branchTo > startpc && branchTo < i ) s_nEndBlock = branchTo;
; 1685 : 				else  s_nEndBlock = i+8;
; 1686 : 				
; 1687 : 				goto StartRecomp;
; 1688 : 
; 1689 : 			case 16: // cp0
; 1690 : 				if( _Rs_ == 16 ) {

	mov	ecx, eax
	and	ecx, 65011712				; 03e00000H
	cmp	ecx, 33554432				; 02000000H
	jne	SHORT $LN49@recRecompi

; 1691 : 					if( _Funct_ == 24 ) { // eret

	mov	ecx, eax
	and	ecx, 63					; 0000003fH
	cmp	cl, 24					; 00000018H
	je	SHORT $LN719@recRecompi
$LN49@recRecompi:

; 1693 : 						goto StartRecomp;
; 1694 : 					}
; 1695 : 				}
; 1696 : 				// Fall through!
; 1697 : 				// COP0's branch opcodes line up with COP1 and COP2's
; 1698 : 
; 1699 : 			case 17: // cp1
; 1700 : 			case 18: // cp2
; 1701 : 				if( _Rs_ == 8 ) {

	mov	ecx, eax
	and	ecx, 65011712				; 03e00000H
	cmp	ecx, 16777216				; 01000000H
	je	SHORT $LN720@recRecompi
$LN46@recRecompi:

; 1710 : 					
; 1711 : 					goto StartRecomp;
; 1712 : 				}
; 1713 : 				break;
; 1714 : 		}
; 1715 : 
; 1716 : 		i += 4;

	add	edx, 4

; 1717 : 	}

	jmp	$LL78@recRecompi
$LN716@recRecompi:

; 1635 : 				// branch = 3
; 1636 : 				willbranch3 = 1;

	mov	DWORD PTR _willbranch3$[esp+72], 1

; 1637 : 				s_nEndBlock = i;

	mov	ebx, edx

; 1718 : 
; 1719 : StartRecomp:

	jmp	SHORT $LN772@recRecompi
$LN57@recRecompi:

; 1660 : 
; 1661 : 					branchTo = _Imm_ * 4 + i + 4;
; 1662 : 					if( branchTo > startpc && branchTo < i ) s_nEndBlock = branchTo;
; 1663 : 					else  s_nEndBlock = i+8;
; 1664 : 
; 1665 : 					goto StartRecomp;
; 1666 : 				}
; 1667 : 
; 1668 : 				break;
; 1669 : 
; 1670 : 			case 2: // J
; 1671 : 			case 3: // JAL
; 1672 : 				s_nHasDelay = 1;
; 1673 : 				s_nEndBlock = i + 8;
; 1674 : 				goto StartRecomp;
; 1675 : 
; 1676 : 			// branches
; 1677 : 			case 4: case 5: case 6: case 7: 
; 1678 : 			case 20: case 21: case 22: case 23:
; 1679 : 
; 1680 : 				if( (cpuRegs.code >> 26) >= 20 ) s_nHasDelay = 1;

	mov	ecx, eax
	and	ecx, -67108864				; fc000000H
	cmp	ecx, 1342177280				; 50000000H

; 1718 : 
; 1719 : StartRecomp:

	jmp	SHORT $LN780@recRecompi
$LN719@recRecompi:

; 1692 : 						s_nEndBlock = i+4;

	lea	ebx, DWORD PTR [edx+4]

; 1718 : 
; 1719 : StartRecomp:

	jmp	SHORT $LN772@recRecompi
$LN720@recRecompi:

; 1702 : 					// BC1F, BC1T, BC1FL, BC1TL
; 1703 : 					// BC2F, BC2T, BC2FL, BC2TL
; 1704 : 					if( _Rt_ >= 2 ) s_nHasDelay = 1;

	mov	ecx, eax
	and	ecx, 2031616				; 001f0000H
	cmp	ecx, 131072				; 00020000H
$LN780@recRecompi:
	sbb	ecx, ecx
	neg	ecx
	inc	ecx
	mov	DWORD PTR _s_nHasDelay, ecx
$LN63@recRecompi:

; 1705 : 					else s_nHasDelay = 2;
; 1706 : 
; 1707 : 					branchTo = _Imm_ * 4 + i + 4;

	cwde
	lea	ebx, DWORD PTR [edx+eax*4+4]

; 1708 : 					if( branchTo > startpc && branchTo < i ) s_nEndBlock = branchTo;

	cmp	ebx, esi
	jbe	SHORT $LN43@recRecompi
	cmp	ebx, edx
	jb	SHORT $LN772@recRecompi
$LN43@recRecompi:

; 1709 : 					else  s_nEndBlock = i+8;

	lea	ebx, DWORD PTR [edx+8]
$LN772@recRecompi:

; 1720 : 
; 1721 : 	// rec info //
; 1722 : 	{
; 1723 : 		EEINST* pcur;
; 1724 : 
; 1725 : 		if( s_nInstCacheSize < (s_nEndBlock-startpc)/4+1 ) {

	mov	ecx, ebx
	sub	ecx, esi
	shr	ecx, 2
	inc	ecx
	mov	DWORD PTR _s_nEndBlock, ebx
$StartRecomp$89558:
	cmp	DWORD PTR _s_nInstCacheSize, ecx
	jae	SHORT $LN40@recRecompi

; 1726 : 			free(s_pInstCache);

	mov	edx, DWORD PTR _s_pInstCache
	push	edx
	call	_free

; 1727 : 			s_nInstCacheSize = (s_nEndBlock-startpc)/4+10;

	mov	eax, DWORD PTR _s_nEndBlock
	sub	eax, esi
	shr	eax, 2
	add	eax, 10					; 0000000aH
	mov	DWORD PTR _s_nInstCacheSize, eax

; 1728 : 			s_pInstCache = (EEINST*)malloc(sizeof(EEINST)*s_nInstCacheSize);

	imul	eax, 112				; 00000070H
	add	esp, 4
	push	eax
	call	_malloc
	mov	ebx, DWORD PTR _s_nEndBlock
	add	esp, 4
	mov	DWORD PTR _s_pInstCache, eax
$LN40@recRecompi:

; 1729 : 			assert( s_pInstCache != NULL );
; 1730 : 		}
; 1731 : 
; 1732 : 		pcur = s_pInstCache + (s_nEndBlock-startpc)/4;

	sub	ebx, esi
	shr	ebx, 2
	imul	ebx, 112				; 00000070H
	add	ebx, DWORD PTR _s_pInstCache
	mov	DWORD PTR _pcur$89591[esp+72], ebx

; 1733 : 		_recClearInst(pcur);

	cld
	mov	ecx, 28					; 0000001cH
	mov	edi, DWORD PTR _pcur$89591[esp+72]
	xor	eax, eax
	rep	 stosd

; 1734 : 		pcur->info = 0;
; 1735 : 
; 1736 : 		for(i = s_nEndBlock; i > startpc; i -= 4 ) {

	mov	edx, DWORD PTR _s_nEndBlock
	mov	eax, 117901063				; 07070707H
	mov	DWORD PTR [ebx], eax
	mov	DWORD PTR [ebx+4], eax
	mov	DWORD PTR [ebx+8], eax
	mov	DWORD PTR [ebx+12], eax
	mov	DWORD PTR [ebx+16], eax
	mov	DWORD PTR [ebx+20], eax
	mov	DWORD PTR [ebx+24], eax
	mov	DWORD PTR [ebx+28], eax
	mov	WORD PTR [ebx+32], ax
	mov	eax, 16843009				; 01010101H
	mov	DWORD PTR [ebx+34], eax
	mov	DWORD PTR [ebx+38], eax
	mov	DWORD PTR [ebx+42], eax
	mov	DWORD PTR [ebx+46], eax
	mov	DWORD PTR [ebx+50], eax
	mov	DWORD PTR [ebx+54], eax
	mov	DWORD PTR [ebx+58], eax
	mov	DWORD PTR [ebx+62], eax
	mov	BYTE PTR [ebx+66], al
	mov	BYTE PTR [ebx+67], 0
	mov	DWORD PTR _i$[esp+72], edx
	cmp	edx, esi
	jbe	$LN37@recRecompi
	lea	eax, DWORD PTR [ebx-112]
	mov	DWORD PTR tv2359[esp+72], eax
$LL39@recRecompi:

; 1737 : 			cpuRegs.code = *(int *)PSM(i-4);

	mov	eax, DWORD PTR _i$[esp+72]
	add	eax, -4					; fffffffcH
	and	eax, 536870911				; 1fffffffH
	cmp	eax, 536870912				; 20000000H
	jae	SHORT $LN264@recRecompi
	mov	ecx, eax
	shr	ecx, 12					; 0000000cH
	mov	ecx, DWORD PTR ?pmap@vtlb_private@@3PAHA[ecx*4]
	test	ecx, ecx
	jl	SHORT $LN264@recRecompi
	and	eax, 4095				; 00000fffH
	add	eax, ecx
	jmp	SHORT $LN263@recRecompi
$LN264@recRecompi:
	xor	eax, eax
$LN263@recRecompi:
	mov	edx, DWORD PTR [eax]

; 1738 : 			pcur[-1] = pcur[0];

	mov	eax, DWORD PTR tv2359[esp+72]
	mov	edi, eax

; 1739 : 
; 1740 : 			BSCPropagate bsc( pcur[-1], pcur[0] );

	mov	DWORD PTR _bsc$89600[esp+72], eax
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+684, edx
	mov	ecx, 28					; 0000001cH
	mov	esi, ebx

; 1741 : 			bsc.rprop();

	lea	eax, DWORD PTR _bsc$89600[esp+72]
	rep movsd
	mov	DWORD PTR _bsc$89600[esp+76], ebx
	call	?rprop@BSCPropagate@@QAEXXZ		; BSCPropagate::rprop
	mov	eax, DWORD PTR _i$[esp+72]

; 1742 : 			pcur--;

	sub	DWORD PTR tv2359[esp+72], 112		; 00000070H
	sub	eax, 4
	sub	ebx, 112				; 00000070H
	mov	DWORD PTR _i$[esp+72], eax
	cmp	eax, DWORD PTR _startpc$[ebp]
	ja	SHORT $LL39@recRecompi

; 1734 : 		pcur->info = 0;
; 1735 : 
; 1736 : 		for(i = s_nEndBlock; i > startpc; i -= 4 ) {

	mov	edx, DWORD PTR _s_nEndBlock
$LN37@recRecompi:

; 1743 : 		}
; 1744 : 	}
; 1745 : 
; 1746 : 	// analyze instructions //
; 1747 : 	{
; 1748 : 		usecop2 = 0;
; 1749 : 		g_pCurInstInfo = s_pInstCache;
; 1750 : 
; 1751 : 		for(i = startpc; i < s_nEndBlock; i += 4) {

	mov	edi, DWORD PTR _startpc$[ebp]
	mov	esi, DWORD PTR _s_pInstCache
	mov	DWORD PTR _usecop2$[esp+72], 0
	mov	DWORD PTR ?g_pCurInstInfo@@3PAUEEINST@@A, esi ; g_pCurInstInfo
	mov	ebx, edi
	cmp	edi, edx
	jae	$LN29@recRecompi
	npad	8
$LL36@recRecompi:

; 1752 : 			g_pCurInstInfo++;
; 1753 : 			cpuRegs.code = *(u32*)PSM(i);

	mov	eax, ebx
	add	esi, 112				; 00000070H
	and	eax, 536870911				; 1fffffffH
	mov	DWORD PTR ?g_pCurInstInfo@@3PAUEEINST@@A, esi ; g_pCurInstInfo
	cmp	eax, 536870912				; 20000000H
	jae	SHORT $LN271@recRecompi
	mov	ecx, eax
	shr	ecx, 12					; 0000000cH
	mov	ecx, DWORD PTR ?pmap@vtlb_private@@3PAHA[ecx*4]
	test	ecx, ecx
	jl	SHORT $LN271@recRecompi
	and	eax, 4095				; 00000fffH
	add	eax, ecx
	jmp	SHORT $LN270@recRecompi
$LN271@recRecompi:
	xor	eax, eax
$LN270@recRecompi:
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+684, eax

; 1754 : 
; 1755 : 			// cop2 //
; 1756 : 			if( g_pCurInstInfo->info & EEINSTINFO_COP2 ) {

	test	BYTE PTR [esi+67], 2
	je	SHORT $LN33@recRecompi

; 1757 : 
; 1758 : 				if( !usecop2 ) {

	cmp	DWORD PTR _usecop2$[esp+72], 0
	jne	SHORT $LN32@recRecompi

; 1759 : 					// init
; 1760 : 					vucycle = 0;

	mov	DWORD PTR ?vucycle@@3HA, 0		; vucycle

; 1761 : 					usecop2 = 1;

	mov	DWORD PTR _usecop2$[esp+72], 1
$LN32@recRecompi:

; 1762 : 				}
; 1763 : 				
; 1764 : 				VU0.code = cpuRegs.code;

	mov	DWORD PTR ?VU0@@3UVURegs@@A+1108, eax

; 1765 : 				_vuRegsCOP22( &VU0, &g_pCurInstInfo->vuregs );

	lea	ecx, DWORD PTR [esi+88]
	shr	eax, 21					; 00000015H
	and	eax, 31					; 0000001fH
	mov	edx, DWORD PTR ?_vuRegsCOP2t@@3PAP6AXPAUVURegs@@PAU_VURegsNum@@@ZA[eax*4]
	push	ecx
	push	OFFSET ?VU0@@3UVURegs@@A		; VU0
	call	edx

; 1766 : 				continue;

	mov	edx, DWORD PTR _s_nEndBlock
	mov	esi, DWORD PTR ?g_pCurInstInfo@@3PAUEEINST@@A ; g_pCurInstInfo
	add	esp, 8
	jmp	SHORT $LN35@recRecompi
$LN33@recRecompi:

; 1767 : 			}
; 1768 : 
; 1769 : 			// fixme - This should be based on the cycle count of the current EE
; 1770 : 			// instruction being analyzed.
; 1771 : 			if( usecop2 ) vucycle++;

	cmp	DWORD PTR _usecop2$[esp+72], 0
	je	SHORT $LN35@recRecompi
	inc	DWORD PTR ?vucycle@@3HA			; vucycle
$LN35@recRecompi:

; 1743 : 		}
; 1744 : 	}
; 1745 : 
; 1746 : 	// analyze instructions //
; 1747 : 	{
; 1748 : 		usecop2 = 0;
; 1749 : 		g_pCurInstInfo = s_pInstCache;
; 1750 : 
; 1751 : 		for(i = startpc; i < s_nEndBlock; i += 4) {

	add	ebx, 4
	cmp	ebx, edx
	jb	$LL36@recRecompi

; 1772 : 
; 1773 : 			// peephole optimizations //
; 1774 : #ifdef PCSX2_VM_COISSUE
; 1775 : 			if( i < s_nEndBlock-4 && recompileCodeSafe(i) ) {
; 1776 : 				u32 curcode = cpuRegs.code;
; 1777 : 				u32 nextcode = *(u32*)PSM(i+4);
; 1778 : 				if( _eeIsLoadStoreCoIssue(curcode, nextcode) && recBSC_co[curcode>>26] != NULL ) {
; 1779 : 
; 1780 : 					// rs has to be the same, and cannot be just written
; 1781 : 					if( ((curcode >> 21) & 0x1F) == ((nextcode >> 21) & 0x1F) && !_eeLoadWritesRs(curcode) ) {
; 1782 : 
; 1783 : 						if( _eeIsLoadStoreCoX(curcode) && ((nextcode>>16)&0x1f) != ((curcode>>21)&0x1f) ) {
; 1784 : 							// see how many stores there are
; 1785 : 							u32 j;
; 1786 : 							// use xmmregs since only supporting lwc1,lq,swc1,sq
; 1787 : 							for(j = i+8; j < s_nEndBlock && j < i+4*XMMREGS; j += 4 ) {
; 1788 : 								u32 nncode = *(u32*)PSM(j);
; 1789 : 								if( (nncode>>26) != (curcode>>26) || ((curcode>>21)&0x1f) != ((nncode>>21)&0x1f) ||
; 1790 : 									_eeLoadWritesRs(nncode))
; 1791 : 									break;
; 1792 : 							}
; 1793 : 
; 1794 : 							if( j > i+8 ) {
; 1795 : 								u32 num = (j-i)>>2; // number of stores that can coissue
; 1796 : 								assert( num <= XMMREGS );
; 1797 : 
; 1798 : 								g_pCurInstInfo[0].numpeeps = num-1;
; 1799 : 								g_pCurInstInfo[0].info |= EEINSTINFO_COREC;
; 1800 : 
; 1801 : 								while(i < j-4) {
; 1802 : 									g_pCurInstInfo++;
; 1803 : 									g_pCurInstInfo[0].info |= EEINSTINFO_NOREC;
; 1804 : 									i += 4;	
; 1805 : 								}
; 1806 : 
; 1807 : 								continue;
; 1808 : 							}
; 1809 : 
; 1810 : 							// fall through
; 1811 : 						}
; 1812 : 
; 1813 : 						// unaligned loadstores
; 1814 : 
; 1815 : 						// if LWL, check if LWR and that offsets are +3 away
; 1816 : 						switch(curcode >> 26) {
; 1817 : 							case 0x22: // LWL
; 1818 : 								if( (nextcode>>26) != 0x26 || ((s16)nextcode)+3 != (s16)curcode )
; 1819 : 									continue;
; 1820 : 								break;
; 1821 : 							case 0x26: // LWR
; 1822 : 								if( (nextcode>>26) != 0x22 || ((s16)nextcode) != (s16)curcode+3 )
; 1823 : 									continue;
; 1824 : 								break;
; 1825 : 
; 1826 : 							case 0x2a: // SWL
; 1827 : 								if( (nextcode>>26) != 0x2e || ((s16)nextcode)+3 != (s16)curcode )
; 1828 : 									continue;
; 1829 : 								break;
; 1830 : 							case 0x2e: // SWR
; 1831 : 								if( (nextcode>>26) != 0x2a || ((s16)nextcode) != (s16)curcode+3 )
; 1832 : 									continue;
; 1833 : 								break;
; 1834 : 
; 1835 : 							case 0x1a: // LDL
; 1836 : 								if( (nextcode>>26) != 0x1b || ((s16)nextcode)+7 != (s16)curcode )
; 1837 : 									continue;
; 1838 : 								break;
; 1839 : 							case 0x1b: // LWR
; 1840 : 								if( (nextcode>>26) != 0x1aa || ((s16)nextcode) != (s16)curcode+7 )
; 1841 : 									continue;
; 1842 : 								break;
; 1843 : 
; 1844 : 							case 0x2c: // SWL
; 1845 : 								if( (nextcode>>26) != 0x2d || ((s16)nextcode)+7 != (s16)curcode )
; 1846 : 									continue;
; 1847 : 								break;
; 1848 : 							case 0x2d: // SWR
; 1849 : 								if( (nextcode>>26) != 0x2c || ((s16)nextcode) != (s16)curcode+7 )
; 1850 : 									continue;
; 1851 : 								break;
; 1852 : 						}
; 1853 : 						
; 1854 : 						// good enough
; 1855 : 						g_pCurInstInfo[0].info |= EEINSTINFO_COREC;
; 1856 : 						g_pCurInstInfo[0].numpeeps = 1;
; 1857 : 						g_pCurInstInfo[1].info |= EEINSTINFO_NOREC;
; 1858 : 						g_pCurInstInfo++;
; 1859 : 						i += 4;
; 1860 : 						continue;
; 1861 : 					}
; 1862 : 				}
; 1863 : 			}
; 1864 : #endif // end peephole
; 1865 : 		}
; 1866 : 		// This *is* important because g_pCurInstInfo is checked a bit later on and
; 1867 : 		// if it's not equal to s_pInstCache it handles recompilation differently.
; 1868 : 		// ... but the empty if() conditional inside the for loop is still amusing. >_<
; 1869 : 		if( usecop2 ) {

	cmp	DWORD PTR _usecop2$[esp+72], 0
	je	SHORT $LN29@recRecompi

; 1870 : 			// add necessary mac writebacks
; 1871 : 			g_pCurInstInfo = s_pInstCache;

	mov	ecx, DWORD PTR _s_pInstCache

; 1872 : 
; 1873 : 			for(i = startpc; i < s_nEndBlock-4; i += 4) {

	lea	eax, DWORD PTR [edx-4]
	mov	DWORD PTR ?g_pCurInstInfo@@3PAUEEINST@@A, ecx ; g_pCurInstInfo
	cmp	edi, eax
	jae	SHORT $LN29@recRecompi
	sub	eax, edi
	dec	eax
	shr	eax, 2
	inc	eax
	imul	eax, 112				; 00000070H
	add	eax, ecx
	mov	DWORD PTR ?g_pCurInstInfo@@3PAUEEINST@@A, eax ; g_pCurInstInfo
$LN29@recRecompi:

; 1874 : 				g_pCurInstInfo++;
; 1875 : 
; 1876 : 				if( g_pCurInstInfo->info & EEINSTINFO_COP2 ) {
; 1877 : 				}
; 1878 : 			}
; 1879 : 		}
; 1880 : 	}
; 1881 : 
; 1882 : #ifdef _DEBUG
; 1883 : 	// dump code
; 1884 : 	for(i = 0; i < ARRAYSIZE(s_recblocks); ++i) {
; 1885 : 		if( startpc == s_recblocks[i] ) {
; 1886 : 			iDumpBlock(startpc, recPtr);
; 1887 : 		}
; 1888 : 	}
; 1889 : 
; 1890 : 	if( (dumplog & 1) ) //|| usecop2 )
; 1891 : 		iDumpBlock(startpc, recPtr);
; 1892 : #endif
; 1893 : 
; 1894 : 	u32 sz=(s_nEndBlock-startpc)>>2;
; 1895 : #ifdef lulz
; 1896 : 	/*
; 1897 : 		Block checking (ADDED BY RAZ-TEMP)
; 1898 : 	*/
; 1899 : 	
; 1900 : 	MOV32ItoR(ECX,startpc);
; 1901 : 	MOV32ItoR(EDX,sz);
; 1902 : 
; 1903 : #endif
; 1904 : 
; 1905 : 	u32 inpage_offs=startpc&0xFFF;
; 1906 : 	u32 inpage_ptr=startpc;
; 1907 : 	u32 inpage_sz=sz*4;
; 1908 : 
; 1909 : 	MOV32ItoR(ECX,startpc);

	mov	eax, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
	mov	ebx, DWORD PTR tv1605[esp+72]
	mov	BYTE PTR [eax], 185			; 000000b9H
	inc	eax
	mov	DWORD PTR [eax], edi
	add	eax, 4
	mov	ecx, edx
	sub	ecx, edi

; 1910 : 	MOV32ItoR(EDX,sz);

	mov	BYTE PTR [eax], 186			; 000000baH
	shr	ecx, 2
	inc	eax
	lea	esi, DWORD PTR [ecx*4]
	mov	DWORD PTR [eax], ecx
	add	eax, 4
	mov	DWORD PTR _inpage_ptr$[esp+72], edi
	mov	DWORD PTR _inpage_sz$[esp+72], esi
	mov	DWORD PTR ?x86Ptr@@3PAEA, eax		; x86Ptr

; 1911 : 
; 1912 : 	while(inpage_sz)

	test	esi, esi
	je	$LN24@recRecompi
	npad	9
$LL25@recRecompi:

; 1913 : 	{
; 1914 : 		int PageType=mmap_GetRamPageInfo((u32*)PSM(inpage_ptr));

	mov	edi, DWORD PTR _inpage_ptr$[esp+72]
	and	edi, 536870911				; 1fffffffH
	cmp	edi, 536870912				; 20000000H
	jae	SHORT $LN294@recRecompi
	mov	ecx, edi
	shr	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR ?pmap@vtlb_private@@3PAHA[ecx*4]
	test	edx, edx
	jl	SHORT $LN294@recRecompi
	mov	ecx, edi
	and	ecx, 4095				; 00000fffH
	add	ecx, edx
	jmp	SHORT $LN293@recRecompi
$LN294@recRecompi:
	xor	ecx, ecx
$LN293@recRecompi:
	sub	ecx, DWORD PTR ?psM@@3PAEA		; psM
	mov	esi, ecx
	cmp	esi, 33554432				; 02000000H
	jb	SHORT $LN298@recRecompi
	or	edx, -1
	jmp	SHORT $LN299@recRecompi
$LN298@recRecompi:
	shr	esi, 12					; 0000000cH
	mov	ecx, esi
	and	ecx, 31					; 0000001fH
	mov	edx, 1
	shl	edx, cl
	shr	esi, 5
	and	edx, DWORD PTR ?psMPWC@@3PAIA[esi*4]
	neg	edx
	sbb	edx, edx
	neg	edx
$LN299@recRecompi:

; 1915 : 		u32 pgsz=std::min(0x1000-inpage_offs,inpage_sz);

	mov	ecx, 4096				; 00001000H
	sub	ecx, ebx
	cmp	DWORD PTR _inpage_sz$[esp+72], ecx
	mov	DWORD PTR $T800811[esp+72], ecx
	lea	ecx, DWORD PTR _inpage_sz$[esp+72]
	jb	SHORT $LN304@recRecompi
	lea	ecx, DWORD PTR $T800811[esp+72]
$LN304@recRecompi:
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR _pgsz$89622[esp+72], ecx

; 1916 : 
; 1917 : 		if(PageType!=-1)

	cmp	edx, -1
	je	$LN19@recRecompi

; 1918 : 		{
; 1919 : 			if (PageType==0)

	test	edx, edx
	jne	SHORT $LN22@recRecompi

; 1920 : 			{
; 1921 : 				//MOV32ItoR(EAX,*pageVer);
; 1922 : 				//CMP32MtoR(EAX,(uptr)pageVer);
; 1923 : 				//JNE32(((u32)dyna_block_discard_recmem)- ( (u32)x86Ptr + 6 ));
; 1924 : 
; 1925 : 				mmap_MarkCountedRamPage(PSM(inpage_ptr),inpage_ptr&~0xFFF);

	cmp	edi, 536870912				; 20000000H
	jae	SHORT $LN306@recRecompi
	mov	edx, edi
	shr	edx, 12					; 0000000cH
	mov	eax, DWORD PTR ?pmap@vtlb_private@@3PAHA[edx*4]
	test	eax, eax
	jl	SHORT $LN306@recRecompi
	and	edi, 4095				; 00000fffH
	add	edi, eax
	mov	eax, edi
	jmp	SHORT $LN305@recRecompi
$LN306@recRecompi:
	xor	eax, eax
$LN305@recRecompi:
	mov	ecx, DWORD PTR _inpage_ptr$[esp+72]
	and	ecx, -4096				; fffff000H
	push	ecx
	call	?mmap_MarkCountedRamPage@@YAXPAXI@Z	; mmap_MarkCountedRamPage

; 1926 : 			}
; 1927 : 			else

	mov	eax, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
	add	esp, 4
	jmp	$LN19@recRecompi
$LN22@recRecompi:

; 1928 : 			{
; 1929 : 				u32 lpc=inpage_ptr;
; 1930 : 				u32 stg=pgsz;
; 1931 : 				while(stg>0)

	cmp	DWORD PTR _pgsz$89622[esp+72], 0
	mov	esi, DWORD PTR _inpage_ptr$[esp+72]
	jbe	$LN19@recRecompi
	mov	ebx, DWORD PTR _pgsz$89622[esp+72]
	dec	ebx
	shr	ebx, 2
	inc	ebx
	npad	5
$LL20@recRecompi:

; 1932 : 				{
; 1933 : 					// was dyna_block_discard_recmem.  See note in recResetEE for details.
; 1934 : 					CMP32ItoM((uptr)PSM(lpc),*(u32*)PSM(lpc));

	mov	ecx, esi
	and	ecx, 536870911				; 1fffffffH
	cmp	ecx, 536870912				; 20000000H
	jae	SHORT $LN311@recRecompi
	mov	edx, ecx
	shr	edx, 12					; 0000000cH
	mov	edi, DWORD PTR ?pmap@vtlb_private@@3PAHA[edx*4]
	test	edi, edi
	jl	SHORT $LN311@recRecompi
	mov	edx, ecx
	and	edx, 4095				; 00000fffH
	add	edx, edi
	jmp	SHORT $LN310@recRecompi
$LN311@recRecompi:
	xor	edx, edx
$LN310@recRecompi:
	cmp	ecx, 536870912				; 20000000H
	jae	SHORT $LN316@recRecompi
	mov	edi, ecx
	shr	edi, 12					; 0000000cH
	mov	edi, DWORD PTR ?pmap@vtlb_private@@3PAHA[edi*4]
	test	edi, edi
	jl	SHORT $LN316@recRecompi
	and	ecx, 4095				; 00000fffH
	add	ecx, edi
	jmp	SHORT $LN315@recRecompi
$LN316@recRecompi:
	xor	ecx, ecx
$LN315@recRecompi:
	mov	edx, DWORD PTR [edx]
	mov	BYTE PTR [eax], 129			; 00000081H
	mov	BYTE PTR [eax+1], 61			; 0000003dH
	inc	eax
	mov	DWORD PTR [eax+1], ecx
	inc	eax
	add	eax, 4
	mov	DWORD PTR [eax], edx
	add	eax, 4

; 1935 : 					JNE32(((u32)&dyna_block_discard)- ( (u32)x86Ptr + 6 ));

	mov	BYTE PTR [eax], 15			; 0000000fH
	mov	ecx, OFFSET ?dyna_block_discard@@YIXII@Z ; dyna_block_discard
	sub	ecx, eax
	inc	eax
	mov	BYTE PTR [eax], 133			; 00000085H
	inc	eax
	sub	ecx, 6
	mov	DWORD PTR [eax], ecx
	add	eax, 4

; 1936 : 
; 1937 : 					stg-=4;
; 1938 : 					lpc+=4;

	add	esi, 4
	sub	ebx, 1
	jne	$LL20@recRecompi

; 1935 : 					JNE32(((u32)&dyna_block_discard)- ( (u32)x86Ptr + 6 ));

	mov	DWORD PTR ?x86Ptr@@3PAEA, eax		; x86Ptr
$LN19@recRecompi:

; 1939 : 				}
; 1940 : 				DbgCon::WriteLn("Manual block @ %08X : %08X %d %d %d %d", params
; 1941 : 					startpc,inpage_ptr,pgsz,0x1000-inpage_offs,inpage_sz,sz*4);
; 1942 : 			}
; 1943 : 		}
; 1944 : 		inpage_ptr+=pgsz;

	mov	ebx, DWORD PTR _inpage_ptr$[esp+72]
	mov	edx, DWORD PTR _pgsz$89622[esp+72]

; 1945 : 		inpage_sz-=pgsz;

	mov	ecx, DWORD PTR _inpage_sz$[esp+72]
	add	ebx, edx
	sub	ecx, edx
	mov	DWORD PTR _inpage_ptr$[esp+72], ebx

; 1946 : 		inpage_offs=inpage_ptr&0xFFF;

	and	ebx, 4095				; 00000fffH
	mov	DWORD PTR _inpage_sz$[esp+72], ecx
	test	ecx, ecx
	jne	$LL25@recRecompi

; 1911 : 
; 1912 : 	while(inpage_sz)

	mov	edx, DWORD PTR _s_nEndBlock
$LN24@recRecompi:

; 1947 : 	}
; 1948 : 
; 1949 : 	// finally recompile //
; 1950 : 	g_pCurInstInfo = s_pInstCache;
; 1951 : 	while (!branch && pc < s_nEndBlock) {

	cmp	DWORD PTR ?branch@@3HA, 0		; branch
	mov	eax, DWORD PTR _s_pInstCache
	mov	DWORD PTR ?g_pCurInstInfo@@3PAUEEINST@@A, eax ; g_pCurInstInfo
	jne	SHORT $LN747@recRecompi
	jmp	SHORT $LN18@recRecompi
$LL746@recRecompi:
	mov	edx, DWORD PTR _s_nEndBlock
$LN18@recRecompi:
	mov	eax, DWORD PTR ?pc@@3IA			; pc
	cmp	eax, edx
	jae	SHORT $LN17@recRecompi

; 1952 : 		recompileNextInstruction(0);

	push	0
	call	?recompileNextInstruction@@YAXH@Z	; recompileNextInstruction
	add	esp, 4
	cmp	DWORD PTR ?branch@@3HA, 0		; branch
	je	SHORT $LL746@recRecompi
$LN747@recRecompi:

; 1947 : 	}
; 1948 : 
; 1949 : 	// finally recompile //
; 1950 : 	g_pCurInstInfo = s_pInstCache;
; 1951 : 	while (!branch && pc < s_nEndBlock) {

	mov	eax, DWORD PTR ?pc@@3IA			; pc
$LN17@recRecompi:

; 1953 : 	}
; 1954 : 
; 1955 : #ifdef _DEBUG
; 1956 : 	if( (dumplog & 1) )
; 1957 : 		iDumpBlock(startpc, recPtr);
; 1958 : #endif
; 1959 : 
; 1960 : 	assert( (pc-startpc)>>2 <= 0xffff );
; 1961 : 	s_pCurBlockEx->size = (pc-startpc)>>2;

	sub	eax, DWORD PTR _startpc$[ebp]
	mov	esi, DWORD PTR _s_pCurBlockEx
	shr	eax, 2

; 1962 : 
; 1963 : 	for(i = 1; i < (u32)s_pCurBlockEx->size-1; ++i) {

	movzx	ecx, ax
	dec	ecx
	mov	edx, 1
	cmp	ecx, edx
	mov	ecx, DWORD PTR _s_pCurBlock
	mov	WORD PTR [esi], ax
	jbe	SHORT $LN14@recRecompi
	npad	6
$LL16@recRecompi:

; 1964 : 		s_pCurBlock[i].SetFnptr( s_pCurBlock->GetFnptr() );

	mov	eax, DWORD PTR [ecx]
	mov	edi, DWORD PTR [ecx+edx*8]
	shl	eax, 4
	shr	eax, 4
	and	edi, -268435456				; f0000000H
	or	eax, edi
	mov	DWORD PTR [ecx+edx*8], eax

; 1965 : 		s_pCurBlock[i].startpc = s_pCurBlock->startpc;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx+edx*8+4], eax
	movzx	eax, WORD PTR [esi]
	inc	edx
	dec	eax
	cmp	edx, eax
	jb	SHORT $LL16@recRecompi
$LN14@recRecompi:

; 1966 : 	}
; 1967 : 
; 1968 : 	// don't overwrite if delay slot
; 1969 : 	if( i < (u32)s_pCurBlockEx->size && !(s_pCurBlock[i].uType & BLOCKTYPE_DELAYSLOT) ) {

	movzx	eax, WORD PTR [esi]
	cmp	edx, eax
	jae	SHORT $LN13@recRecompi
	test	DWORD PTR [ecx+edx*8], 268435456	; 10000000H
	jne	SHORT $LN13@recRecompi

; 1970 : 		s_pCurBlock[i].SetFnptr( s_pCurBlock->GetFnptr() );

	mov	eax, DWORD PTR [ecx]
	mov	edi, DWORD PTR [ecx+edx*8]
	shl	eax, 4
	shr	eax, 4
	and	edi, -268435456				; f0000000H
	or	edi, eax
	mov	DWORD PTR [ecx+edx*8], edi

; 1971 : 		s_pCurBlock[i].startpc = s_pCurBlock->startpc;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx+edx*8+4], eax
$LN13@recRecompi:

; 1972 : 	}
; 1973 : 
; 1974 : 	// set the block ptr
; 1975 : 	AddBaseBlockEx(s_pCurBlockEx, 0);

	push	esi
	mov	eax, OFFSET _s_vecBaseBlocksEx
	call	?Add@BASEBLOCKS@@QAEXPAUBASEBLOCKEX@@@Z	; BASEBLOCKS::Add

; 1976 : //	if( p[1].startpc == p[0].startpc + 4 ) {
; 1977 : //		assert( p[1].GetFnptr() != 0 );
; 1978 : //		// already fn in place, so add to list
; 1979 : //		AddBaseBlockEx(s_pCurBlockEx, 0);
; 1980 : //	}
; 1981 : //	else
; 1982 : //		*(BASEBLOCKEX**)(p+1) = pex;
; 1983 : //	}
; 1984 : 
; 1985 : 	//PC_SETBLOCKEX(s_pCurBlock, s_pCurBlockEx);
; 1986 : 
; 1987 : 	if( !(pc&0x10000000) )

	mov	edi, DWORD PTR ?pc@@3IA			; pc
	test	edi, 268435456				; 10000000H
	jne	SHORT $LN12@recRecompi

; 1988 : 		maxrecmem = std::max( (pc&~0xa0000000), maxrecmem );

	mov	eax, edi
	and	eax, 1610612735				; 5fffffffH
	cmp	eax, DWORD PTR ?maxrecmem@@3IA		; maxrecmem
	mov	DWORD PTR $T800812[esp+72], eax
	mov	eax, OFFSET ?maxrecmem@@3IA		; maxrecmem
	jb	SHORT $LN355@recRecompi
	lea	eax, DWORD PTR $T800812[esp+72]
$LN355@recRecompi:
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR ?maxrecmem@@3IA, ecx		; maxrecmem
$LN12@recRecompi:

; 1989 : 
; 1990 : 	if( branch == 2 )

	mov	ebx, DWORD PTR ?branch@@3HA		; branch
	cmp	ebx, 2
	jne	$LN11@recRecompi

; 1991 : 	{
; 1992 : 		// Branch type 2 - This is how I "think" this works (air):
; 1993 : 		// Performs a branch/event test but does not actually "break" the block.
; 1994 : 		// This allows exceptions to be raised, and is thus sufficient for
; 1995 : 		// certain types of things like SYSCALL, EI, etc.  but it is not sufficient
; 1996 : 		// for actual branching instructions.
; 1997 : 
; 1998 : 		iFlushCall(FLUSH_EVERYTHING);

	xor	edi, edi
	mov	esi, OFFSET ?x86regs@@3PAU_x86regs@@A	; x86regs
$LL371@recRecompi:
	cmp	BYTE PTR [esi], 0
	je	SHORT $LN370@recRecompi
	push	edi
	call	?_freeX86reg@@YAXH@Z			; _freeX86reg
	add	esp, 4
$LN370@recRecompi:
	add	esi, 12					; 0000000cH
	inc	edi
	cmp	esi, OFFSET ?x86regs@@3PAU_x86regs@@A+96
	jl	SHORT $LL371@recRecompi
	xor	esi, esi
$LL377@recRecompi:
	cmp	BYTE PTR ?xmmregs@@3PAU_xmmregs@@A[esi*8], 0
	je	SHORT $LN376@recRecompi
	mov	eax, esi
	call	?_freeXMMreg@@YAXH@Z			; _freeXMMreg
$LN376@recRecompi:
	inc	esi
	cmp	esi, 8
	jl	SHORT $LL377@recRecompi
	xor	edi, edi
	mov	esi, OFFSET ?mmxregs@@3PAU_mmxregs@@A	; mmxregs
$LL389@recRecompi:
	cmp	BYTE PTR [esi], 0
	je	SHORT $LN388@recRecompi
	mov	edx, edi
	call	?_freeMMXreg@@YAXH@Z			; _freeMMXreg
$LN388@recRecompi:
	add	esi, 6
	inc	edi
	cmp	esi, OFFSET ?mmxregs@@3PAU_mmxregs@@A+48
	jl	SHORT $LL389@recRecompi
	call	?_flushConstRegs@@YAXXZ			; _flushConstRegs
	mov	ax, WORD PTR ?iCWstate@@3GA		; iCWstate
	mov	esi, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
	test	ax, ax
	je	SHORT $LN395@recRecompi
	test	al, 1
	je	SHORT $LN405@recRecompi
	mov	BYTE PTR [esi], 217			; 000000d9H
	inc	esi
	mov	BYTE PTR [esi], 45			; 0000002dH
	inc	esi
	mov	DWORD PTR [esi], OFFSET _fpucws
	add	esi, 4
	mov	DWORD PTR ?x86Ptr@@3PAEA, esi		; x86Ptr
$LN405@recRecompi:
	xor	edx, edx
	mov	WORD PTR ?iCWstate@@3GA, dx		; iCWstate
$LN395@recRecompi:
	cmp	WORD PTR ?x86FpuState@@3GA, 1		; x86FpuState
	jne	SHORT $LN358@recRecompi
	cmp	DWORD PTR ?cpucaps@@3UCAPABILITIES@@A+136, 0
	je	SHORT $LN357@recRecompi
	mov	eax, 3599				; 00000e0fH
	mov	WORD PTR [esi], ax
	jmp	SHORT $LN773@recRecompi
$LN357@recRecompi:
	mov	ecx, 30479				; 0000770fH
	mov	WORD PTR [esi], cx
$LN773@recRecompi:
	add	esi, 2
	xor	edx, edx
	mov	DWORD PTR ?x86Ptr@@3PAEA, esi		; x86Ptr
	mov	WORD PTR ?x86FpuState@@3GA, dx		; x86FpuState
$LN358@recRecompi:

; 1999 : 		iBranchTest(0xffffffff, true);

	cmp	DWORD PTR ?bExecBIOS@@3IA, 0		; bExecBIOS
	je	SHORT $LN419@recRecompi
	call	?CheckForBIOSEnd@@YAXXZ			; CheckForBIOSEnd
	mov	esi, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
$LN419@recRecompi:
	mov	BYTE PTR [esi], 139			; 0000008bH
	inc	esi
	mov	BYTE PTR [esi], 5
	inc	esi
	mov	DWORD PTR [esi], OFFSET ?cpuRegs@@3UcpuRegisters@@A+960
	add	esi, 4
	call	?eeScaleBlockCycles@@YAIXZ		; eeScaleBlockCycles
	cmp	eax, 128				; 00000080H
	jae	SHORT $LN445@recRecompi
	mov	BYTE PTR [esi], 131			; 00000083H
	inc	esi
	mov	BYTE PTR [esi], 192			; 000000c0H
	inc	esi
	mov	BYTE PTR [esi], al
	inc	esi
	jmp	SHORT $LN470@recRecompi
$LN445@recRecompi:
	mov	BYTE PTR [esi], 5
	inc	esi
	mov	DWORD PTR [esi], eax
	add	esi, 4
$LN470@recRecompi:
	mov	BYTE PTR [esi], 137			; 00000089H
	mov	BYTE PTR [esi+1], 5
	inc	esi
	mov	DWORD PTR [esi+1], OFFSET ?cpuRegs@@3UcpuRegisters@@A+960
	inc	esi
	add	esi, 4
	mov	BYTE PTR [esi], 43			; 0000002bH
	inc	esi
	mov	BYTE PTR [esi], 5
	inc	esi
	mov	DWORD PTR [esi], OFFSET ?g_nextBranchCycle@@3IA ; g_nextBranchCycle
	add	esi, 4
	mov	eax, 50163				; 0000c3f3H
	mov	WORD PTR [esi], ax
	add	esi, 2

; 2000 : 	}
; 2001 : 	else

	jmp	$LN774@recRecompi
$LN11@recRecompi:

; 2002 : 	{
; 2003 : 		assert( branch != 3 );
; 2004 : 		if( branch )

	test	ebx, ebx
	jne	SHORT $LN750@recRecompi

; 2005 : 			assert( !willbranch3 );
; 2006 : 		else
; 2007 : 			ADD32ItoM((int)&cpuRegs.cycle, eeScaleBlockCycles() );

	call	?eeScaleBlockCycles@@YAIXZ		; eeScaleBlockCycles
	mov	esi, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
	mov	BYTE PTR [esi], 129			; 00000081H
	inc	esi
	mov	BYTE PTR [esi], 5
	inc	esi
	mov	DWORD PTR [esi], OFFSET ?cpuRegs@@3UcpuRegisters@@A+960
	add	esi, 4
	mov	DWORD PTR [esi], eax
	add	esi, 4
	mov	DWORD PTR ?x86Ptr@@3PAEA, esi		; x86Ptr
	jmp	SHORT $LN530@recRecompi
$LN750@recRecompi:
	mov	esi, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
$LN530@recRecompi:

; 2008 : 
; 2009 : 		if( willbranch3 ) {

	cmp	DWORD PTR _willbranch3$[esp+72], 0
	je	$LN7@recRecompi

; 2010 : 			BASEBLOCK* pblock = PC_GETBLOCK(s_nEndBlock);

	movzx	ecx, WORD PTR _s_nEndBlock+2
	mov	edx, DWORD PTR _s_nEndBlock
	mov	eax, DWORD PTR ?recLUT@@3PAIA		; recLUT
	mov	ecx, DWORD PTR [eax+ecx*4]
	and	edx, 65535				; 0000ffffH
	lea	ebx, DWORD PTR [ecx+edx*2]

; 2011 : 			assert( pc == s_nEndBlock );
; 2012 : 			iFlushCall(FLUSH_EVERYTHING);

	xor	edi, edi
	mov	esi, OFFSET ?x86regs@@3PAU_x86regs@@A	; x86regs
$LL547@recRecompi:
	cmp	BYTE PTR [esi], 0
	je	SHORT $LN546@recRecompi
	push	edi
	call	?_freeX86reg@@YAXH@Z			; _freeX86reg
	add	esp, 4
$LN546@recRecompi:
	add	esi, 12					; 0000000cH
	inc	edi
	cmp	esi, OFFSET ?x86regs@@3PAU_x86regs@@A+96
	jl	SHORT $LL547@recRecompi
	xor	esi, esi
$LL553@recRecompi:
	cmp	BYTE PTR ?xmmregs@@3PAU_xmmregs@@A[esi*8], 0
	je	SHORT $LN552@recRecompi
	mov	eax, esi
	call	?_freeXMMreg@@YAXH@Z			; _freeXMMreg
$LN552@recRecompi:
	inc	esi
	cmp	esi, 8
	jl	SHORT $LL553@recRecompi
	xor	edi, edi
	mov	esi, OFFSET ?mmxregs@@3PAU_mmxregs@@A	; mmxregs
$LL565@recRecompi:
	cmp	BYTE PTR [esi], 0
	je	SHORT $LN564@recRecompi
	mov	edx, edi
	call	?_freeMMXreg@@YAXH@Z			; _freeMMXreg
$LN564@recRecompi:
	add	esi, 6
	inc	edi
	cmp	esi, OFFSET ?mmxregs@@3PAU_mmxregs@@A+48
	jl	SHORT $LL565@recRecompi
	call	?_flushConstRegs@@YAXXZ			; _flushConstRegs
	mov	ax, WORD PTR ?iCWstate@@3GA		; iCWstate
	mov	esi, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
	test	ax, ax
	je	SHORT $LN571@recRecompi
	test	al, 1
	je	SHORT $LN581@recRecompi
	mov	BYTE PTR [esi], 217			; 000000d9H
	inc	esi
	mov	BYTE PTR [esi], 45			; 0000002dH
	inc	esi
	mov	DWORD PTR [esi], OFFSET _fpucws
	add	esi, 4
$LN581@recRecompi:
	xor	edx, edx
	mov	WORD PTR ?iCWstate@@3GA, dx		; iCWstate
$LN571@recRecompi:
	cmp	WORD PTR ?x86FpuState@@3GA, 1		; x86FpuState
	jne	SHORT $LN534@recRecompi
	cmp	DWORD PTR ?cpucaps@@3UCAPABILITIES@@A+136, 0
	je	SHORT $LN533@recRecompi
	mov	eax, 3599				; 00000e0fH
	mov	WORD PTR [esi], ax
	jmp	SHORT $LN775@recRecompi
$LN533@recRecompi:
	mov	ecx, 30479				; 0000770fH
	mov	WORD PTR [esi], cx
$LN775@recRecompi:
	add	esi, 2
	xor	edx, edx
	mov	WORD PTR ?x86FpuState@@3GA, dx		; x86FpuState
$LN534@recRecompi:

; 2013 : 			MOV32ItoM((uptr)&cpuRegs.pc, pc);

	mov	edi, DWORD PTR ?pc@@3IA			; pc
	mov	BYTE PTR [esi], 199			; 000000c7H
	mov	BYTE PTR [esi+1], 5
	inc	esi
	mov	DWORD PTR [esi+1], OFFSET ?cpuRegs@@3UcpuRegisters@@A+680
	inc	esi
	add	esi, 4
	mov	DWORD PTR [esi], edi

; 2014 : 			JMP32((uptr)pblock->GetFnptr() - ((uptr)x86Ptr + 5));

	mov	eax, DWORD PTR [ebx]
	add	esi, 4
	shl	eax, 4
	sub	eax, esi
	mov	BYTE PTR [esi], 233			; 000000e9H
	sub	eax, 5
	inc	esi

; 2015 : 			branch = 3;

	mov	ebx, 3
	mov	DWORD PTR [esi], eax
	add	esi, 4
	mov	DWORD PTR ?branch@@3HA, ebx		; branch
	jmp	$LN776@recRecompi
$LN7@recRecompi:

; 2016 : 		}
; 2017 : 		else if( !branch ) {

	test	ebx, ebx
	jne	$LN5@recRecompi

; 2018 : 			// didn't branch, but had to stop
; 2019 : 			MOV32ItoM( (uptr)&cpuRegs.pc, pc );

	mov	BYTE PTR [esi], 199			; 000000c7H
	inc	esi
	mov	BYTE PTR [esi], 5
	inc	esi
	mov	DWORD PTR [esi], OFFSET ?cpuRegs@@3UcpuRegisters@@A+680
	add	esi, 4
	mov	DWORD PTR [esi], edi
	add	esi, 4
	mov	DWORD PTR ?x86Ptr@@3PAEA, esi		; x86Ptr

; 2020 : 
; 2021 : 			iFlushCall(FLUSH_EVERYTHING);

	xor	edi, edi
	mov	esi, OFFSET ?x86regs@@3PAU_x86regs@@A	; x86regs
	npad	6
$LL638@recRecompi:
	cmp	BYTE PTR [esi], 0
	je	SHORT $LN637@recRecompi
	push	edi
	call	?_freeX86reg@@YAXH@Z			; _freeX86reg
	add	esp, 4
$LN637@recRecompi:
	add	esi, 12					; 0000000cH
	inc	edi
	cmp	esi, OFFSET ?x86regs@@3PAU_x86regs@@A+96
	jl	SHORT $LL638@recRecompi
	xor	esi, esi
	npad	4
$LL644@recRecompi:
	cmp	BYTE PTR ?xmmregs@@3PAU_xmmregs@@A[esi*8], 0
	je	SHORT $LN643@recRecompi
	mov	eax, esi
	call	?_freeXMMreg@@YAXH@Z			; _freeXMMreg
$LN643@recRecompi:
	inc	esi
	cmp	esi, 8
	jl	SHORT $LL644@recRecompi
	xor	edi, edi
	mov	esi, OFFSET ?mmxregs@@3PAU_mmxregs@@A	; mmxregs
	npad	2
$LL656@recRecompi:
	cmp	BYTE PTR [esi], 0
	je	SHORT $LN655@recRecompi
	mov	edx, edi
	call	?_freeMMXreg@@YAXH@Z			; _freeMMXreg
$LN655@recRecompi:
	add	esi, 6
	inc	edi
	cmp	esi, OFFSET ?mmxregs@@3PAU_mmxregs@@A+48
	jl	SHORT $LL656@recRecompi
	call	?_flushConstRegs@@YAXXZ			; _flushConstRegs
	mov	ax, WORD PTR ?iCWstate@@3GA		; iCWstate
	mov	esi, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
	test	ax, ax
	je	SHORT $LN662@recRecompi
	test	al, 1
	je	SHORT $LN672@recRecompi
	mov	BYTE PTR [esi], 217			; 000000d9H
	inc	esi
	mov	BYTE PTR [esi], 45			; 0000002dH
	inc	esi
	mov	DWORD PTR [esi], OFFSET _fpucws
	add	esi, 4
$LN672@recRecompi:
	xor	eax, eax
	mov	WORD PTR ?iCWstate@@3GA, ax		; iCWstate
$LN662@recRecompi:
	cmp	WORD PTR ?x86FpuState@@3GA, 1		; x86FpuState
	jne	SHORT $LN625@recRecompi
	cmp	DWORD PTR ?cpucaps@@3UCAPABILITIES@@A+136, 0
	je	SHORT $LN624@recRecompi
	mov	ecx, 3599				; 00000e0fH
	mov	WORD PTR [esi], cx
	jmp	SHORT $LN777@recRecompi
$LN624@recRecompi:
	mov	edx, 30479				; 0000770fH
	mov	WORD PTR [esi], dx
$LN777@recRecompi:
	add	esi, 2
	xor	eax, eax
	mov	WORD PTR ?x86FpuState@@3GA, ax		; x86FpuState
$LN625@recRecompi:

; 2022 : 
; 2023 : 			ptr = JMP32(0);

	mov	BYTE PTR [esi], 233			; 000000e9H
	inc	esi
	mov	DWORD PTR [esi], 0
	add	esi, 4
	lea	ecx, DWORD PTR [esi-4]
	mov	DWORD PTR _ptr$[esp+72], ecx
$LN774@recRecompi:
	mov	edi, DWORD PTR ?pc@@3IA			; pc
	mov	ebx, DWORD PTR ?branch@@3HA		; branch
$LN776@recRecompi:
	mov	DWORD PTR ?x86Ptr@@3PAEA, esi		; x86Ptr
$LN5@recRecompi:

; 2024 : 		}
; 2025 : 	}
; 2026 : 
; 2027 : 	assert( x86Ptr >= (u8*)s_pCurBlock->GetFnptr() + EE_MIN_BLOCK_BYTES );
; 2028 : 	assert( x86Ptr < recMem+REC_CACHEMEM );
; 2029 : 	assert( recStackPtr < recStack+RECSTACK_SIZE );
; 2030 : 	assert( x86FpuState == 0 );
; 2031 : 
; 2032 : 	recPtr = x86Ptr;

	mov	DWORD PTR _recPtr, esi

; 2033 : 
; 2034 : 	assert( (g_cpuHasConstReg&g_cpuFlushedConstReg) == g_cpuHasConstReg );
; 2035 : 
; 2036 : 	if( !branch ) {

	test	ebx, ebx
	jne	SHORT $LN1@recRecompi

; 2037 : 		BASEBLOCK* pcurblock = s_pCurBlock;
; 2038 : 		u32 nEndBlock = s_nEndBlock;
; 2039 : 		s_pCurBlock = PC_GETBLOCK(pc);

	movzx	edx, WORD PTR ?pc@@3IA+2
	mov	ecx, DWORD PTR ?recLUT@@3PAIA		; recLUT
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	esi, DWORD PTR _s_pCurBlock
	mov	eax, edi
	and	eax, 65535				; 0000ffffH
	lea	eax, DWORD PTR [edx+eax*2]
	mov	DWORD PTR _s_pCurBlock, eax

; 2040 : 		assert( ptr != NULL );
; 2041 : 		
; 2042 : 		if( s_pCurBlock->startpc != pc ) 

	cmp	DWORD PTR [eax+4], edi
	je	SHORT $LN3@recRecompi

; 2043 :  			recRecompile(pc);

	push	edi
	call	?recRecompile@@YAXI@Z			; recRecompile
	mov	eax, DWORD PTR _s_pCurBlock
	add	esp, 4
$LN3@recRecompi:

; 2044 : 
; 2045 : 		if( pcurblock->startpc == startpc ) {

	mov	ecx, DWORD PTR _startpc$[ebp]
	cmp	DWORD PTR [esi+4], ecx
	jne	$LL690@recRecompi

; 2046 : 			assert( pcurblock->GetFnptr() );
; 2047 : 			assert( s_pCurBlock->startpc == nEndBlock );
; 2048 : 			*ptr = s_pCurBlock->GetFnptr() - ( (u32)ptr + 4 );

	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR _ptr$[esp+72]
	shl	edx, 4
	sub	edx, eax
	sub	edx, 4
	mov	DWORD PTR [eax], edx
$LN1@recRecompi:

; 2049 : 		}
; 2050 : 		else {
; 2051 : 			recRecompile(startpc);
; 2052 : 			assert( pcurblock->GetFnptr() != 0 );
; 2053 : 		}
; 2054 : 	}
; 2055 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN781@recRecompi:
	DD	$LN72@recRecompi
	DD	$LN68@recRecompi
	DD	$LN717@recRecompi
	DD	$LN57@recRecompi
	DD	$LN51@recRecompi
	DD	$LN49@recRecompi
	DD	$LN46@recRecompi
$LN743@recRecompi:
	DB	0
	DB	1
	DB	2
	DB	2
	DB	3
	DB	3
	DB	3
	DB	3
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	4
	DB	5
	DB	5
	DB	6
	DB	3
	DB	3
	DB	3
	DB	3
?recRecompile@@YAXI@Z ENDP				; recRecompile
; Function compile flags: /Odtpy
?DispatcherReg@@YAXXZ PROC				; DispatcherReg

; 750  : 	s_pDispatchBlock = PC_GETBLOCK(cpuRegs.pc);

	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+680
	shr	eax, 16					; 00000010H
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+680
	and	ecx, 65535				; 0000ffffH
	mov	edx, DWORD PTR ?recLUT@@3PAIA		; recLUT
	mov	eax, DWORD PTR [edx+eax*4]
	lea	ecx, DWORD PTR [eax+ecx*2]
	mov	DWORD PTR ?s_pDispatchBlock@@3PBUBASEBLOCK@@B, ecx ; s_pDispatchBlock

; 751  : 
; 752  : 	if( s_pDispatchBlock->startpc != cpuRegs.pc )

	mov	edx, DWORD PTR ?s_pDispatchBlock@@3PBUBASEBLOCK@@B ; s_pDispatchBlock
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+680
	je	SHORT $LN1@Dispatcher@3

; 753  : 		recRecompile(cpuRegs.pc);

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+680
	push	ecx
	call	?recRecompile@@YAXI@Z			; recRecompile
	add	esp, 4
$LN1@Dispatcher@3:

; 754  : 
; 755  : 	__asm
; 756  : 	{
; 757  : 		mov eax, s_pDispatchBlock

	mov	eax, DWORD PTR ?s_pDispatchBlock@@3PBUBASEBLOCK@@B ; s_pDispatchBlock

; 758  : 		mov eax, dword ptr [eax]

	mov	eax, DWORD PTR [eax]

; 759  : 	}
; 760  : 
; 761  : #ifdef _DEBUG
; 762  : 	__asm mov g_EEDispatchTemp, eax
; 763  : 	assert( g_EEDispatchTemp );
; 764  : #endif
; 765  : 
; 766  : 	__asm {
; 767  : 		//and eax, 0x0fffffff
; 768  : 		shl eax, 4

	shl	eax, 4

; 769  : 		jmp eax

	jmp	eax
?DispatcherReg@@YAXXZ ENDP				; DispatcherReg
	ORG $+6588
__unwindtable$?recAlloc@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?recAlloc@@YAXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?recAlloc@@YAXXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?recAlloc@@YAXXZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?recAlloc@@YAXXZ$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?recAlloc@@YAXXZ$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?recAlloc@@YAXXZ$5
__ehfuncinfo$?recAlloc@@YAXXZ DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?recAlloc@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
$T802603 = -376						; size = 28
$T802605 = -348						; size = 28
$T802613 = -320						; size = 28
$T802611 = -292						; size = 28
$T802609 = -264						; size = 28
$T802607 = -236						; size = 28
$T802604 = -208						; size = 32
$T802608 = -176						; size = 32
$T802602 = -144						; size = 32
$T802610 = -112						; size = 32
$T802606 = -80						; size = 32
$T802612 = -48						; size = 32
__$EHRec$ = -12						; size = 12
?recAlloc@@YAXXZ PROC					; recAlloc

; 484  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?recAlloc@@YAXXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 364				; 0000016cH
	push	ebx

; 485  : 	// Hardware Requirements Check...
; 486  : 
; 487  : 	if ( !( cpucaps.hasMultimediaExtensions  ) )

	xor	ebx, ebx
	push	esi
	cmp	DWORD PTR ?cpucaps@@3UCAPABILITIES@@A+80, ebx
	jne	SHORT $LN10@recAlloc

; 488  : 		throw Exception::HardwareDeficiency( _( "Processor doesn't support MMX" ) );

	push	OFFSET ??_C@_0BO@BJGNDGDH@Processor?5doesn?8t?5support?5MMX?$AA@
	push	OFFSET ??_C@_05FFJFDMOL@pcsx2?$AA@
	call	DWORD PTR __imp__dgettext
	mov	ecx, eax
	add	esp, 8
	mov	DWORD PTR $T802603[esp+408], 15		; 0000000fH
	mov	DWORD PTR $T802603[esp+404], ebx
	mov	BYTE PTR $T802603[esp+388], bl
	lea	esi, DWORD PTR [ecx+1]
$LL109@recAlloc:
	mov	dl, BYTE PTR [ecx]
	inc	ecx
	cmp	dl, bl
	jne	SHORT $LL109@recAlloc
	sub	ecx, esi
	push	ecx
	push	eax
	lea	ecx, DWORD PTR $T802603[esp+392]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	DWORD PTR __$EHRec$[esp+392], ebx
	lea	eax, DWORD PTR $T802603[esp+384]
	push	eax
	lea	ecx, DWORD PTR $T802602[esp+388]
	push	ecx
	call	??0HardwareDeficiency@Exception@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Exception::HardwareDeficiency::HardwareDeficiency
	push	OFFSET __TI3?AVHardwareDeficiency@Exception@@
	lea	edx, DWORD PTR $T802602[esp+388]
	push	edx
	call	__CxxThrowException@8
$LN113@recAlloc:
$LN10@recAlloc:

; 489  : 
; 490  : 	if ( !( cpucaps.hasStreamingSIMDExtensions ) )

	cmp	DWORD PTR ?cpucaps@@3UCAPABILITIES@@A+88, ebx
	jne	SHORT $LN9@recAlloc

; 491  : 		throw Exception::HardwareDeficiency( _( "Processor doesn't support SSE" ) );

	push	OFFSET ??_C@_0BO@EAHPPEPN@Processor?5doesn?8t?5support?5SSE?$AA@
	push	OFFSET ??_C@_05FFJFDMOL@pcsx2?$AA@
	call	DWORD PTR __imp__dgettext
	mov	ecx, eax
	add	esp, 8
	mov	DWORD PTR $T802605[esp+408], 15		; 0000000fH
	mov	DWORD PTR $T802605[esp+404], ebx
	mov	BYTE PTR $T802605[esp+388], bl
	lea	esi, DWORD PTR [ecx+1]
$LL110@recAlloc:
	mov	dl, BYTE PTR [ecx]
	inc	ecx
	cmp	dl, bl
	jne	SHORT $LL110@recAlloc
	sub	ecx, esi
	push	ecx
	push	eax
	lea	ecx, DWORD PTR $T802605[esp+392]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	DWORD PTR __$EHRec$[esp+392], 1
	lea	eax, DWORD PTR $T802605[esp+384]
	push	eax
	lea	ecx, DWORD PTR $T802604[esp+388]
	push	ecx
	call	??0HardwareDeficiency@Exception@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Exception::HardwareDeficiency::HardwareDeficiency
	push	OFFSET __TI3?AVHardwareDeficiency@Exception@@
	lea	edx, DWORD PTR $T802604[esp+388]
	push	edx
	call	__CxxThrowException@8
$LN114@recAlloc:
$LN9@recAlloc:

; 492  : 
; 493  : 	if ( !( cpucaps.hasStreamingSIMD2Extensions ) )

	cmp	DWORD PTR ?cpucaps@@3UCAPABILITIES@@A+92, ebx
	jne	SHORT $LN8@recAlloc

; 494  : 		throw Exception::HardwareDeficiency( _( "Processor doesn't support SSE2" ) );

	push	OFFSET ??_C@_0BP@CODMKFCE@Processor?5doesn?8t?5support?5SSE2?$AA@
	push	OFFSET ??_C@_05FFJFDMOL@pcsx2?$AA@
	call	DWORD PTR __imp__dgettext
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR $T802607[esp+388]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[esp+392], 2
	lea	eax, DWORD PTR $T802607[esp+384]
	push	eax
	lea	ecx, DWORD PTR $T802606[esp+388]
	push	ecx
	call	??0HardwareDeficiency@Exception@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Exception::HardwareDeficiency::HardwareDeficiency
	push	OFFSET __TI3?AVHardwareDeficiency@Exception@@
	lea	edx, DWORD PTR $T802606[esp+388]
	push	edx
	call	__CxxThrowException@8
$LN115@recAlloc:
$LN8@recAlloc:

; 495  : 
; 496  : 	if( recLUT == NULL )

	cmp	DWORD PTR ?recLUT@@3PAIA, ebx		; recLUT
	jne	SHORT $LN7@recAlloc

; 497  : 		recLUT = (uptr*) _aligned_malloc( 0x010000 * sizeof(uptr), 16 );

	push	16					; 00000010H
	push	262144					; 00040000H
	call	__aligned_malloc
	add	esp, 8
	mov	DWORD PTR ?recLUT@@3PAIA, eax		; recLUT
$LN7@recAlloc:

; 498  : 
; 499  : 	if( recMem == NULL )

	mov	esi, DWORD PTR _recMem
	cmp	esi, ebx
	jne	$LN5@recAlloc

; 500  : 	{
; 501  : 		// Note: the VUrec depends on being able to grab an allocatione below the 0x10000000 line,
; 502  : 		// so we give the EErec an address above that to try first as it's basemem address, hence
; 503  : 		// the 0x20000000 pick.
; 504  : 
; 505  : 		const uint cachememsize = REC_CACHEMEM+0x1000;
; 506  : 		recMem = (u8*)SysMmapEx( 0x20000000, cachememsize, 0, "recAlloc(R5900)" );

	mov	esi, DWORD PTR __imp__VirtualAlloc@16
	push	64					; 00000040H
	push	12288					; 00003000H
	push	16781312				; 01001000H
	push	536870912				; 20000000H
	call	esi
	cmp	eax, ebx
	jne	SHORT $LN91@recAlloc
	push	536870912				; 20000000H
	push	OFFSET ??_C@_0BA@GOFBLDMA@recAlloc?$CIR5900?$CJ?$AA@
	push	ebx
	push	OFFSET ??_C@_0CP@LIOIKNAO@First?5try?5failed?5allocating?5?$CFs?5a@
	call	?Notice@Console@@YA_NPBDPBU_VARG_PARAM@@ZZ ; Console::Notice
	add	esp, 16					; 00000010H
	push	64					; 00000040H
	push	12288					; 00003000H
	push	16781312				; 01001000H
	push	ebx
	call	esi
$LN91@recAlloc:
	mov	esi, eax
	mov	DWORD PTR _recMem, esi

; 507  : 	}
; 508  : 
; 509  : 	if( recMem == NULL )

	cmp	eax, ebx
	jne	SHORT $LN5@recAlloc

; 510  : 		throw Exception::OutOfMemory( "R5900-32 > failed to allocate recompiler memory." );

	push	OFFSET ??_C@_0DB@KMMEHCKA@R5900?932?5?$DO?5failed?5to?5allocate?5re@
	lea	ecx, DWORD PTR $T802609[esp+388]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[esp+392], 3
	lea	eax, DWORD PTR $T802609[esp+384]
	push	eax
	lea	ecx, DWORD PTR $T802608[esp+388]
	push	ecx
	call	??0OutOfMemory@Exception@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Exception::OutOfMemory::OutOfMemory
	push	OFFSET __TI3?AVOutOfMemory@Exception@@
	lea	edx, DWORD PTR $T802608[esp+388]
	push	edx
	call	__CxxThrowException@8
$LN116@recAlloc:
$LN5@recAlloc:

; 511  : 
; 512  : 	// Goal: Allocate BASEBLOCKs for every possible branch target in PS2 memory.
; 513  : 	// Any 4-byte aligned address makes a valid branch target as per MIPS design (all instructions are
; 514  : 	// always 4 bytes long).
; 515  : 
; 516  :     if( m_recBlockAlloc == NULL )

	mov	eax, DWORD PTR _m_recBlockAlloc
	cmp	eax, ebx
	jne	SHORT $LN3@recAlloc

; 517  : 		m_recBlockAlloc = (u8*) _aligned_malloc( m_recBlockAllocSize, 4096 );

	push	4096					; 00001000H
	push	76873728				; 04950000H
	call	__aligned_malloc
	add	esp, 8
	mov	DWORD PTR _m_recBlockAlloc, eax

; 518  : 
; 519  : 	if( m_recBlockAlloc == NULL )

	cmp	eax, ebx
	jne	SHORT $LN3@recAlloc

; 520  : 		throw Exception::OutOfMemory( "R5900-32 Init > Failed to allocate memory for BASEBLOCK tables." );

	push	OFFSET ??_C@_0EA@NGEJMDFP@R5900?932?5Init?5?$DO?5Failed?5to?5alloca@
	lea	ecx, DWORD PTR $T802611[esp+388]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[esp+392], 4
	lea	eax, DWORD PTR $T802611[esp+384]
	push	eax
	lea	ecx, DWORD PTR $T802610[esp+388]
	push	ecx
	call	??0OutOfMemory@Exception@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Exception::OutOfMemory::OutOfMemory
	push	OFFSET __TI3?AVOutOfMemory@Exception@@
	lea	edx, DWORD PTR $T802610[esp+388]
	push	edx
	call	__CxxThrowException@8
$LN117@recAlloc:
$LN3@recAlloc:

; 521  : 
; 522  : 	u8* curpos = m_recBlockAlloc;
; 523  : 	recRAM = (BASEBLOCK*)curpos; curpos += (Ps2MemSize::Base / 4) * sizeof(BASEBLOCK);

	mov	DWORD PTR _recRAM, eax
	add	eax, 67108864				; 04000000H

; 524  : 	recROM = (BASEBLOCK*)curpos; curpos += (Ps2MemSize::Rom / 4) * sizeof(BASEBLOCK);

	mov	DWORD PTR _recROM, eax
	add	eax, 8388608				; 00800000H

; 525  : 	recROM1 = (BASEBLOCK*)curpos; curpos += (Ps2MemSize::Rom1 / 4) * sizeof(BASEBLOCK);

	mov	DWORD PTR _recROM1, eax
	add	eax, 524288				; 00080000H

; 526  : 	recBlocks = (BASEBLOCKEX*)curpos; curpos += sizeof(BASEBLOCKEX)*EE_NUMBLOCKS;

	mov	DWORD PTR _recBlocks, eax
	add	eax, 786432				; 000c0000H

; 527  : 	recStack = (u8*)curpos;

	mov	DWORD PTR _recStack, eax

; 528  : 
; 529  : 	if( s_pInstCache == NULL )

	cmp	DWORD PTR _s_pInstCache, ebx
	jne	SHORT $LN1@recAlloc

; 530  : 	{
; 531  : 		s_nInstCacheSize = 128;
; 532  : 		s_pInstCache = (EEINST*)malloc( sizeof(EEINST) * s_nInstCacheSize );

	push	14336					; 00003800H
	mov	DWORD PTR _s_nInstCacheSize, 128	; 00000080H
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _s_pInstCache, eax

; 533  : 	}
; 534  : 
; 535  : 	if( s_pInstCache == NULL )

	cmp	eax, ebx
	jne	SHORT $LN1@recAlloc

; 536  : 		throw Exception::OutOfMemory( "R5900-32 Init > failed to allocate memory for pInstCache." );

	push	OFFSET ??_C@_0DK@KMFNGPCI@R5900?932?5Init?5?$DO?5failed?5to?5alloca@
	lea	ecx, DWORD PTR $T802613[esp+388]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[esp+392], 5
	lea	eax, DWORD PTR $T802613[esp+384]
	push	eax
	lea	ecx, DWORD PTR $T802612[esp+388]
	push	ecx
	call	??0OutOfMemory@Exception@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Exception::OutOfMemory::OutOfMemory
	push	OFFSET __TI3?AVOutOfMemory@Exception@@
	lea	edx, DWORD PTR $T802612[esp+388]
	push	edx
	call	__CxxThrowException@8
$LN118@recAlloc:
$LN1@recAlloc:

; 537  : 
; 538  : 	// No errors.. Proceed with initialization:
; 539  : 
; 540  : 	ProfilerRegisterSource( "EERec", recMem, REC_CACHEMEM+0x1000 );

	push	16781312				; 01001000H
	push	esi
	mov	esi, OFFSET ??_C@_05OAHDOEDM@EERec?$AA@
	call	?ProfilerRegisterSource@@YAXPBDPBXI@Z	; ProfilerRegisterSource

; 541  : 
; 542  : 	x86FpuState = FPU_STATE;
; 543  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+392]
	add	esp, 8
	xor	eax, eax
	pop	esi
	mov	WORD PTR ?x86FpuState@@3GA, ax		; x86FpuState
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN112@recAlloc:
__unwindfunclet$?recAlloc@@YAXXZ$0:
	lea	ecx, DWORD PTR $T802603[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?recAlloc@@YAXXZ$1:
	lea	ecx, DWORD PTR $T802605[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?recAlloc@@YAXXZ$2:
	lea	ecx, DWORD PTR $T802607[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?recAlloc@@YAXXZ$3:
	lea	ecx, DWORD PTR $T802609[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?recAlloc@@YAXXZ$4:
	lea	ecx, DWORD PTR $T802611[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?recAlloc@@YAXXZ$5:
	lea	ecx, DWORD PTR $T802613[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?recAlloc@@YAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?recAlloc@@YAXXZ
	jmp	___CxxFrameHandler3
?recAlloc@@YAXXZ ENDP					; recAlloc
PUBLIC	?recBREAK@OpcodeImpl@Dynarec@R5900@@YAXXZ	; R5900::Dynarec::OpcodeImpl::recBREAK
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?recBREAK@OpcodeImpl@Dynarec@R5900@@YAXXZ PROC		; R5900::Dynarec::OpcodeImpl::recBREAK

; 898  : 	MOV32ItoM( (uptr)&cpuRegs.code, cpuRegs.code );

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+684
	mov	eax, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
	mov	BYTE PTR [eax], 199			; 000000c7H
	mov	BYTE PTR [eax+1], 5
	inc	eax
	mov	DWORD PTR [eax+1], OFFSET ?cpuRegs@@3UcpuRegisters@@A+684
	inc	eax
	mov	DWORD PTR [eax+4], ecx
	add	eax, 4
	add	eax, 4

; 899  : 	MOV32ItoM( (uptr)&cpuRegs.pc, pc );

	mov	BYTE PTR [eax], 199			; 000000c7H
	inc	eax
	mov	BYTE PTR [eax], 5
	push	ebx
	inc	eax
	push	esi
	mov	DWORD PTR [eax], OFFSET ?cpuRegs@@3UcpuRegisters@@A+680
	push	edi
	mov	edi, DWORD PTR ?pc@@3IA			; pc
	add	eax, 4
	mov	DWORD PTR [eax], edi
	add	eax, 4

; 900  : 	iFlushCall(FLUSH_EVERYTHING);

	push	4095					; 00000fffH
	mov	DWORD PTR ?x86Ptr@@3PAEA, eax		; x86Ptr
	call	?iFlushCall@@YAXH@Z			; iFlushCall

; 901  : 	CALLFunc( (uptr)R5900::Interpreter::OpcodeImpl::BREAK );

	mov	esi, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
	mov	BYTE PTR [esi], 232			; 000000e8H
	mov	eax, OFFSET ?BREAK@OpcodeImpl@Interpreter@R5900@@YAXXZ ; R5900::Interpreter::OpcodeImpl::BREAK
	sub	eax, esi
	inc	esi
	add	esi, 4
	sub	eax, 5
	mov	DWORD PTR [esi-4], eax

; 902  : 
; 903  : 	CMP32ItoM((uptr)&cpuRegs.pc, pc);

	mov	BYTE PTR [esi], 129			; 00000081H
	mov	BYTE PTR [esi+1], 61			; 0000003dH
	inc	esi
	mov	DWORD PTR [esi+1], OFFSET ?cpuRegs@@3UcpuRegisters@@A+680
	inc	esi
	mov	DWORD PTR [esi+4], edi
	add	esi, 4
	add	esi, 4

; 904  : 	j8Ptr[0] = JE8(0);

	mov	BYTE PTR [esi], 116			; 00000074H
	inc	esi
	mov	BYTE PTR [esi], 0
	inc	esi
	lea	eax, DWORD PTR [esi-1]
	add	esp, 4
	mov	DWORD PTR ?j8Ptr@@3PAPAEA, eax

; 905  : 	ADD32ItoM((uptr)&cpuRegs.cycle, eeScaleBlockCycles());

	call	?eeScaleBlockCycles@@YAIXZ		; eeScaleBlockCycles
	mov	BYTE PTR [esi], 129			; 00000081H
	inc	esi
	mov	BYTE PTR [esi], 5
	inc	esi
	mov	DWORD PTR [esi], OFFSET ?cpuRegs@@3UcpuRegisters@@A+960
	add	esi, 4
	mov	DWORD PTR [esi], eax
	add	esi, 4

; 906  : 	RET();

	mov	BYTE PTR [esi], 195			; 000000c3H

; 907  : 	x86SetJ8(j8Ptr[0]);

	mov	eax, DWORD PTR ?j8Ptr@@3PAPAEA
	inc	esi
	mov	DWORD PTR ?x86Ptr@@3PAEA, esi		; x86Ptr
	sub	esi, eax
	dec	esi
	mov	ebx, esi
	mov	edi, eax
	cmp	ebx, 127				; 0000007fH
	jbe	SHORT $LN74@recBREAK
	mov	esi, OFFSET ??_C@_0BH@PGICDMIF@j8?5greater?5than?50x7f?$CB?$CB?$AA@
	call	?Error@Console@@YA_NPBD@Z		; Console::Error
$LN74@recBREAK:
	mov	BYTE PTR [edi], bl
	pop	edi
	pop	esi
	pop	ebx

; 908  : 	//branch = 2;
; 909  : }

	ret	0
?recBREAK@OpcodeImpl@Dynarec@R5900@@YAXXZ ENDP		; R5900::Dynarec::OpcodeImpl::recBREAK
_TEXT	ENDS
PUBLIC	?recSYSCALL@OpcodeImpl@Dynarec@R5900@@YAXXZ	; R5900::Dynarec::OpcodeImpl::recSYSCALL
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?recSYSCALL@OpcodeImpl@Dynarec@R5900@@YAXXZ PROC	; R5900::Dynarec::OpcodeImpl::recSYSCALL

; 883  : 	MOV32ItoM( (uptr)&cpuRegs.code, cpuRegs.code );

	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+684
	mov	eax, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
	mov	BYTE PTR [eax], 199			; 000000c7H
	mov	BYTE PTR [eax+1], 5
	inc	eax
	mov	DWORD PTR [eax+1], OFFSET ?cpuRegs@@3UcpuRegisters@@A+684
	inc	eax
	mov	DWORD PTR [eax+4], ecx
	add	eax, 4
	add	eax, 4

; 884  : 	MOV32ItoM( (uptr)&cpuRegs.pc, pc );

	mov	BYTE PTR [eax], 199			; 000000c7H
	inc	eax
	mov	BYTE PTR [eax], 5
	push	ebx
	inc	eax
	push	esi
	mov	DWORD PTR [eax], OFFSET ?cpuRegs@@3UcpuRegisters@@A+680
	push	edi
	mov	edi, DWORD PTR ?pc@@3IA			; pc
	add	eax, 4
	mov	DWORD PTR [eax], edi
	add	eax, 4

; 885  : 	iFlushCall(FLUSH_NODESTROY);

	push	43					; 0000002bH
	mov	DWORD PTR ?x86Ptr@@3PAEA, eax		; x86Ptr
	call	?iFlushCall@@YAXH@Z			; iFlushCall

; 886  : 	CALLFunc( (uptr)R5900::Interpreter::OpcodeImpl::SYSCALL );

	mov	esi, DWORD PTR ?x86Ptr@@3PAEA		; x86Ptr
	mov	BYTE PTR [esi], 232			; 000000e8H
	mov	eax, OFFSET ?SYSCALL@OpcodeImpl@Interpreter@R5900@@YAXXZ ; R5900::Interpreter::OpcodeImpl::SYSCALL
	sub	eax, esi
	inc	esi
	add	esi, 4
	sub	eax, 5
	mov	DWORD PTR [esi-4], eax

; 887  : 
; 888  : 	CMP32ItoM((uptr)&cpuRegs.pc, pc);

	mov	BYTE PTR [esi], 129			; 00000081H
	mov	BYTE PTR [esi+1], 61			; 0000003dH
	inc	esi
	mov	DWORD PTR [esi+1], OFFSET ?cpuRegs@@3UcpuRegisters@@A+680
	inc	esi
	mov	DWORD PTR [esi+4], edi
	add	esi, 4
	add	esi, 4

; 889  : 	j8Ptr[0] = JE8(0);

	mov	BYTE PTR [esi], 116			; 00000074H
	inc	esi
	mov	BYTE PTR [esi], 0
	inc	esi
	lea	eax, DWORD PTR [esi-1]
	add	esp, 4
	mov	DWORD PTR ?j8Ptr@@3PAPAEA, eax

; 890  : 	ADD32ItoM((uptr)&cpuRegs.cycle, eeScaleBlockCycles());

	call	?eeScaleBlockCycles@@YAIXZ		; eeScaleBlockCycles
	mov	BYTE PTR [esi], 129			; 00000081H
	mov	BYTE PTR [esi+1], 5
	inc	esi
	inc	esi
	mov	DWORD PTR [esi], OFFSET ?cpuRegs@@3UcpuRegisters@@A+960
	mov	DWORD PTR [esi+4], eax
	add	esi, 4
	add	esi, 4

; 891  : 	JMP32((uptr)DispatcherReg - ( (uptr)x86Ptr + 5 ));

	mov	BYTE PTR [esi], 233			; 000000e9H
	mov	eax, OFFSET ?DispatcherReg@@YAXXZ	; DispatcherReg
	sub	eax, esi
	inc	esi
	sub	eax, 5
	mov	DWORD PTR [esi], eax

; 892  : 	x86SetJ8(j8Ptr[0]);

	mov	eax, DWORD PTR ?j8Ptr@@3PAPAEA
	add	esi, 4
	mov	DWORD PTR ?x86Ptr@@3PAEA, esi		; x86Ptr
	sub	esi, eax
	dec	esi
	mov	ebx, esi
	mov	edi, eax
	cmp	ebx, 127				; 0000007fH
	jbe	SHORT $LN76@recSYSCALL
	mov	esi, OFFSET ??_C@_0BH@PGICDMIF@j8?5greater?5than?50x7f?$CB?$CB?$AA@
	call	?Error@Console@@YA_NPBD@Z		; Console::Error
$LN76@recSYSCALL:
	mov	BYTE PTR [edi], bl
	pop	edi
	pop	esi
	pop	ebx

; 893  : 	//branch = 2;
; 894  : }

	ret	0
?recSYSCALL@OpcodeImpl@Dynarec@R5900@@YAXXZ ENDP	; R5900::Dynarec::OpcodeImpl::recSYSCALL
; Function compile flags: /Ogtpy
_retval$867297 = -29					; size = 1
_vsyncEvent$867394 = -29				; size = 1
_result$867323 = -28					; size = 4
_sDeltaTime$867344 = -28				; size = 8
_i$867298 = -28						; size = 4
_count$867354 = -20					; size = 8
_count$867359 = -12					; size = 8
?recEventTest@@YA_NXZ PROC				; recEventTest

; 639  : {

	sub	esp, 36					; 00000024H

; 640  : #ifdef PCSX2_DEVBUILD
; 641  :     // dont' remove this check unless doing an official release
; 642  :     if( g_globalXMMSaved || g_globalMMXSaved)

	cmp	BYTE PTR ?g_globalXMMSaved@@3EA, 0	; g_globalXMMSaved
	push	ebx
	push	ebp
	push	esi
	push	edi
	jne	SHORT $LN1@recEventTe
	cmp	BYTE PTR ?g_globalMMXSaved@@3EA, 0	; g_globalMMXSaved
	je	SHORT $LN2@recEventTe
$LN1@recEventTe:

; 643  : 		DevCon::Error("Pcsx2 Foopah!  Frozen regs have not been restored!!!");

	mov	esi, OFFSET ??_C@_0DF@HHKJLMIF@Pcsx2?5Foopah?$CB?5?5Frozen?5regs?5have?5@
	call	?Error@Console@@YA_NPBD@Z		; Console::Error
$LN2@recEventTe:

; 644  : 	assert( !g_globalXMMSaved && !g_globalMMXSaved);
; 645  : #endif
; 646  : 
; 647  : 	// Perform counters, ints, and IOP updates:
; 648  : 	bool retval = _cpuBranchTest_Shared();

	mov	ebp, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	eax, DWORD PTR _eeWaitCycles
	add	eax, ebp
	mov	ecx, ebp
	sub	ecx, DWORD PTR ?EEoCycle@@3IA		; EEoCycle
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
	mov	eax, DWORD PTR ?EEsCycle@@3HA		; EEsCycle
	add	eax, ecx
	mov	esi, 1
	mov	BYTE PTR ?eeEventTestIsActive@@3_NA, 1	; eeEventTestIsActive
	mov	DWORD PTR ?EEsCycle@@3HA, eax		; EEsCycle
	mov	DWORD PTR ?EEoCycle@@3IA, ebp		; EEoCycle
	test	eax, eax
	jle	SHORT $LN12@recEventTe
	mov	BYTE PTR ?iopBranchAction@@3_NA, 1	; iopBranchAction
$LN12@recEventTe:
	mov	eax, DWORD PTR ?counters@@3PAUCounter@@A+188
	mov	edx, ebp
	sub	edx, eax
	cmp	edx, DWORD PTR ?counters@@3PAUCounter@@A+192
	mov	BYTE PTR _vsyncEvent$867394[esp+52], 0
	jl	SHORT $LN479@recEventTe
	test	BYTE PTR ?counters@@3PAUCounter@@A+164, 1
	je	$LN20@recEventTe
	push	eax
	push	0
	call	?rcntStartGate@@YIX_NI@Z		; rcntStartGate
	push	0
	call	?psxCheckStartGate16@@YAXH@Z		; psxCheckStartGate16
	mov	eax, DWORD PTR _vSyncInfo+20
	mov	ecx, DWORD PTR _vSyncInfo+16
	mov	ebp, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	add	esp, 4
	add	DWORD PTR ?counters@@3PAUCounter@@A+188, eax
	mov	DWORD PTR ?counters@@3PAUCounter@@A+192, ecx
	mov	DWORD PTR ?counters@@3PAUCounter@@A+164, 0
$LN479@recEventTe:
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
$LN19@recEventTe:
	mov	eax, ebp
	sub	eax, DWORD PTR ?nextsCounter@@3IA	; nextsCounter
	cmp	eax, DWORD PTR ?nextCounter@@3HA	; nextCounter
	jl	$LN192@recEventTe
	mov	ecx, DWORD PTR ?counters@@3PAUCounter@@A+228
	mov	eax, ebp
	sub	eax, ecx
	cmp	eax, DWORD PTR ?counters@@3PAUCounter@@A+232
	jl	$LN513@recEventTe
	cmp	DWORD PTR ?counters@@3PAUCounter@@A+204, 3
	mov	esi, ecx
	jne	$LN44@recEventTe
	test	DWORD PTR ?varLog@@3IA, 1073741824	; varLog, 40000000H
	je	SHORT $LN53@recEventTe
	mov	ecx, DWORD PTR _iFrame
	push	ecx
	push	OFFSET ??_C@_0DK@GPMLIACH@?1?1?1?1?1?1?1?1?1?5?5EE?5COUNTER?5VSYNC?5END?5@
	call	?SrcLog_EECNT@@YA_NPBDZZ		; SrcLog_EECNT
	add	esp, 8
$LN53@recEventTe:
	inc	DWORD PTR _iFrame
	cmp	DWORD PTR ?g_vu1SkipCount@@3IA, 0	; g_vu1SkipCount
	jbe	$LN50@recEventTe
	push	0
	call	?gsPostVsyncEnd@@YAX_N@Z		; gsPostVsyncEnd
	add	esp, 4
	mov	ecx, OFFSET ?g_vu1SkipCount@@3IA	; g_vu1SkipCount
	mov	eax, -1
	lock	 xadd	 DWORD PTR [ecx], eax
	mov	DWORD PTR _result$867323[esp+52], eax
	mov	DWORD PTR ?CpuVU1@@3UVUmicroCpu@@A+8, OFFSET ?DummyExecuteVU1Block@@YAXXZ ; DummyExecuteVU1Block
	jmp	$LN65@recEventTe
$LN20@recEventTe:
	test	BYTE PTR ?CSRw@@3IA, 4
	je	SHORT $LN18@recEventTe
	mov	edx, DWORD PTR ?g_RealGSMem@@3PAEA+4100
	or	DWORD PTR ?g_RealGSMem@@3PAEA+4096, 4
	mov	DWORD PTR ?g_RealGSMem@@3PAEA+4100, edx
$LN18@recEventTe:
	test	DWORD PTR ?g_RealGSMem@@3PAEA+4112, 1024 ; 00000400H
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	jne	SHORT $LN28@recEventTe
	or	DWORD PTR [edi+61440], esi
	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
	mov	ebp, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
$LN28@recEventTe:
	cmp	DWORD PTR ?gates@@3HA, 0		; gates
	je	SHORT $LN16@recEventTe
	mov	eax, DWORD PTR ?counters@@3PAUCounter@@A+188
	push	eax
	push	0
	call	?rcntEndGate@@YIX_NI@Z			; rcntEndGate
	mov	ebp, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
$LN16@recEventTe:
	cmp	BYTE PTR ?psxhblankgate@@3EA, 0		; psxhblankgate
	je	SHORT $LN30@recEventTe
	xor	eax, eax
	call	?_psxCheckEndGate@@YAXH@Z		; _psxCheckEndGate
	mov	ebp, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
$LN30@recEventTe:
	mov	ecx, DWORD PTR _vSyncInfo+16
	mov	edx, DWORD PTR _vSyncInfo+20
	add	DWORD PTR ?counters@@3PAUCounter@@A+188, ecx
	mov	DWORD PTR ?counters@@3PAUCounter@@A+192, edx
	mov	DWORD PTR ?counters@@3PAUCounter@@A+164, esi
	jmp	$LN19@recEventTe
$LN50@recEventTe:
	push	1
	call	?gsPostVsyncEnd@@YAX_N@Z		; gsPostVsyncEnd
	add	esp, 4
	test	BYTE PTR ?g_Session@@3USessionOverrideFlags@@A, 4 ; g_Session
	jne	SHORT $LN64@recEventTe
	test	BYTE PTR ?Config@@3UPcsxConfig@@A+3576, 64 ; 00000040H
	je	SHORT $LN64@recEventTe
	mov	edx, DWORD PTR ?recVU1@@3UVUmicroCpu@@B+8
	mov	DWORD PTR ?CpuVU1@@3UVUmicroCpu@@A+8, edx
	jmp	SHORT $LN65@recEventTe
$LN64@recEventTe:
	mov	eax, DWORD PTR ?intVU1@@3UVUmicroCpu@@B+8
	mov	DWORD PTR ?CpuVU1@@3UVUmicroCpu@@A+8, eax
$LN65@recEventTe:
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	or	DWORD PTR [edi+61440], 8
	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
	mov	eax, DWORD PTR ?psxH@@3PAEA		; psxH
	or	DWORD PTR [eax+4208], 2048		; 00000800H
	test	BYTE PTR ?psxvblankgate@@3EA, 2		; psxvblankgate
	je	SHORT $LN72@recEventTe
	mov	eax, 1
	call	?_psxCheckEndGate@@YAXH@Z		; _psxCheckEndGate
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
$LN72@recEventTe:
	test	BYTE PTR ?psxvblankgate@@3EA, 8		; psxvblankgate
	je	SHORT $LN74@recEventTe
	mov	eax, 3
	call	?_psxCheckEndGate@@YAXH@Z		; _psxCheckEndGate
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
$LN74@recEventTe:
	cmp	DWORD PTR ?gates@@3HA, 0		; gates
	je	SHORT $LN48@recEventTe
	push	esi
	push	1
	call	?rcntEndGate@@YIX_NI@Z			; rcntEndGate
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
$LN48@recEventTe:
	test	DWORD PTR ?Config@@3UPcsxConfig@@A+3576, 3072 ; 00000c00H
	je	$LN474@recEventTe
	cmp	DWORD PTR ?Config@@3UPcsxConfig@@A+3604, 999 ; 000003e7H
	jge	$LN474@recEventTe
	mov	esi, DWORD PTR _m_iTicks
	add	esi, DWORD PTR _m_iStart
	mov	edi, DWORD PTR _m_iTicks+4
	adc	edi, DWORD PTR _m_iStart+4
	lea	ecx, DWORD PTR _count$867354[esp+52]
	push	ecx
	call	DWORD PTR __imp__QueryPerformanceCounter@4
	mov	edx, DWORD PTR _m_iTicks+4
	mov	ebx, DWORD PTR _count$867354[esp+52]
	mov	eax, DWORD PTR _m_iTicks
	mov	ebp, DWORD PTR _count$867354[esp+56]
	push	0
	push	8
	push	edx
	sub	ebx, esi
	push	eax
	sbb	ebp, edi
	call	__allmul
	cmp	ebp, edx
	jl	SHORT $LN78@recEventTe
	jg	SHORT $LN472@recEventTe
	cmp	ebx, eax
	jbe	SHORT $LN78@recEventTe
$LN472@recEventTe:
	mov	eax, DWORD PTR _count$867354[esp+52]
	sub	eax, DWORD PTR _m_iTicks
	mov	ecx, DWORD PTR _count$867354[esp+56]
	sbb	ecx, DWORD PTR _m_iTicks+4
	mov	DWORD PTR _m_iStart, eax
	sub	eax, esi
	mov	DWORD PTR _m_iStart+4, ecx
	call	?gsSyncLimiterLostTime@@YAXH@Z		; gsSyncLimiterLostTime
	jmp	SHORT $LN480@recEventTe
$LN78@recEventTe:
	mov	DWORD PTR _m_iStart, esi
	mov	DWORD PTR _m_iStart+4, edi
	test	ebp, ebp
	jg	SHORT $LN480@recEventTe
	jl	SHORT $LN475@recEventTe
	test	ebx, ebx
	jae	SHORT $LN480@recEventTe
$LN475@recEventTe:
	mov	ebx, DWORD PTR __imp__Sleep@4
	mov	ebp, DWORD PTR __imp__QueryPerformanceCounter@4
$LL77@recEventTe:
	push	0
	call	ebx
	lea	ecx, DWORD PTR _count$867359[esp+52]
	push	ecx
	call	ebp
	mov	eax, DWORD PTR _count$867359[esp+52]
	mov	edx, DWORD PTR _count$867359[esp+56]
	sub	eax, esi
	sbb	edx, edi
	mov	DWORD PTR _sDeltaTime$867344[esp+56], edx
	js	SHORT $LL77@recEventTe
	jg	SHORT $LN480@recEventTe
	test	eax, eax
	jb	SHORT $LL77@recEventTe
$LN480@recEventTe:
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
$LN474@recEventTe:
	mov	eax, DWORD PTR _vSyncInfo+8
	mov	ecx, DWORD PTR _vSyncInfo+4
	add	DWORD PTR ?counters@@3PAUCounter@@A+228, eax
	mov	ebp, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	DWORD PTR ?counters@@3PAUCounter@@A+232, ecx
	mov	DWORD PTR ?counters@@3PAUCounter@@A+204, 0
	mov	BYTE PTR _retval$867297[esp+52], 1
	jmp	$LN46@recEventTe
$LN44@recEventTe:
	test	DWORD PTR ?varLog@@3IA, 1073741824	; varLog, 40000000H
	je	SHORT $LN95@recEventTe
	mov	edx, DWORD PTR _iFrame
	push	edx
	push	OFFSET ??_C@_0DM@NMBMHAFB@?1?1?1?1?1?1?1?1?1?5?5EE?5COUNTER?5VSYNC?5STAR@
	call	?SrcLog_EECNT@@YA_NPBDZZ		; SrcLog_EECNT
	add	esp, 8
$LN95@recEventTe:
	call	?vSyncDebugStuff@@YAXXZ			; vSyncDebugStuff
	test	BYTE PTR ?CSRw@@3IA, 8
	je	SHORT $LN92@recEventTe
	mov	eax, DWORD PTR ?g_RealGSMem@@3PAEA+4100
	or	DWORD PTR ?g_RealGSMem@@3PAEA+4096, 8
	mov	DWORD PTR ?g_RealGSMem@@3PAEA+4100, eax
$LN92@recEventTe:
	test	DWORD PTR ?g_RealGSMem@@3PAEA+4112, 2048 ; 00000800H
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	mov	ebx, 1
	jne	SHORT $LN98@recEventTe
	or	DWORD PTR [edi+61440], ebx
	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
$LN98@recEventTe:
	or	DWORD PTR [edi+61440], 4
	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
	call	?cdvdVsync@@YAXXZ			; cdvdVsync
	mov	eax, DWORD PTR ?psxH@@3PAEA		; psxH
	or	DWORD PTR [eax+4208], ebx
	test	BYTE PTR ?psxvblankgate@@3EA, 2		; psxvblankgate
	je	SHORT $LN103@recEventTe
	push	ebx
	call	?psxCheckStartGate16@@YAXH@Z		; psxCheckStartGate16
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	add	esp, 4
$LN103@recEventTe:
	test	BYTE PTR ?psxvblankgate@@3EA, 8		; psxvblankgate
	je	SHORT $LN125@recEventTe
	mov	eax, 3
	call	?_psxCheckStartGate@@YAXH@Z		; _psxCheckStartGate
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
$LN125@recEventTe:
	cmp	DWORD PTR ?gates@@3HA, 0		; gates
	je	SHORT $LN90@recEventTe
	push	esi
	push	ebx
	call	?rcntStartGate@@YIX_NI@Z		; rcntStartGate
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
$LN90@recEventTe:
	cmp	DWORD PTR ?Config@@3UPcsxConfig@@A+3596, 0
	je	SHORT $LN127@recEventTe
	xor	ebp, ebp
	cmp	DWORD PTR ?patchnumber@@3HA, ebp	; patchnumber
	jle	SHORT $LN127@recEventTe
	mov	esi, OFFSET ?patch@@3PAUIniPatch@@A	; patch
	npad	4
$LL129@recEventTe:
	cmp	DWORD PTR [esi+16], ebx
	jne	SHORT $LN128@recEventTe
	mov	eax, esi
	call	?_applypatch@@YAXHPAUIniPatch@@@Z	; _applypatch
$LN128@recEventTe:
	add	ebp, ebx
	add	esi, 32					; 00000020H
	cmp	ebp, DWORD PTR ?patchnumber@@3HA	; patchnumber
	jl	SHORT $LL129@recEventTe
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
$LN127@recEventTe:
	mov	ecx, DWORD PTR _vSyncInfo+4
	mov	edx, DWORD PTR _vSyncInfo+8
	mov	eax, DWORD PTR _vSyncInfo+12
	add	DWORD PTR ?counters@@3PAUCounter@@A+228, ecx
	add	DWORD PTR ?counters@@3PAUCounter@@A+188, eax
	mov	ebp, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	DWORD PTR ?counters@@3PAUCounter@@A+232, edx
	mov	DWORD PTR ?counters@@3PAUCounter@@A+204, 3
$LN513@recEventTe:
	mov	BYTE PTR _retval$867297[esp+52], 0
$LN46@recEventTe:
	mov	DWORD PTR _i$867298[esp+52], 0
	mov	esi, OFFSET ?counters@@3PAUCounter@@A+4
$LL40@recEventTe:
	mov	eax, DWORD PTR [esi]
	test	al, al
	jns	$LN39@recEventTe
	and	eax, 3
	cmp	al, 3
	je	$LN36@recEventTe
	mov	ecx, ebp
	sub	ecx, DWORD PTR [esi+32]
	jns	SHORT $LN35@recEventTe
	xor	ecx, ecx
$LN35@recEventTe:
	mov	ebx, DWORD PTR [esi+12]
	xor	edx, edx
	mov	eax, ecx
	div	ebx
	mov	edx, ebp
	add	DWORD PTR [esi-4], eax
	imul	eax, ebx
	sub	ecx, eax
	mov	eax, DWORD PTR [esi+4]
	sub	edx, ecx
	mov	ecx, DWORD PTR [esi-4]
	mov	DWORD PTR [esi+32], edx
	cmp	ecx, eax
	jb	SHORT $LN160@recEventTe
	mov	edx, DWORD PTR [esi]
	test	edx, 256				; 00000100H
	je	SHORT $LN163@recEventTe
	test	DWORD PTR ?varLog@@3IA, 1073741824	; varLog, 40000000H
	je	SHORT $LN167@recEventTe
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _i$867298[esp+60]
	mov	eax, edx
	push	eax
	push	ecx
	push	OFFSET ??_C@_0DO@EGNLMAGK@EE?5Counter?$FL?$CFd?$FN?5TARGET?5reached?5?9?5@
	call	?SrcLog_EECNT@@YA_NPBDZZ		; SrcLog_EECNT
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	add	esp, 20					; 00000014H
$LN167@recEventTe:
	mov	ecx, DWORD PTR [esi+16]
	or	DWORD PTR [esi], 1024			; 00000400H
	mov	edx, 1
	shl	edx, cl
	or	DWORD PTR [edi+61440], edx
	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
	mov	eax, DWORD PTR [esi]
	mov	ebp, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	test	al, 64					; 00000040H
	je	SHORT $LN162@recEventTe
	mov	eax, DWORD PTR [esi+4]
	sub	DWORD PTR [esi-4], eax
	jmp	SHORT $LN160@recEventTe
$LN162@recEventTe:
	or	DWORD PTR [esi+4], 268435456		; 10000000H
	jmp	SHORT $LN160@recEventTe
$LN163@recEventTe:
	or	eax, 268435456				; 10000000H
	mov	DWORD PTR [esi+4], eax
$LN160@recEventTe:
	mov	eax, DWORD PTR [esi-4]
	cmp	eax, 65535				; 0000ffffH
	jbe	SHORT $LN39@recEventTe
	mov	ecx, DWORD PTR [esi]
	test	ecx, 512				; 00000200H
	je	SHORT $LN175@recEventTe
	test	DWORD PTR ?varLog@@3IA, 1073741824	; varLog, 40000000H
	je	SHORT $LN174@recEventTe
	mov	edx, DWORD PTR _i$867298[esp+52]
	push	eax
	push	ecx
	push	edx
	push	OFFSET ??_C@_0CN@DJCFHOEE@EE?5Counter?$FL?$CFd?$FN?5OVERFLOW?5?9?5mode?$DN?$CF@
	call	?SrcLog_EECNT@@YA_NPBDZZ		; SrcLog_EECNT
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	add	esp, 16					; 00000010H
$LN174@recEventTe:
	mov	ecx, DWORD PTR [esi+16]
	or	DWORD PTR [esi], 2048			; 00000800H
	mov	eax, 1
	shl	eax, cl
	or	DWORD PTR [edi+61440], eax
	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
	mov	ebp, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
$LN175@recEventTe:
	add	DWORD PTR [esi-4], -65536		; ffff0000H
	xor	ecx, ecx
	mov	WORD PTR [esi+6], cx
	jmp	SHORT $LN39@recEventTe
$LN36@recEventTe:
	mov	DWORD PTR [esi+32], ebp
$LN39@recEventTe:
	inc	DWORD PTR _i$867298[esp+52]
	add	esi, 40					; 00000028H
	cmp	esi, OFFSET ?counters@@3PAUCounter@@A+124
	jle	$LL40@recEventTe
	mov	ebx, DWORD PTR ?counters@@3PAUCounter@@A+232
	sub	ebx, ebp
	add	ebx, DWORD PTR ?counters@@3PAUCounter@@A+228
	mov	DWORD PTR ?nextsCounter@@3IA, ebp	; nextsCounter
	mov	DWORD PTR ?nextCounter@@3HA, ebx	; nextCounter
	mov	edx, OFFSET ?counters@@3PAUCounter@@A+8
$LL180@recEventTe:
	mov	eax, DWORD PTR [edx-4]
	test	al, al
	jns	SHORT $LN179@recEventTe
	and	eax, 3
	cmp	al, 3
	je	SHORT $LN179@recEventTe
	mov	esi, DWORD PTR [edx-8]
	cmp	esi, 65536				; 00010000H
	ja	SHORT $LN186@recEventTe
	mov	ecx, DWORD PTR [edx]
	cmp	esi, ecx
	ja	SHORT $LN186@recEventTe
	mov	ebx, DWORD PTR [edx+8]
	mov	eax, 65536				; 00010000H
	sub	eax, esi
	imul	eax, ebx
	mov	ebx, DWORD PTR ?nextCounter@@3HA	; nextCounter
	sub	eax, ebp
	add	eax, DWORD PTR [edx+28]
	cmp	eax, ebx
	jge	SHORT $LN185@recEventTe
	mov	ebx, eax
	mov	DWORD PTR ?nextCounter@@3HA, ebx	; nextCounter
$LN185@recEventTe:
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN179@recEventTe
	sub	ecx, esi
	imul	ecx, DWORD PTR [edx+8]
	sub	ecx, ebp
	add	ecx, DWORD PTR [edx+28]
	cmp	ecx, ebx
	jge	SHORT $LN179@recEventTe
	mov	ebx, ecx
	jmp	SHORT $LN514@recEventTe
$LN186@recEventTe:
	mov	ebx, 4
$LN514@recEventTe:
	mov	DWORD PTR ?nextCounter@@3HA, ebx	; nextCounter
$LN179@recEventTe:
	add	edx, 40					; 00000028H
	cmp	edx, OFFSET ?counters@@3PAUCounter@@A+168
	jl	SHORT $LL180@recEventTe
	test	ebx, ebx
	jge	SHORT $LN177@recEventTe
	mov	DWORD PTR ?nextCounter@@3HA, 0		; nextCounter
$LN177@recEventTe:
	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+688
	mov	dl, BYTE PTR _retval$867297[esp+52]
	mov	ecx, eax
	and	ecx, -2147482656			; 800003e0H
	mov	BYTE PTR _vsyncEvent$867394[esp+52], dl
	cmp	ecx, -2147483616			; 80000020H
	jne	SHORT $LN193@recEventTe
	mov	edx, ebp
	sub	edx, DWORD PTR ?s_iLastPERFCycle@@3PAIA
	mov	DWORD PTR ?s_iLastPERFCycle@@3PAIA, ebp
	add	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+692, edx
$LN193@recEventTe:
	and	eax, -2146467840			; 800f8000H
	cmp	eax, -2147450880			; 80008000H
	jne	SHORT $LN192@recEventTe
	mov	eax, ebp
	sub	eax, DWORD PTR ?s_iLastPERFCycle@@3PAIA+4
	mov	DWORD PTR ?s_iLastPERFCycle@@3PAIA+4, ebp
	add	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+696, eax
$LN192@recEventTe:
	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+580
	mov	ecx, ebp
	sub	ecx, DWORD PTR ?s_iLastCOP0Cycle@@3IA	; s_iLastCOP0Cycle
	mov	DWORD PTR ?s_iLastCOP0Cycle@@3IA, ebp	; s_iLastCOP0Cycle
	add	eax, ecx
	test	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+592, 32768 ; 00008000H
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+580, eax
	je	SHORT $LN196@recEventTe
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+588
	cmp	eax, ecx
	jb	SHORT $LN196@recEventTe
	lea	edx, DWORD PTR [ecx+1000]
	cmp	eax, edx
	jae	SHORT $LN196@recEventTe
	push	ecx
	push	eax
	push	0
	push	OFFSET ??_C@_0BC@KKHOMMCD@timr?5intr?3?5?$CFx?0?5?$CFx?$AA@
	call	?Status@Console@@YA_NPBDPBU_VARG_PARAM@@ZZ ; Console::Status
	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+968
	push	eax
	push	8421376					; 00808000H
	call	?cpuException@@YAXII@Z			; cpuException
	mov	ebp, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	add	esp, 24					; 00000018H
$LN196@recEventTe:
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
	test	edx, 1073741823				; 3fffffffH
	je	$LN396@recEventTe
	mov	ebx, -257				; fffffeffH
	test	dl, 2
	je	$LN245@recEventTe
	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+836
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+708
	mov	esi, ebp
	sub	esi, eax
	cmp	esi, ecx
	jl	$LN203@recEventTe
	and	edx, -3					; fffffffdH
	test	DWORD PTR ?varLog@@3IA, 1024		; varLog, 00000400H
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, edx
	je	SHORT $LN226@recEventTe
	push	ebp
	push	OFFSET ??_C@_0BG@OEMEHKAM@vif1Interrupt?3?5?$CF8?48x?6?$AA@
	call	?SrcLog_VIF@@YA_NPBDZZ			; SrcLog_VIF
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	add	esp, 8
$LN226@recEventTe:
	xor	esi, esi
	mov	DWORD PTR ?g_vifCycles@@3HA, esi	; g_vifCycles
	cmp	DWORD PTR ?vif1@@3UvifStruct@@A+20, esi
	je	$LN221@recEventTe
	cmp	DWORD PTR ?vif1@@3UvifStruct@@A+4, esi
	jne	$LN221@recEventTe
	or	DWORD PTR [edi+15360], 2048		; 00000800H
	or	DWORD PTR [edi+61440], 32		; 00000020H
	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
	dec	DWORD PTR ?vif1@@3UvifStruct@@A+20
	mov	eax, DWORD PTR [edi+15360]
	test	eax, 1792				; 00000700H
	je	SHORT $LN222@recEventTe
	and	eax, -520093697				; e0ffffffH
	and	DWORD PTR [edi+36864], ebx
	mov	DWORD PTR [edi+15360], eax
	mov	ebp, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	jmp	SHORT $LN245@recEventTe
$LN222@recEventTe:
	cmp	WORD PTR [edi+36896], si
	ja	SHORT $LN220@recEventTe
	cmp	BYTE PTR ?vif1@@3UvifStruct@@A+36, 0
	jbe	$LN221@recEventTe
$LN220@recEventTe:
	cmp	BYTE PTR ?vif1@@3UvifStruct@@A+35, 1
	jne	SHORT $LN219@recEventTe
$LN215@recEventTe:
	call	?_chainVIF1@@YAHXZ			; _chainVIF1
	jmp	SHORT $LN218@recEventTe
$LN219@recEventTe:
	call	?_VIF1chain@@YAHXZ			; _VIF1chain
$LN218@recEventTe:
	mov	eax, DWORD PTR ?g_vifCycles@@3HA	; g_vifCycles
	or	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, 2
	cmp	eax, 28					; 0000001cH
	mov	ebp, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+836, ebp
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+708, eax
	jg	SHORT $LN237@recEventTe
	mov	ecx, DWORD PTR ?psxCycleEE@@3HA		; psxCycleEE
	cmp	ecx, esi
	jle	SHORT $LN237@recEventTe
	add	DWORD PTR ?psxBreak@@3HA, ecx		; psxBreak
	mov	DWORD PTR ?psxCycleEE@@3HA, esi		; psxCycleEE
$LN237@recEventTe:
	mov	ecx, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	ecx, ebp
	cmp	ecx, eax
	jle	SHORT $LN483@recEventTe
	add	eax, ebp
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
$LN483@recEventTe:
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
$LN245@recEventTe:
	test	BYTE PTR ?cpuRegs@@3UcpuRegisters@@A+964, 4
	je	$LN273@recEventTe
	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+840
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+712
	mov	edx, ebp
	sub	edx, eax
	cmp	edx, ecx
	jl	$LN249@recEventTe
	and	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, -5 ; fffffffbH
	test	DWORD PTR ?varLog@@3IA, 4096		; varLog, 00001000H
	je	SHORT $LN264@recEventTe
	push	ebp
	push	OFFSET ??_C@_0BE@FPDFMCPK@gsInterrupt?3?5?$CF8?48x?6?$AA@
	call	?SrcLog_GIF@@YA_NPBDZZ			; SrcLog_GIF
	mov	ebp, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	add	esp, 8
$LN264@recEventTe:
	test	DWORD PTR [edi+40960], 256		; 00000100H
	je	$LN273@recEventTe
	xor	esi, esi
	cmp	WORD PTR [edi+40992], si
	ja	SHORT $LN259@recEventTe
	cmp	DWORD PTR _gspath3done, esi
	jne	$LN257@recEventTe
$LN259@recEventTe:
	test	BYTE PTR [edi+57344], 1
	jne	$LN258@recEventTe
	mov	esi, OFFSET ??_C@_0CA@OMBBMBNE@gs?5dma?5masked?0?5re?9scheduling?4?4?4?$AA@
	call	?Notice@Console@@YA_NPBD@Z		; Console::Notice
	mov	ebp, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	eax, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	or	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, 4
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	sub	eax, ebp
	cmp	eax, 64					; 00000040H
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+840, ebp
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+712, 64 ; 00000040H
	jle	$LN273@recEventTe
	lea	ecx, DWORD PTR [ebp+64]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
	jmp	$LN273@recEventTe
$LN221@recEventTe:
	mov	eax, DWORD PTR [edi+36864]
	test	eax, 256				; 00000100H
	jne	SHORT $LN217@recEventTe
	push	eax
	push	OFFSET ??_C@_0BO@KFAMBPHK@Vif1?5running?5when?5CHCR?5?$DN?$DN?5?$CFx?6?$AA@
	call	?SysPrintf@@YAXPBDZZ			; SysPrintf
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	add	esp, 8
$LN217@recEventTe:
	mov	edx, DWORD PTR [edi+36864]
	and	edx, 260				; 00000104H
	cmp	edx, 260				; 00000104H
	jne	SHORT $LN216@recEventTe
	cmp	BYTE PTR ?vif1@@3UvifStruct@@A+33, 0
	jne	SHORT $LN216@recEventTe
	test	BYTE PTR [edi+57344], 1
	jne	$LN215@recEventTe
	push	OFFSET ??_C@_0BB@EELLKNKM@vif1?5dma?5masked?6?$AA@
	call	?SysPrintf@@YAXPBDZZ			; SysPrintf
	mov	ebp, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	add	esp, 4
	jmp	$LN483@recEventTe
$LN216@recEventTe:
	cmp	WORD PTR [edi+36896], si
	jbe	SHORT $LN214@recEventTe
	push	OFFSET ??_C@_0BO@OINNBNMI@VIF1?5Ending?5with?5?$CFx?5QWC?5left?6?$AA@
	call	?SysPrintf@@YAXPBDZZ			; SysPrintf
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	add	esp, 4
$LN214@recEventTe:
	mov	eax, DWORD PTR ?vif1@@3UvifStruct@@A+16
	cmp	eax, esi
	je	SHORT $LN213@recEventTe
	push	eax
	push	OFFSET ??_C@_0BH@OMPPLFGP@vif1?4cmd?5still?5set?5?$CFx?6?$AA@
	call	?SysPrintf@@YAXPBDZZ			; SysPrintf
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	add	esp, 8
$LN213@recEventTe:
	and	DWORD PTR [edi+36864], ebx
	mov	ecx, 1
	mov	DWORD PTR _prevviftag, esi
	mov	DWORD PTR _prevvifcycles, esi
	call	?hwDmacIrq@@YAXH@Z			; hwDmacIrq
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	cmp	DWORD PTR [edi+15600], esi
	je	SHORT $LN211@recEventTe
	test	BYTE PTR [edi+36864], 1
	je	SHORT $LN482@recEventTe
$LN211@recEventTe:
	and	DWORD PTR [edi+15360], -520093697	; e0ffffffH
$LN482@recEventTe:
	mov	ebp, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	jmp	$LN245@recEventTe
$LN203@recEventTe:
	mov	edx, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	edx, eax
	cmp	edx, ecx
	jle	$LN245@recEventTe
	add	ecx, eax
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
	jmp	$LN245@recEventTe
$LN258@recEventTe:
	call	?GIFdma@@YAXXZ				; GIFdma
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	cmp	DWORD PTR _gspath3done, esi
	je	SHORT $LN485@recEventTe
$LN257@recEventTe:
	mov	DWORD PTR _gspath3done, esi
	mov	DWORD PTR _gscycles, esi
	and	DWORD PTR [edi+40960], ebx
	mov	edx, DWORD PTR ?g_RealGSMem@@3PAEA+4096
	mov	eax, DWORD PTR ?g_RealGSMem@@3PAEA+4100
	and	edx, -32769				; ffff7fffH
	or	edx, 16384				; 00004000H
	mov	DWORD PTR ?g_RealGSMem@@3PAEA+4096, edx
	mov	DWORD PTR ?g_RealGSMem@@3PAEA+4100, eax
	and	DWORD PTR [edi+12320], -520097281	; e0fff1ffH
	mov	ecx, 2
	mov	DWORD PTR ?Path3transfer@@3HA, esi	; Path3transfer
	call	?hwDmacIrq@@YAXH@Z			; hwDmacIrq
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
$LN485@recEventTe:
	mov	ebp, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
$LN273@recEventTe:
	test	BYTE PTR ?cpuRegs@@3UcpuRegisters@@A+964, 32 ; 00000020H
	je	SHORT $LN287@recEventTe
	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+852
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+724
	mov	edx, ebp
	sub	edx, eax
	cmp	edx, ecx
	jl	SHORT $LN277@recEventTe
	and	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, -33 ; ffffffdfH
	and	DWORD PTR [edi+49152], ebx
	mov	ecx, 5
	call	?hwDmacIrq@@YAXH@Z			; hwDmacIrq
	mov	ebp, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	jmp	SHORT $LN287@recEventTe
$LN249@recEventTe:
	mov	edx, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	edx, eax
	cmp	edx, ecx
	jle	SHORT $LN273@recEventTe
	add	ecx, eax
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
	jmp	SHORT $LN273@recEventTe
$LN277@recEventTe:
	mov	edx, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	edx, eax
	cmp	edx, ecx
	jle	SHORT $LN287@recEventTe
	add	ecx, eax
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
$LN287@recEventTe:
	test	BYTE PTR ?cpuRegs@@3UcpuRegisters@@A+964, 64 ; 00000040H
	je	SHORT $LN301@recEventTe
	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+856
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+728
	mov	edx, ebp
	sub	edx, eax
	cmp	edx, ecx
	jl	SHORT $LN291@recEventTe
	and	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, -65 ; ffffffbfH
	mov	ecx, 6
	call	?hwDmacIrq@@YAXH@Z			; hwDmacIrq
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	and	DWORD PTR [edi+50176], ebx
	mov	ebp, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	jmp	SHORT $LN301@recEventTe
$LN291@recEventTe:
	mov	edx, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	edx, eax
	cmp	edx, ecx
	jle	SHORT $LN301@recEventTe
	add	ecx, eax
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
$LN301@recEventTe:
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
	test	edx, 3865				; 00000f19H
	je	$LN396@recEventTe
	test	dl, 1
	je	SHORT $LN313@recEventTe
	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+832
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+704
	mov	esi, ebp
	sub	esi, eax
	cmp	esi, ecx
	jl	SHORT $LN305@recEventTe
	and	edx, -2					; fffffffeH
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, edx
	call	?vif0Interrupt@@YAXXZ			; vif0Interrupt
	mov	ebp, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	jmp	SHORT $LN313@recEventTe
$LN305@recEventTe:
	mov	edx, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	edx, eax
	cmp	edx, ecx
	jle	SHORT $LN313@recEventTe
	add	ecx, eax
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
$LN313@recEventTe:
	test	BYTE PTR ?cpuRegs@@3UcpuRegisters@@A+964, 8
	je	SHORT $LN325@recEventTe
	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+844
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+716
	mov	edx, ebp
	sub	edx, eax
	cmp	edx, ecx
	jl	SHORT $LN317@recEventTe
	and	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, -9 ; fffffff7H
	call	?ipu0Interrupt@@YAXXZ			; ipu0Interrupt
	mov	ebp, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	jmp	SHORT $LN325@recEventTe
$LN317@recEventTe:
	mov	edx, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	edx, eax
	cmp	edx, ecx
	jle	SHORT $LN325@recEventTe
	add	ecx, eax
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
$LN325@recEventTe:
	test	BYTE PTR ?cpuRegs@@3UcpuRegisters@@A+964, 16 ; 00000010H
	je	$LN345@recEventTe
	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+848
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+720
	mov	edx, ebp
	sub	edx, eax
	cmp	edx, ecx
	jl	SHORT $LN329@recEventTe
	and	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, -17 ; ffffffefH
	test	DWORD PTR ?varLog@@3IA, 16384		; varLog, 00004000H
	je	SHORT $LN342@recEventTe
	push	ebp
	push	OFFSET ??_C@_0BD@IOONBAFN@ipu1Interrupt?5?$CFx?3?6?$AA@
	call	?SrcLog_IPU@@YA_NPBDZZ			; SrcLog_IPU
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	add	esp, 8
$LN342@recEventTe:
	test	BYTE PTR _g_nDMATransfer, 64		; 00000040H
	je	SHORT $LN339@recEventTe
	or	DWORD PTR [edi+61440], 256		; 00000100H
	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
	and	DWORD PTR _g_nDMATransfer, -65		; ffffffbfH
$LN339@recEventTe:
	test	BYTE PTR _g_nDMATransfer, 4
	je	SHORT $LN338@recEventTe
	and	DWORD PTR _g_nDMATransfer, -5		; fffffffbH
	jmp	SHORT $LN337@recEventTe
$LN338@recEventTe:
	and	DWORD PTR [edi+46080], ebx
$LN337@recEventTe:
	mov	ecx, 4
	call	?hwDmacIrq@@YAXH@Z			; hwDmacIrq
	mov	ebp, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	jmp	SHORT $LN345@recEventTe
$LN329@recEventTe:
	mov	edx, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	edx, eax
	cmp	edx, ecx
	jle	SHORT $LN345@recEventTe
	add	ecx, eax
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
$LN345@recEventTe:
	test	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, 256 ; 00000100H
	je	SHORT $LN357@recEventTe
	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+864
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+736
	mov	edx, ebp
	sub	edx, eax
	cmp	edx, ecx
	jl	SHORT $LN349@recEventTe
	and	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, ebx
	call	?SPRFROMinterrupt@@YAXXZ		; SPRFROMinterrupt
	mov	ebp, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	jmp	SHORT $LN357@recEventTe
$LN349@recEventTe:
	mov	edx, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	edx, eax
	cmp	edx, ecx
	jle	SHORT $LN357@recEventTe
	add	ecx, eax
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
$LN357@recEventTe:
	test	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, 512 ; 00000200H
	je	SHORT $LN372@recEventTe
	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+868
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+740
	mov	edx, ebp
	sub	edx, eax
	cmp	edx, ecx
	jl	SHORT $LN361@recEventTe
	and	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, -513 ; fffffdffH
	call	?_dmaSPR1@@YAXXZ			; _dmaSPR1
	cmp	DWORD PTR ?spr1finished@@3HA, 0		; spr1finished
	je	SHORT $LN487@recEventTe
	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
	and	DWORD PTR [eax+54272], ebx
	mov	ecx, 9
	call	?hwDmacIrq@@YAXH@Z			; hwDmacIrq
$LN487@recEventTe:
	mov	ebp, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
$LN372@recEventTe:
	test	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, 1024 ; 00000400H
	je	SHORT $LN384@recEventTe
	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+872
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+744
	mov	edx, ebp
	sub	edx, eax
	cmp	edx, ecx
	jl	SHORT $LN376@recEventTe
	and	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, -1025 ; fffffbffH
	call	?vifMFIFOInterrupt@@YAXXZ		; vifMFIFOInterrupt
	mov	ebp, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	jmp	SHORT $LN384@recEventTe
$LN361@recEventTe:
	mov	edx, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	edx, eax
	cmp	edx, ecx
	jle	SHORT $LN372@recEventTe
	add	ecx, eax
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
	jmp	SHORT $LN372@recEventTe
$LN376@recEventTe:
	mov	edx, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	edx, eax
	cmp	edx, ecx
	jle	SHORT $LN384@recEventTe
	add	ecx, eax
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
$LN384@recEventTe:
	test	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, 2048 ; 00000800H
	je	SHORT $LN396@recEventTe
	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+876
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+748
	sub	ebp, eax
	cmp	ebp, ecx
	jl	SHORT $LN388@recEventTe
	and	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, -2049 ; fffff7ffH
	call	?gifMFIFOInterrupt@@YAXXZ		; gifMFIFOInterrupt
	jmp	SHORT $LN396@recEventTe
$LN388@recEventTe:
	mov	edx, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	edx, eax
	cmp	edx, ecx
	jle	SHORT $LN396@recEventTe
	add	ecx, eax
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
$LN396@recEventTe:
	call	?psxBranchTest@@YAXXZ			; psxBranchTest
	cmp	BYTE PTR ?iopBranchAction@@3_NA, 0	; iopBranchAction
	je	SHORT $LN9@recEventTe
	mov	eax, DWORD PTR ?EEsCycle@@3HA		; EEsCycle
	mov	ecx, DWORD PTR ?psxCpu@@3PAUR3000Acpu@@A ; psxCpu
	mov	edx, DWORD PTR [ecx+12]
	push	eax
	call	edx
	add	esp, 4
	mov	DWORD PTR ?EEsCycle@@3HA, eax		; EEsCycle
	mov	BYTE PTR ?iopBranchAction@@3_NA, 0	; iopBranchAction
$LN9@recEventTe:
	test	BYTE PTR ?VU0@@3UVURegs@@A+976, 1
	je	SHORT $LN491@recEventTe
	call	DWORD PTR ?CpuVU0@@3UVUmicroCpu@@A+8
	test	BYTE PTR ?VU0@@3UVURegs@@A+976, 1
	mov	eax, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	mov	esi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	je	SHORT $LN401@recEventTe
	mov	ecx, eax
	sub	ecx, esi
	cmp	ecx, 768				; 00000300H
	jle	SHORT $LN401@recEventTe
	lea	eax, DWORD PTR [esi+768]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
	jmp	SHORT $LN401@recEventTe
$LN491@recEventTe:
	mov	eax, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	mov	esi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
$LN401@recEventTe:
	mov	edx, DWORD PTR ?EEsCycle@@3HA		; EEsCycle
	cmp	edx, 192				; 000000c0H
	jle	SHORT $LN406@recEventTe
	mov	ecx, eax
	sub	ecx, esi
	cmp	ecx, 48					; 00000030H
	jle	SHORT $LN406@recEventTe
	lea	eax, DWORD PTR [esi+48]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
$LN406@recEventTe:
	mov	ecx, DWORD PTR ?g_psxNextBranchCycle@@3IA ; g_psxNextBranchCycle
	sub	ecx, DWORD PTR ?psxRegs@@3UpsxRegisters@@A+528
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	sub	ecx, edx
	mov	edx, eax
	sub	edx, esi
	cmp	edx, ecx
	jle	SHORT $LN411@recEventTe
	lea	eax, DWORD PTR [esi+ecx]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
$LN411@recEventTe:
	mov	ecx, DWORD PTR ?counters@@3PAUCounter@@A+188
	mov	edx, DWORD PTR ?counters@@3PAUCounter@@A+192
	mov	edi, eax
	sub	edi, ecx
	cmp	edi, edx
	jle	SHORT $LN414@recEventTe
	lea	eax, DWORD PTR [ecx+edx]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
$LN414@recEventTe:
	mov	ecx, DWORD PTR ?nextsCounter@@3IA	; nextsCounter
	mov	edx, DWORD PTR ?nextCounter@@3HA	; nextCounter
	mov	edi, eax
	sub	edi, ecx
	cmp	edi, edx
	jle	SHORT $LN417@recEventTe
	lea	eax, DWORD PTR [ecx+edx]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
$LN417@recEventTe:
	test	BYTE PTR ?cpuRegs@@3UcpuRegisters@@A+594, 1
	mov	BYTE PTR ?eeEventTestIsActive@@3_NA, 0	; eeEventTestIsActive
	je	$LN460@recEventTe
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+592
	test	bl, 1
	je	$LN460@recEventTe
	test	bl, 6
	jne	$LN460@recEventTe
	test	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, 1073741824 ; 40000000H
	je	$LN440@recEventTe
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+952
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+824
	mov	edi, esi
	sub	edi, ecx
	cmp	edi, edx
	jl	$LN425@recEventTe
	and	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, -1073741825 ; bfffffffH
	test	ebx, 1024				; 00000400H
	je	$LN440@recEventTe
	mov	edx, DWORD PTR ?psH@@3PAEA		; psH
	mov	ecx, DWORD PTR [edx+61440]
	test	ecx, ecx
	jne	SHORT $LN435@recEventTe
	mov	esi, OFFSET ??_C@_0CH@FCDDAIFJ@?$CKPCSX2?$CK?3?5intcInterrupt?5already?5c@
	call	?Notice@Console@@YA_NPBD@Z		; Console::Notice
	jmp	SHORT $LN516@recEventTe
$LN435@recEventTe:
	mov	edx, DWORD PTR [edx+61456]
	and	edx, ecx
	je	SHORT $LN440@recEventTe
	test	BYTE PTR ?varLog@@3IA, 4
	je	SHORT $LN439@recEventTe
	push	edx
	push	OFFSET ??_C@_0BC@LCGONOKJ@intcInterrupt?5?$CFx?6?$AA@
	call	?SrcLog_HW@@YA_NPBDZZ			; SrcLog_HW
	add	esp, 8
$LN439@recEventTe:
	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
	test	BYTE PTR [eax+61440], 2
	je	SHORT $LN433@recEventTe
	xor	ecx, ecx
	call	?rcntRcount@@YIIH@Z			; rcntRcount
	mov	ecx, 1
	mov	DWORD PTR ?counters@@3PAUCounter@@A+12, eax
	call	?rcntRcount@@YIIH@Z			; rcntRcount
	mov	DWORD PTR ?counters@@3PAUCounter@@A+52, eax
$LN433@recEventTe:
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+968
	push	ecx
	push	1024					; 00000400H
	call	?cpuException@@YAXII@Z			; cpuException
	add	esp, 8
$LN516@recEventTe:
	mov	eax, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	mov	esi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+592
	jmp	SHORT $LN440@recEventTe
$LN425@recEventTe:
	mov	edi, eax
	sub	edi, ecx
	cmp	edi, edx
	jle	SHORT $LN440@recEventTe
	lea	eax, DWORD PTR [edx+ecx]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
$LN440@recEventTe:
	test	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, -2147483648 ; 80000000H
	je	$LN460@recEventTe
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+956
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+828
	sub	esi, ecx
	cmp	esi, edx
	jl	$LN444@recEventTe
	and	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, 2147483647 ; 7fffffffH
	and	ebx, 67591				; 00010807H
	cmp	ebx, 67585				; 00010801H
	jne	$LN460@recEventTe
	mov	edx, DWORD PTR ?psH@@3PAEA		; psH
	movzx	eax, WORD PTR [edx+57360]
	mov	cx, WORD PTR [edx+57362]
	and	cx, ax
	jne	SHORT $LN453@recEventTe
	test	eax, 32768				; 00008000H
	je	SHORT $LN460@recEventTe
$LN453@recEventTe:
	test	BYTE PTR [edx+57344], 1
	je	SHORT $LN460@recEventTe
	test	BYTE PTR ?varLog@@3IA, 4
	je	SHORT $LN459@recEventTe
	test	cx, cx
	jne	SHORT $LN457@recEventTe
	test	eax, 32768				; 00008000H
	jne	SHORT $LN457@recEventTe
	xor	eax, eax
	jmp	SHORT $LN458@recEventTe
$LN457@recEventTe:
	mov	eax, 1
$LN458@recEventTe:
	push	eax
	push	OFFSET ??_C@_0BC@IOCBKJEO@dmacInterrupt?5?$CFx?6?$AA@
	call	?SrcLog_HW@@YA_NPBDZZ			; SrcLog_HW
	add	esp, 8
$LN459@recEventTe:
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+968
	push	edx
	push	2048					; 00000800H
	call	?cpuException@@YAXII@Z			; cpuException

; 649  : 
; 650  : #ifdef PCSX2_DEVBUILD
; 651  : 	assert( !g_globalXMMSaved && !g_globalMMXSaved);
; 652  : #endif
; 653  : 	return retval;

	mov	al, BYTE PTR _vsyncEvent$867394[esp+60]
	add	esp, 8

; 654  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 36					; 00000024H
	ret	0

; 644  : 	assert( !g_globalXMMSaved && !g_globalMMXSaved);
; 645  : #endif
; 646  : 
; 647  : 	// Perform counters, ints, and IOP updates:
; 648  : 	bool retval = _cpuBranchTest_Shared();

$LN444@recEventTe:
	sub	eax, ecx
	cmp	eax, edx
	jle	SHORT $LN460@recEventTe
	add	edx, ecx
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, edx	; g_nextBranchCycle
$LN460@recEventTe:

; 649  : 
; 650  : #ifdef PCSX2_DEVBUILD
; 651  : 	assert( !g_globalXMMSaved && !g_globalMMXSaved);
; 652  : #endif
; 653  : 	return retval;

	mov	al, BYTE PTR _vsyncEvent$867394[esp+52]

; 654  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 36					; 00000024H
	ret	0
?recEventTest@@YA_NXZ ENDP				; recEventTest
; Function compile flags: /Ogtp
_count$870190 = -28					; size = 8
_count$870185 = -20					; size = 8
_sDeltaTime$870175 = -12				; size = 8
_result$870153 = -8					; size = 4
_change$870134 = -8					; size = 4
_i$870128 = -4						; size = 4
?recExecuteBlock@@YAXXZ PROC				; recExecuteBlock

; 799  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi

; 800  : 	g_EEFreezeRegs = true;

	mov	BYTE PTR ?g_EEFreezeRegs@@3_NA, 1	; g_EEFreezeRegs

; 801  : 	__asm
; 802  : 	{
; 803  : 		push ebx

	push	ebx

; 804  : 		push esi

	push	esi

; 805  : 		push edi

	push	edi

; 806  : 		push ebp

	push	ebp

; 807  : 
; 808  : 		call DispatcherReg

	call	?DispatcherReg@@YAXXZ			; DispatcherReg

; 809  : 
; 810  : 		pop ebp

	pop	ebp

; 811  : 		pop edi

	pop	edi

; 812  : 		pop esi

	pop	esi

; 813  : 		pop ebx

	pop	ebx

; 814  : 	}
; 815  : 	g_EEFreezeRegs = false;
; 816  : 	recEventTest();

	cmp	BYTE PTR ?g_globalXMMSaved@@3EA, 0	; g_globalXMMSaved
	mov	BYTE PTR ?g_EEFreezeRegs@@3_NA, 0	; g_EEFreezeRegs
	jne	SHORT $LN3@recExecute
	cmp	BYTE PTR ?g_globalMMXSaved@@3EA, 0	; g_globalMMXSaved
	je	SHORT $LN4@recExecute
$LN3@recExecute:
	mov	esi, OFFSET ??_C@_0DF@HHKJLMIF@Pcsx2?5Foopah?$CB?5?5Frozen?5regs?5have?5@
	call	?Error@Console@@YA_NPBD@Z		; Console::Error
$LN4@recExecute:
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	eax, DWORD PTR _eeWaitCycles
	add	eax, ebx
	mov	ecx, ebx
	sub	ecx, DWORD PTR ?EEoCycle@@3IA		; EEoCycle
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
	mov	eax, DWORD PTR ?EEsCycle@@3HA		; EEsCycle
	add	eax, ecx
	mov	BYTE PTR ?eeEventTestIsActive@@3_NA, 1	; eeEventTestIsActive
	mov	DWORD PTR ?EEsCycle@@3HA, eax		; EEsCycle
	mov	DWORD PTR ?EEoCycle@@3IA, ebx		; EEoCycle
	test	eax, eax
	jle	SHORT $LN14@recExecute
	mov	BYTE PTR ?iopBranchAction@@3_NA, 1	; iopBranchAction
$LN14@recExecute:
	mov	eax, DWORD PTR ?counters@@3PAUCounter@@A+188
	mov	edx, ebx
	sub	edx, eax
	cmp	edx, DWORD PTR ?counters@@3PAUCounter@@A+192
	jl	SHORT $LN481@recExecute
	test	BYTE PTR ?counters@@3PAUCounter@@A+164, 1
	je	$LN22@recExecute
	push	eax
	push	0
	call	?rcntStartGate@@YIX_NI@Z		; rcntStartGate
	push	0
	call	?psxCheckStartGate16@@YAXH@Z		; psxCheckStartGate16
	mov	eax, DWORD PTR _vSyncInfo+20
	mov	ecx, DWORD PTR _vSyncInfo+16
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	add	esp, 4
	add	DWORD PTR ?counters@@3PAUCounter@@A+188, eax
	mov	DWORD PTR ?counters@@3PAUCounter@@A+192, ecx
	mov	DWORD PTR ?counters@@3PAUCounter@@A+164, 0
$LN481@recExecute:
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
$LN21@recExecute:
	mov	eax, ebx
	sub	eax, DWORD PTR ?nextsCounter@@3IA	; nextsCounter
	cmp	eax, DWORD PTR ?nextCounter@@3HA	; nextCounter
	jl	$LN194@recExecute
	mov	ecx, DWORD PTR ?counters@@3PAUCounter@@A+228
	mov	eax, ebx
	sub	eax, ecx
	cmp	eax, DWORD PTR ?counters@@3PAUCounter@@A+232
	jl	$LN48@recExecute
	cmp	DWORD PTR ?counters@@3PAUCounter@@A+204, 3
	jne	$LN46@recExecute
	test	DWORD PTR ?varLog@@3IA, 1073741824	; varLog, 40000000H
	mov	esi, ecx
	je	SHORT $LN55@recExecute
	mov	ecx, DWORD PTR _iFrame
	push	ecx
	push	OFFSET ??_C@_0DK@GPMLIACH@?1?1?1?1?1?1?1?1?1?5?5EE?5COUNTER?5VSYNC?5END?5@
	call	?SrcLog_EECNT@@YA_NPBDZZ		; SrcLog_EECNT
	add	esp, 8
$LN55@recExecute:
	inc	DWORD PTR _iFrame
	cmp	DWORD PTR ?g_vu1SkipCount@@3IA, 0	; g_vu1SkipCount
	jbe	$LN52@recExecute
	push	0
	call	?gsPostVsyncEnd@@YAX_N@Z		; gsPostVsyncEnd
	add	esp, 4
	mov	ecx, OFFSET ?g_vu1SkipCount@@3IA	; g_vu1SkipCount
	mov	eax, -1
	lock	 xadd	 DWORD PTR [ecx], eax
	mov	DWORD PTR _result$870153[ebp], eax
	mov	DWORD PTR ?CpuVU1@@3UVUmicroCpu@@A+8, OFFSET ?DummyExecuteVU1Block@@YAXXZ ; DummyExecuteVU1Block
	jmp	$LN67@recExecute
$LN22@recExecute:
	test	BYTE PTR ?CSRw@@3IA, 4
	je	SHORT $LN20@recExecute
	mov	edx, DWORD PTR ?g_RealGSMem@@3PAEA+4100
	or	DWORD PTR ?g_RealGSMem@@3PAEA+4096, 4
	mov	DWORD PTR ?g_RealGSMem@@3PAEA+4100, edx
$LN20@recExecute:
	test	DWORD PTR ?g_RealGSMem@@3PAEA+4112, 1024 ; 00000400H
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	jne	SHORT $LN30@recExecute
	or	DWORD PTR [edi+61440], 1
	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
$LN30@recExecute:
	cmp	DWORD PTR ?gates@@3HA, 0		; gates
	je	SHORT $LN18@recExecute
	mov	eax, DWORD PTR ?counters@@3PAUCounter@@A+188
	push	eax
	push	0
	call	?rcntEndGate@@YIX_NI@Z			; rcntEndGate
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
$LN18@recExecute:
	cmp	BYTE PTR ?psxhblankgate@@3EA, 0		; psxhblankgate
	je	SHORT $LN32@recExecute
	xor	eax, eax
	call	?_psxCheckEndGate@@YAXH@Z		; _psxCheckEndGate
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
$LN32@recExecute:
	mov	ecx, DWORD PTR _vSyncInfo+16
	mov	edx, DWORD PTR _vSyncInfo+20
	add	DWORD PTR ?counters@@3PAUCounter@@A+188, ecx
	mov	DWORD PTR ?counters@@3PAUCounter@@A+192, edx
	mov	DWORD PTR ?counters@@3PAUCounter@@A+164, 1
	jmp	$LN21@recExecute
$LN52@recExecute:
	push	1
	call	?gsPostVsyncEnd@@YAX_N@Z		; gsPostVsyncEnd
	add	esp, 4
	test	BYTE PTR ?g_Session@@3USessionOverrideFlags@@A, 4 ; g_Session
	jne	SHORT $LN66@recExecute
	test	BYTE PTR ?Config@@3UPcsxConfig@@A+3576, 64 ; 00000040H
	je	SHORT $LN66@recExecute
	mov	edx, DWORD PTR ?recVU1@@3UVUmicroCpu@@B+8
	mov	DWORD PTR ?CpuVU1@@3UVUmicroCpu@@A+8, edx
	jmp	SHORT $LN67@recExecute
$LN66@recExecute:
	mov	eax, DWORD PTR ?intVU1@@3UVUmicroCpu@@B+8
	mov	DWORD PTR ?CpuVU1@@3UVUmicroCpu@@A+8, eax
$LN67@recExecute:
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	or	DWORD PTR [edi+61440], 8
	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
	mov	eax, DWORD PTR ?psxH@@3PAEA		; psxH
	or	DWORD PTR [eax+4208], 2048		; 00000800H
	test	BYTE PTR ?psxvblankgate@@3EA, 2		; psxvblankgate
	je	SHORT $LN74@recExecute
	mov	eax, 1
	call	?_psxCheckEndGate@@YAXH@Z		; _psxCheckEndGate
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
$LN74@recExecute:
	test	BYTE PTR ?psxvblankgate@@3EA, 8		; psxvblankgate
	je	SHORT $LN76@recExecute
	mov	eax, 3
	call	?_psxCheckEndGate@@YAXH@Z		; _psxCheckEndGate
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
$LN76@recExecute:
	cmp	DWORD PTR ?gates@@3HA, 0		; gates
	je	SHORT $LN50@recExecute
	push	esi
	push	1
	call	?rcntEndGate@@YIX_NI@Z			; rcntEndGate
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
$LN50@recExecute:
	test	DWORD PTR ?Config@@3UPcsxConfig@@A+3576, 3072 ; 00000c00H
	je	$LN476@recExecute
	cmp	DWORD PTR ?Config@@3UPcsxConfig@@A+3604, 999 ; 000003e7H
	jge	$LN476@recExecute
	mov	esi, DWORD PTR _m_iTicks
	add	esi, DWORD PTR _m_iStart
	mov	edi, DWORD PTR _m_iTicks+4
	adc	edi, DWORD PTR _m_iStart+4
	lea	ecx, DWORD PTR _count$870185[ebp]
	push	ecx
	call	DWORD PTR __imp__QueryPerformanceCounter@4
	mov	eax, DWORD PTR _count$870185[ebp]
	mov	edx, DWORD PTR _m_iTicks+4
	mov	ebx, DWORD PTR _count$870185[ebp+4]
	push	0
	sub	eax, esi
	push	8
	mov	DWORD PTR _sDeltaTime$870175[ebp], eax
	mov	eax, DWORD PTR _m_iTicks
	push	edx
	push	eax
	sbb	ebx, edi
	call	__allmul
	cmp	ebx, edx
	jl	SHORT $LN80@recExecute
	jg	SHORT $LN474@recExecute
	cmp	DWORD PTR _sDeltaTime$870175[ebp], eax
	jbe	SHORT $LN80@recExecute
$LN474@recExecute:
	mov	eax, DWORD PTR _count$870185[ebp]
	sub	eax, DWORD PTR _m_iTicks
	mov	ecx, DWORD PTR _count$870185[ebp+4]
	sbb	ecx, DWORD PTR _m_iTicks+4
	mov	DWORD PTR _m_iStart, eax
	sub	eax, esi
	mov	DWORD PTR _m_iStart+4, ecx
	call	?gsSyncLimiterLostTime@@YAXH@Z		; gsSyncLimiterLostTime
	jmp	SHORT $LN482@recExecute
$LN80@recExecute:
	mov	DWORD PTR _m_iStart, esi
	mov	DWORD PTR _m_iStart+4, edi
	test	ebx, ebx
	jg	SHORT $LN482@recExecute
	jl	SHORT $LN477@recExecute
	cmp	DWORD PTR _sDeltaTime$870175[ebp], 0
	jae	SHORT $LN482@recExecute
$LN477@recExecute:
	mov	ebx, DWORD PTR __imp__Sleep@4
$LL79@recExecute:
	push	0
	call	ebx
	lea	ecx, DWORD PTR _count$870190[ebp]
	push	ecx
	call	DWORD PTR __imp__QueryPerformanceCounter@4
	mov	eax, DWORD PTR _count$870190[ebp]
	mov	edx, DWORD PTR _count$870190[ebp+4]
	sub	eax, esi
	sbb	edx, edi
	mov	DWORD PTR _sDeltaTime$870175[ebp+4], edx
	js	SHORT $LL79@recExecute
	jg	SHORT $LN482@recExecute
	test	eax, eax
	jb	SHORT $LL79@recExecute
$LN482@recExecute:
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
$LN476@recExecute:
	mov	eax, DWORD PTR _vSyncInfo+8
	mov	ecx, DWORD PTR _vSyncInfo+4
	add	DWORD PTR ?counters@@3PAUCounter@@A+228, eax
	mov	DWORD PTR ?counters@@3PAUCounter@@A+232, ecx
	mov	DWORD PTR ?counters@@3PAUCounter@@A+204, 0
	jmp	$LN511@recExecute
$LN46@recExecute:
	test	DWORD PTR ?varLog@@3IA, 1073741824	; varLog, 40000000H
	mov	ebx, ecx
	je	SHORT $LN97@recExecute
	mov	edx, DWORD PTR _iFrame
	push	edx
	push	OFFSET ??_C@_0DM@NMBMHAFB@?1?1?1?1?1?1?1?1?1?5?5EE?5COUNTER?5VSYNC?5STAR@
	call	?SrcLog_EECNT@@YA_NPBDZZ		; SrcLog_EECNT
	add	esp, 8
$LN97@recExecute:
	call	?vSyncDebugStuff@@YAXXZ			; vSyncDebugStuff
	test	BYTE PTR ?CSRw@@3IA, 8
	je	SHORT $LN94@recExecute
	mov	eax, DWORD PTR ?g_RealGSMem@@3PAEA+4100
	or	DWORD PTR ?g_RealGSMem@@3PAEA+4096, 8
	mov	DWORD PTR ?g_RealGSMem@@3PAEA+4100, eax
$LN94@recExecute:
	test	DWORD PTR ?g_RealGSMem@@3PAEA+4112, 2048 ; 00000800H
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	mov	esi, 1
	jne	SHORT $LN100@recExecute
	or	DWORD PTR [edi+61440], esi
	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
$LN100@recExecute:
	or	DWORD PTR [edi+61440], 4
	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
	call	?cdvdVsync@@YAXXZ			; cdvdVsync
	mov	eax, DWORD PTR ?psxH@@3PAEA		; psxH
	or	DWORD PTR [eax+4208], esi
	test	BYTE PTR ?psxvblankgate@@3EA, 2		; psxvblankgate
	je	SHORT $LN105@recExecute
	push	esi
	call	?psxCheckStartGate16@@YAXH@Z		; psxCheckStartGate16
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	add	esp, 4
$LN105@recExecute:
	test	BYTE PTR ?psxvblankgate@@3EA, 8		; psxvblankgate
	je	SHORT $LN127@recExecute
	mov	eax, 3
	call	?_psxCheckStartGate@@YAXH@Z		; _psxCheckStartGate
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
$LN127@recExecute:
	cmp	DWORD PTR ?gates@@3HA, 0		; gates
	je	SHORT $LN92@recExecute
	push	ebx
	push	esi
	call	?rcntStartGate@@YIX_NI@Z		; rcntStartGate
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
$LN92@recExecute:
	cmp	DWORD PTR ?Config@@3UPcsxConfig@@A+3596, 0
	je	SHORT $LN129@recExecute
	xor	ebx, ebx
	cmp	DWORD PTR ?patchnumber@@3HA, ebx	; patchnumber
	jle	SHORT $LN129@recExecute
	mov	edi, OFFSET ?patch@@3PAUIniPatch@@A	; patch
$LL131@recExecute:
	cmp	DWORD PTR [edi+16], esi
	jne	SHORT $LN130@recExecute
	mov	eax, edi
	call	?_applypatch@@YAXHPAUIniPatch@@@Z	; _applypatch
$LN130@recExecute:
	add	ebx, esi
	add	edi, 32					; 00000020H
	cmp	ebx, DWORD PTR ?patchnumber@@3HA	; patchnumber
	jl	SHORT $LL131@recExecute
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
$LN129@recExecute:
	mov	ecx, DWORD PTR _vSyncInfo+4
	mov	edx, DWORD PTR _vSyncInfo+8
	mov	eax, DWORD PTR _vSyncInfo+12
	add	DWORD PTR ?counters@@3PAUCounter@@A+228, ecx
	add	DWORD PTR ?counters@@3PAUCounter@@A+188, eax
	mov	DWORD PTR ?counters@@3PAUCounter@@A+232, edx
	mov	DWORD PTR ?counters@@3PAUCounter@@A+204, 3
$LN511@recExecute:
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
$LN48@recExecute:
	mov	DWORD PTR _i$870128[ebp], 0
	mov	esi, OFFSET ?counters@@3PAUCounter@@A+4
$LN42@recExecute:
	mov	eax, DWORD PTR [esi]
	test	al, al
	jns	$LN41@recExecute
	and	eax, 3
	cmp	al, 3
	je	$LN38@recExecute
	mov	eax, ebx
	sub	eax, DWORD PTR [esi+32]
	mov	DWORD PTR _change$870134[ebp], eax
	jns	SHORT $LN37@recExecute
	xor	eax, eax
	mov	DWORD PTR _change$870134[ebp], eax
$LN37@recExecute:
	mov	ecx, DWORD PTR [esi+12]
	xor	edx, edx
	div	ecx
	mov	edx, ebx
	add	DWORD PTR [esi-4], eax
	imul	eax, ecx
	mov	ecx, DWORD PTR _change$870134[ebp]
	sub	ecx, eax
	mov	eax, DWORD PTR [esi+4]
	sub	edx, ecx
	mov	ecx, DWORD PTR [esi-4]
	mov	DWORD PTR [esi+32], edx
	cmp	ecx, eax
	jb	SHORT $LN162@recExecute
	test	DWORD PTR [esi], 256			; 00000100H
	je	SHORT $LN165@recExecute
	test	DWORD PTR ?varLog@@3IA, 1073741824	; varLog, 40000000H
	je	SHORT $LN169@recExecute
	push	eax
	mov	eax, DWORD PTR [esi]
	push	ecx
	mov	ecx, DWORD PTR _i$870128[ebp]
	push	eax
	push	ecx
	push	OFFSET ??_C@_0DO@EGNLMAGK@EE?5Counter?$FL?$CFd?$FN?5TARGET?5reached?5?9?5@
	call	?SrcLog_EECNT@@YA_NPBDZZ		; SrcLog_EECNT
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	add	esp, 20					; 00000014H
$LN169@recExecute:
	mov	ecx, DWORD PTR [esi+16]
	or	DWORD PTR [esi], 1024			; 00000400H
	mov	edx, 1
	shl	edx, cl
	or	DWORD PTR [edi+61440], edx
	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
	test	BYTE PTR [esi], 64			; 00000040H
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	je	SHORT $LN164@recExecute
	mov	eax, DWORD PTR [esi+4]
	sub	DWORD PTR [esi-4], eax
	jmp	SHORT $LN162@recExecute
$LN164@recExecute:
	or	DWORD PTR [esi+4], 268435456		; 10000000H
	jmp	SHORT $LN162@recExecute
$LN165@recExecute:
	or	eax, 268435456				; 10000000H
	mov	DWORD PTR [esi+4], eax
$LN162@recExecute:
	mov	eax, DWORD PTR [esi-4]
	cmp	eax, 65535				; 0000ffffH
	jbe	SHORT $LN41@recExecute
	test	DWORD PTR [esi], 512			; 00000200H
	je	SHORT $LN177@recExecute
	test	DWORD PTR ?varLog@@3IA, 1073741824	; varLog, 40000000H
	je	SHORT $LN176@recExecute
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR _i$870128[ebp]
	push	eax
	push	ecx
	push	edx
	push	OFFSET ??_C@_0CN@DJCFHOEE@EE?5Counter?$FL?$CFd?$FN?5OVERFLOW?5?9?5mode?$DN?$CF@
	call	?SrcLog_EECNT@@YA_NPBDZZ		; SrcLog_EECNT
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	add	esp, 16					; 00000010H
$LN176@recExecute:
	mov	ecx, DWORD PTR [esi+16]
	or	DWORD PTR [esi], 2048			; 00000800H
	mov	eax, 1
	shl	eax, cl
	or	DWORD PTR [edi+61440], eax
	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
$LN177@recExecute:
	add	DWORD PTR [esi-4], -65536		; ffff0000H
	xor	ecx, ecx
	mov	WORD PTR [esi+6], cx
	jmp	SHORT $LN41@recExecute
$LN38@recExecute:
	mov	DWORD PTR [esi+32], ebx
$LN41@recExecute:
	inc	DWORD PTR _i$870128[ebp]
	add	esi, 40					; 00000028H
	cmp	esi, OFFSET ?counters@@3PAUCounter@@A+124
	jle	$LN42@recExecute
	mov	esi, DWORD PTR ?counters@@3PAUCounter@@A+232
	sub	esi, ebx
	add	esi, DWORD PTR ?counters@@3PAUCounter@@A+228
	mov	DWORD PTR ?nextsCounter@@3IA, ebx	; nextsCounter
	mov	DWORD PTR ?nextCounter@@3HA, esi	; nextCounter
	mov	edx, OFFSET ?counters@@3PAUCounter@@A+8
$LL182@recExecute:
	mov	eax, DWORD PTR [edx-4]
	test	al, al
	jns	SHORT $LN181@recExecute
	and	eax, 3
	cmp	al, 3
	je	SHORT $LN181@recExecute
	mov	esi, DWORD PTR [edx-8]
	cmp	esi, 65536				; 00010000H
	ja	SHORT $LN188@recExecute
	mov	ecx, DWORD PTR [edx]
	cmp	esi, ecx
	ja	SHORT $LN188@recExecute
	mov	eax, 65536				; 00010000H
	sub	eax, esi
	imul	eax, DWORD PTR [edx+8]
	mov	esi, DWORD PTR ?nextCounter@@3HA	; nextCounter
	sub	eax, ebx
	add	eax, DWORD PTR [edx+28]
	cmp	eax, esi
	jge	SHORT $LN187@recExecute
	mov	esi, eax
	mov	DWORD PTR ?nextCounter@@3HA, esi	; nextCounter
$LN187@recExecute:
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN181@recExecute
	sub	ecx, DWORD PTR [edx-8]
	imul	ecx, DWORD PTR [edx+8]
	sub	ecx, ebx
	add	ecx, DWORD PTR [edx+28]
	cmp	ecx, esi
	jge	SHORT $LN181@recExecute
	mov	esi, ecx
	jmp	SHORT $LN512@recExecute
$LN188@recExecute:
	mov	esi, 4
$LN512@recExecute:
	mov	DWORD PTR ?nextCounter@@3HA, esi	; nextCounter
$LN181@recExecute:
	add	edx, 40					; 00000028H
	cmp	edx, OFFSET ?counters@@3PAUCounter@@A+168
	jl	SHORT $LL182@recExecute
	test	esi, esi
	jge	SHORT $LN179@recExecute
	mov	DWORD PTR ?nextCounter@@3HA, 0		; nextCounter
$LN179@recExecute:
	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+688
	mov	edx, eax
	and	edx, -2147482656			; 800003e0H
	cmp	edx, -2147483616			; 80000020H
	jne	SHORT $LN195@recExecute
	mov	ecx, ebx
	sub	ecx, DWORD PTR ?s_iLastPERFCycle@@3PAIA
	mov	DWORD PTR ?s_iLastPERFCycle@@3PAIA, ebx
	add	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+692, ecx
$LN195@recExecute:
	and	eax, -2146467840			; 800f8000H
	cmp	eax, -2147450880			; 80008000H
	jne	SHORT $LN194@recExecute
	mov	edx, ebx
	sub	edx, DWORD PTR ?s_iLastPERFCycle@@3PAIA+4
	mov	DWORD PTR ?s_iLastPERFCycle@@3PAIA+4, ebx
	add	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+696, edx
$LN194@recExecute:
	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+580
	mov	ecx, ebx
	sub	ecx, DWORD PTR ?s_iLastCOP0Cycle@@3IA	; s_iLastCOP0Cycle
	mov	DWORD PTR ?s_iLastCOP0Cycle@@3IA, ebx	; s_iLastCOP0Cycle
	add	eax, ecx
	test	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+592, 32768 ; 00008000H
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+580, eax
	je	SHORT $LN198@recExecute
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+588
	cmp	eax, ecx
	jb	SHORT $LN198@recExecute
	lea	edx, DWORD PTR [ecx+1000]
	cmp	eax, edx
	jae	SHORT $LN198@recExecute
	push	ecx
	push	eax
	push	0
	push	OFFSET ??_C@_0BC@KKHOMMCD@timr?5intr?3?5?$CFx?0?5?$CFx?$AA@
	call	?Status@Console@@YA_NPBDPBU_VARG_PARAM@@ZZ ; Console::Status
	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+968
	push	eax
	push	8421376					; 00808000H
	call	?cpuException@@YAXII@Z			; cpuException
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	add	esp, 24					; 00000018H
$LN198@recExecute:
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
	test	edx, 1073741823				; 3fffffffH
	je	$LN398@recExecute
	test	dl, 2
	je	$LN247@recExecute
	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+836
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+708
	mov	esi, ebx
	sub	esi, eax
	cmp	esi, ecx
	jl	$LN205@recExecute
	and	edx, -3					; fffffffdH
	test	DWORD PTR ?varLog@@3IA, 1024		; varLog, 00000400H
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, edx
	je	SHORT $LN228@recExecute
	push	ebx
	push	OFFSET ??_C@_0BG@OEMEHKAM@vif1Interrupt?3?5?$CF8?48x?6?$AA@
	call	?SrcLog_VIF@@YA_NPBDZZ			; SrcLog_VIF
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	add	esp, 8
$LN228@recExecute:
	cmp	DWORD PTR ?vif1@@3UvifStruct@@A+20, 0
	mov	DWORD PTR ?g_vifCycles@@3HA, 0		; g_vifCycles
	je	$LN223@recExecute
	cmp	DWORD PTR ?vif1@@3UvifStruct@@A+4, 0
	jne	$LN223@recExecute
	or	DWORD PTR [edi+15360], 2048		; 00000800H
	or	DWORD PTR [edi+61440], 32		; 00000020H
	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
	dec	DWORD PTR ?vif1@@3UvifStruct@@A+20
	mov	eax, DWORD PTR [edi+15360]
	test	eax, 1792				; 00000700H
	je	SHORT $LN224@recExecute
	and	eax, -520093697				; e0ffffffH
	and	DWORD PTR [edi+36864], -257		; fffffeffH
	mov	DWORD PTR [edi+15360], eax
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	jmp	$LN247@recExecute
$LN224@recExecute:
	cmp	WORD PTR [edi+36896], 0
	ja	SHORT $LN222@recExecute
	cmp	BYTE PTR ?vif1@@3UvifStruct@@A+36, 0
	jbe	$LN223@recExecute
$LN222@recExecute:
	cmp	BYTE PTR ?vif1@@3UvifStruct@@A+35, 1
	jne	SHORT $LN221@recExecute
$LN217@recExecute:
	call	?_chainVIF1@@YAHXZ			; _chainVIF1
	jmp	SHORT $LN220@recExecute
$LN221@recExecute:
	call	?_VIF1chain@@YAHXZ			; _VIF1chain
$LN220@recExecute:
	mov	eax, DWORD PTR ?g_vifCycles@@3HA	; g_vifCycles
	or	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, 2
	cmp	eax, 28					; 0000001cH
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+708, eax
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+836, ebx
	jg	SHORT $LN231@recExecute
	mov	ecx, DWORD PTR ?psxCycleEE@@3HA		; psxCycleEE
	test	ecx, ecx
	jle	SHORT $LN231@recExecute
	add	DWORD PTR ?psxBreak@@3HA, ecx		; psxBreak
	mov	DWORD PTR ?psxCycleEE@@3HA, 0		; psxCycleEE
$LN231@recExecute:
	mov	ecx, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	ecx, ebx
	cmp	ecx, eax
	jle	SHORT $LN485@recExecute
	add	eax, ebx
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
$LN485@recExecute:
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
$LN247@recExecute:
	test	BYTE PTR ?cpuRegs@@3UcpuRegisters@@A+964, 4
	je	$LN275@recExecute
	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+840
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+712
	mov	edx, ebx
	sub	edx, eax
	cmp	edx, ecx
	jl	$LN251@recExecute
	and	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, -5 ; fffffffbH
	test	DWORD PTR ?varLog@@3IA, 4096		; varLog, 00001000H
	je	SHORT $LN266@recExecute
	push	ebx
	push	OFFSET ??_C@_0BE@FPDFMCPK@gsInterrupt?3?5?$CF8?48x?6?$AA@
	call	?SrcLog_GIF@@YA_NPBDZZ			; SrcLog_GIF
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	add	esp, 8
$LN266@recExecute:
	test	DWORD PTR [edi+40960], 256		; 00000100H
	je	$LN275@recExecute
	xor	esi, esi
	cmp	WORD PTR [edi+40992], si
	ja	SHORT $LN261@recExecute
	cmp	DWORD PTR _gspath3done, esi
	jne	$LN259@recExecute
$LN261@recExecute:
	test	BYTE PTR [edi+57344], 1
	jne	$LN260@recExecute
	mov	esi, OFFSET ??_C@_0CA@OMBBMBNE@gs?5dma?5masked?0?5re?9scheduling?4?4?4?$AA@
	call	?Notice@Console@@YA_NPBD@Z		; Console::Notice
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	eax, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	or	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, 4
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	sub	eax, ebx
	cmp	eax, 64					; 00000040H
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+840, ebx
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+712, 64 ; 00000040H
	jle	$LN275@recExecute
	lea	ecx, DWORD PTR [ebx+64]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
	jmp	$LN275@recExecute
$LN223@recExecute:
	mov	eax, DWORD PTR [edi+36864]
	test	eax, 256				; 00000100H
	jne	SHORT $LN219@recExecute
	push	eax
	push	OFFSET ??_C@_0BO@KFAMBPHK@Vif1?5running?5when?5CHCR?5?$DN?$DN?5?$CFx?6?$AA@
	call	?SysPrintf@@YAXPBDZZ			; SysPrintf
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	add	esp, 8
$LN219@recExecute:
	mov	edx, DWORD PTR [edi+36864]
	and	edx, 260				; 00000104H
	cmp	edx, 260				; 00000104H
	jne	SHORT $LN218@recExecute
	cmp	BYTE PTR ?vif1@@3UvifStruct@@A+33, 0
	jne	SHORT $LN218@recExecute
	test	BYTE PTR [edi+57344], 1
	jne	$LN217@recExecute
	push	OFFSET ??_C@_0BB@EELLKNKM@vif1?5dma?5masked?6?$AA@
	call	?SysPrintf@@YAXPBDZZ			; SysPrintf
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	add	esp, 4
	jmp	$LN485@recExecute
$LN218@recExecute:
	xor	esi, esi
	cmp	WORD PTR [edi+36896], si
	jbe	SHORT $LN216@recExecute
	push	OFFSET ??_C@_0BO@OINNBNMI@VIF1?5Ending?5with?5?$CFx?5QWC?5left?6?$AA@
	call	?SysPrintf@@YAXPBDZZ			; SysPrintf
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	add	esp, 4
$LN216@recExecute:
	mov	eax, DWORD PTR ?vif1@@3UvifStruct@@A+16
	cmp	eax, esi
	je	SHORT $LN215@recExecute
	push	eax
	push	OFFSET ??_C@_0BH@OMPPLFGP@vif1?4cmd?5still?5set?5?$CFx?6?$AA@
	call	?SysPrintf@@YAXPBDZZ			; SysPrintf
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	add	esp, 8
$LN215@recExecute:
	and	DWORD PTR [edi+36864], -257		; fffffeffH
	mov	ecx, 1
	mov	DWORD PTR _prevviftag, esi
	mov	DWORD PTR _prevvifcycles, esi
	call	?hwDmacIrq@@YAXH@Z			; hwDmacIrq
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	cmp	DWORD PTR [edi+15600], esi
	je	SHORT $LN213@recExecute
	test	BYTE PTR [edi+36864], 1
	je	SHORT $LN484@recExecute
$LN213@recExecute:
	and	DWORD PTR [edi+15360], -520093697	; e0ffffffH
$LN484@recExecute:
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	jmp	$LN247@recExecute
$LN205@recExecute:
	mov	edx, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	edx, eax
	cmp	edx, ecx
	jle	$LN247@recExecute
	add	ecx, eax
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
	jmp	$LN247@recExecute
$LN260@recExecute:
	call	?GIFdma@@YAXXZ				; GIFdma
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	cmp	DWORD PTR _gspath3done, esi
	je	SHORT $LN487@recExecute
$LN259@recExecute:
	mov	DWORD PTR _gspath3done, esi
	mov	DWORD PTR _gscycles, esi
	and	DWORD PTR [edi+40960], -257		; fffffeffH
	mov	edx, DWORD PTR ?g_RealGSMem@@3PAEA+4096
	mov	eax, DWORD PTR ?g_RealGSMem@@3PAEA+4100
	and	edx, -32769				; ffff7fffH
	or	edx, 16384				; 00004000H
	mov	DWORD PTR ?g_RealGSMem@@3PAEA+4096, edx
	mov	DWORD PTR ?g_RealGSMem@@3PAEA+4100, eax
	and	DWORD PTR [edi+12320], -520097281	; e0fff1ffH
	mov	ecx, 2
	mov	DWORD PTR ?Path3transfer@@3HA, esi	; Path3transfer
	call	?hwDmacIrq@@YAXH@Z			; hwDmacIrq
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
$LN487@recExecute:
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
$LN275@recExecute:
	test	BYTE PTR ?cpuRegs@@3UcpuRegisters@@A+964, 32 ; 00000020H
	je	SHORT $LN498@recExecute
	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+852
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+724
	mov	edx, ebx
	sub	edx, eax
	cmp	edx, ecx
	jl	SHORT $LN279@recExecute
	and	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, -33 ; ffffffdfH
	mov	esi, -257				; fffffeffH
	and	DWORD PTR [edi+49152], esi
	mov	ecx, 5
	call	?hwDmacIrq@@YAXH@Z			; hwDmacIrq
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	jmp	SHORT $LN289@recExecute
$LN251@recExecute:
	mov	edx, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	edx, eax
	cmp	edx, ecx
	jle	SHORT $LN275@recExecute
	add	ecx, eax
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
	jmp	SHORT $LN275@recExecute
$LN279@recExecute:
	mov	edx, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	edx, eax
	cmp	edx, ecx
	jle	SHORT $LN498@recExecute
	add	ecx, eax
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
$LN498@recExecute:
	mov	esi, -257				; fffffeffH
$LN289@recExecute:
	test	BYTE PTR ?cpuRegs@@3UcpuRegisters@@A+964, 64 ; 00000040H
	je	SHORT $LN303@recExecute
	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+856
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+728
	mov	edx, ebx
	sub	edx, eax
	cmp	edx, ecx
	jl	SHORT $LN293@recExecute
	and	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, -65 ; ffffffbfH
	mov	ecx, 6
	call	?hwDmacIrq@@YAXH@Z			; hwDmacIrq
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	and	DWORD PTR [edi+50176], esi
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	jmp	SHORT $LN303@recExecute
$LN293@recExecute:
	mov	edx, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	edx, eax
	cmp	edx, ecx
	jle	SHORT $LN303@recExecute
	add	ecx, eax
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
$LN303@recExecute:
	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
	test	eax, 3865				; 00000f19H
	je	$LN398@recExecute
	test	al, 1
	je	SHORT $LN315@recExecute
	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+832
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+704
	mov	edx, ebx
	sub	edx, eax
	cmp	edx, ecx
	jl	SHORT $LN307@recExecute
	and	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, -2 ; fffffffeH
	call	?vif0Interrupt@@YAXXZ			; vif0Interrupt
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	jmp	SHORT $LN315@recExecute
$LN307@recExecute:
	mov	edx, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	edx, eax
	cmp	edx, ecx
	jle	SHORT $LN315@recExecute
	add	ecx, eax
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
$LN315@recExecute:
	test	BYTE PTR ?cpuRegs@@3UcpuRegisters@@A+964, 8
	je	SHORT $LN327@recExecute
	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+844
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+716
	mov	edx, ebx
	sub	edx, eax
	cmp	edx, ecx
	jl	SHORT $LN319@recExecute
	and	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, -9 ; fffffff7H
	call	?ipu0Interrupt@@YAXXZ			; ipu0Interrupt
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	jmp	SHORT $LN327@recExecute
$LN319@recExecute:
	mov	edx, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	edx, eax
	cmp	edx, ecx
	jle	SHORT $LN327@recExecute
	add	ecx, eax
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
$LN327@recExecute:
	test	BYTE PTR ?cpuRegs@@3UcpuRegisters@@A+964, 16 ; 00000010H
	je	$LN347@recExecute
	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+848
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+720
	mov	edx, ebx
	sub	edx, eax
	cmp	edx, ecx
	jl	SHORT $LN331@recExecute
	and	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, -17 ; ffffffefH
	test	DWORD PTR ?varLog@@3IA, 16384		; varLog, 00004000H
	je	SHORT $LN344@recExecute
	push	ebx
	push	OFFSET ??_C@_0BD@IOONBAFN@ipu1Interrupt?5?$CFx?3?6?$AA@
	call	?SrcLog_IPU@@YA_NPBDZZ			; SrcLog_IPU
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	add	esp, 8
$LN344@recExecute:
	test	BYTE PTR _g_nDMATransfer, 64		; 00000040H
	je	SHORT $LN341@recExecute
	or	DWORD PTR [edi+61440], 256		; 00000100H
	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
	and	DWORD PTR _g_nDMATransfer, -65		; ffffffbfH
$LN341@recExecute:
	test	BYTE PTR _g_nDMATransfer, 4
	je	SHORT $LN340@recExecute
	and	DWORD PTR _g_nDMATransfer, -5		; fffffffbH
	jmp	SHORT $LN339@recExecute
$LN340@recExecute:
	and	DWORD PTR [edi+46080], esi
$LN339@recExecute:
	mov	ecx, 4
	call	?hwDmacIrq@@YAXH@Z			; hwDmacIrq
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	jmp	SHORT $LN347@recExecute
$LN331@recExecute:
	mov	edx, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	edx, eax
	cmp	edx, ecx
	jle	SHORT $LN347@recExecute
	add	ecx, eax
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
$LN347@recExecute:
	test	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, 256 ; 00000100H
	je	SHORT $LN359@recExecute
	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+864
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+736
	mov	edx, ebx
	sub	edx, eax
	cmp	edx, ecx
	jl	SHORT $LN351@recExecute
	and	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, esi
	call	?SPRFROMinterrupt@@YAXXZ		; SPRFROMinterrupt
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	jmp	SHORT $LN359@recExecute
$LN351@recExecute:
	mov	edx, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	edx, eax
	cmp	edx, ecx
	jle	SHORT $LN359@recExecute
	add	ecx, eax
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
$LN359@recExecute:
	test	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, 512 ; 00000200H
	je	SHORT $LN374@recExecute
	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+868
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+740
	mov	edx, ebx
	sub	edx, eax
	cmp	edx, ecx
	jl	SHORT $LN363@recExecute
	and	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, -513 ; fffffdffH
	call	?_dmaSPR1@@YAXXZ			; _dmaSPR1
	cmp	DWORD PTR ?spr1finished@@3HA, 0		; spr1finished
	je	SHORT $LN489@recExecute
	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
	and	DWORD PTR [eax+54272], esi
	mov	ecx, 9
	call	?hwDmacIrq@@YAXH@Z			; hwDmacIrq
$LN489@recExecute:
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
$LN374@recExecute:
	test	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, 1024 ; 00000400H
	je	SHORT $LN386@recExecute
	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+872
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+744
	mov	edx, ebx
	sub	edx, eax
	cmp	edx, ecx
	jl	SHORT $LN378@recExecute
	and	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, -1025 ; fffffbffH
	call	?vifMFIFOInterrupt@@YAXXZ		; vifMFIFOInterrupt
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	jmp	SHORT $LN386@recExecute
$LN363@recExecute:
	mov	edx, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	edx, eax
	cmp	edx, ecx
	jle	SHORT $LN374@recExecute
	add	ecx, eax
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
	jmp	SHORT $LN374@recExecute
$LN378@recExecute:
	mov	edx, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	edx, eax
	cmp	edx, ecx
	jle	SHORT $LN386@recExecute
	add	ecx, eax
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
$LN386@recExecute:
	test	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, 2048 ; 00000800H
	je	SHORT $LN398@recExecute
	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+876
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+748
	sub	ebx, eax
	cmp	ebx, ecx
	jl	SHORT $LN390@recExecute
	and	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, -2049 ; fffff7ffH
	call	?gifMFIFOInterrupt@@YAXXZ		; gifMFIFOInterrupt
	jmp	SHORT $LN398@recExecute
$LN390@recExecute:
	mov	edx, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	edx, eax
	cmp	edx, ecx
	jle	SHORT $LN398@recExecute
	add	ecx, eax
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
$LN398@recExecute:
	call	?psxBranchTest@@YAXXZ			; psxBranchTest
	cmp	BYTE PTR ?iopBranchAction@@3_NA, 0	; iopBranchAction
	je	SHORT $LN11@recExecute
	mov	eax, DWORD PTR ?EEsCycle@@3HA		; EEsCycle
	mov	ecx, DWORD PTR ?psxCpu@@3PAUR3000Acpu@@A ; psxCpu
	mov	edx, DWORD PTR [ecx+12]
	push	eax
	call	edx
	add	esp, 4
	mov	DWORD PTR ?EEsCycle@@3HA, eax		; EEsCycle
	mov	BYTE PTR ?iopBranchAction@@3_NA, 0	; iopBranchAction
$LN11@recExecute:
	test	BYTE PTR ?VU0@@3UVURegs@@A+976, 1
	je	SHORT $LN493@recExecute
	call	DWORD PTR ?CpuVU0@@3UVUmicroCpu@@A+8
	test	BYTE PTR ?VU0@@3UVURegs@@A+976, 1
	mov	eax, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	mov	esi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	je	SHORT $LN403@recExecute
	mov	ecx, eax
	sub	ecx, esi
	cmp	ecx, 768				; 00000300H
	jle	SHORT $LN403@recExecute
	lea	eax, DWORD PTR [esi+768]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
	jmp	SHORT $LN403@recExecute
$LN493@recExecute:
	mov	eax, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	mov	esi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
$LN403@recExecute:
	mov	edx, DWORD PTR ?EEsCycle@@3HA		; EEsCycle
	cmp	edx, 192				; 000000c0H
	jle	SHORT $LN408@recExecute
	mov	ecx, eax
	sub	ecx, esi
	cmp	ecx, 48					; 00000030H
	jle	SHORT $LN408@recExecute
	lea	eax, DWORD PTR [esi+48]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
$LN408@recExecute:
	mov	ecx, DWORD PTR ?g_psxNextBranchCycle@@3IA ; g_psxNextBranchCycle
	sub	ecx, DWORD PTR ?psxRegs@@3UpsxRegisters@@A+528
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	sub	ecx, edx
	mov	edx, eax
	sub	edx, esi
	cmp	edx, ecx
	jle	SHORT $LN413@recExecute
	lea	eax, DWORD PTR [esi+ecx]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
$LN413@recExecute:
	mov	ecx, DWORD PTR ?counters@@3PAUCounter@@A+188
	mov	edx, DWORD PTR ?counters@@3PAUCounter@@A+192
	mov	edi, eax
	sub	edi, ecx
	cmp	edi, edx
	jle	SHORT $LN416@recExecute
	lea	eax, DWORD PTR [ecx+edx]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
$LN416@recExecute:
	mov	ecx, DWORD PTR ?nextsCounter@@3IA	; nextsCounter
	mov	edx, DWORD PTR ?nextCounter@@3HA	; nextCounter
	mov	edi, eax
	sub	edi, ecx
	cmp	edi, edx
	jle	SHORT $LN419@recExecute
	lea	eax, DWORD PTR [ecx+edx]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
$LN419@recExecute:
	test	BYTE PTR ?cpuRegs@@3UcpuRegisters@@A+594, 1
	mov	BYTE PTR ?eeEventTestIsActive@@3_NA, 0	; eeEventTestIsActive
	je	$LN462@recExecute
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+592
	test	bl, 1
	je	$LN462@recExecute
	test	bl, 6
	jne	$LN462@recExecute
	test	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, 1073741824 ; 40000000H
	je	$LN442@recExecute
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+952
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+824
	mov	edi, esi
	sub	edi, ecx
	cmp	edi, edx
	jl	$LN427@recExecute
	and	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, -1073741825 ; bfffffffH
	test	ebx, 1024				; 00000400H
	je	$LN442@recExecute
	mov	edx, DWORD PTR ?psH@@3PAEA		; psH
	mov	ecx, DWORD PTR [edx+61440]
	test	ecx, ecx
	jne	SHORT $LN437@recExecute
	mov	esi, OFFSET ??_C@_0CH@FCDDAIFJ@?$CKPCSX2?$CK?3?5intcInterrupt?5already?5c@
	call	?Notice@Console@@YA_NPBD@Z		; Console::Notice
	jmp	SHORT $LN514@recExecute
$LN437@recExecute:
	mov	edx, DWORD PTR [edx+61456]
	and	edx, ecx
	je	SHORT $LN442@recExecute
	test	BYTE PTR ?varLog@@3IA, 4
	je	SHORT $LN441@recExecute
	push	edx
	push	OFFSET ??_C@_0BC@LCGONOKJ@intcInterrupt?5?$CFx?6?$AA@
	call	?SrcLog_HW@@YA_NPBDZZ			; SrcLog_HW
	add	esp, 8
$LN441@recExecute:
	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
	test	BYTE PTR [eax+61440], 2
	je	SHORT $LN435@recExecute
	xor	ecx, ecx
	call	?rcntRcount@@YIIH@Z			; rcntRcount
	mov	ecx, 1
	mov	DWORD PTR ?counters@@3PAUCounter@@A+12, eax
	call	?rcntRcount@@YIIH@Z			; rcntRcount
	mov	DWORD PTR ?counters@@3PAUCounter@@A+52, eax
$LN435@recExecute:
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+968
	push	ecx
	push	1024					; 00000400H
	call	?cpuException@@YAXII@Z			; cpuException
	add	esp, 8
$LN514@recExecute:
	mov	eax, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	mov	esi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+592
	jmp	SHORT $LN442@recExecute
$LN427@recExecute:
	mov	edi, eax
	sub	edi, ecx
	cmp	edi, edx
	jle	SHORT $LN442@recExecute
	lea	eax, DWORD PTR [edx+ecx]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
$LN442@recExecute:
	test	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, -2147483648 ; 80000000H
	je	$LN462@recExecute
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+956
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+828
	sub	esi, ecx
	cmp	esi, edx
	jl	$LN446@recExecute
	and	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, 2147483647 ; 7fffffffH
	and	ebx, 67591				; 00010807H
	cmp	ebx, 67585				; 00010801H
	jne	SHORT $LN462@recExecute
	mov	edx, DWORD PTR ?psH@@3PAEA		; psH
	movzx	eax, WORD PTR [edx+57360]
	mov	cx, WORD PTR [edx+57362]
	and	cx, ax
	jne	SHORT $LN455@recExecute
	test	eax, 32768				; 00008000H
	je	SHORT $LN462@recExecute
$LN455@recExecute:
	test	BYTE PTR [edx+57344], 1
	je	SHORT $LN462@recExecute
	test	BYTE PTR ?varLog@@3IA, 4
	je	SHORT $LN461@recExecute
	test	cx, cx
	jne	SHORT $LN459@recExecute
	test	eax, 32768				; 00008000H
	jne	SHORT $LN459@recExecute
	xor	eax, eax
	jmp	SHORT $LN460@recExecute
$LN459@recExecute:
	mov	eax, 1
$LN460@recExecute:
	push	eax
	push	OFFSET ??_C@_0BC@IOCBKJEO@dmacInterrupt?5?$CFx?6?$AA@
	call	?SrcLog_HW@@YA_NPBDZZ			; SrcLog_HW
	add	esp, 8
$LN461@recExecute:
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+968
	push	edx
	push	2048					; 00000800H
	call	?cpuException@@YAXII@Z			; cpuException
	add	esp, 8

; 817  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0

; 814  : 	}
; 815  : 	g_EEFreezeRegs = false;
; 816  : 	recEventTest();

$LN446@recExecute:
	sub	eax, ecx
	cmp	eax, edx
	jle	SHORT $LN462@recExecute
	add	edx, ecx
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, edx	; g_nextBranchCycle
$LN462@recExecute:

; 817  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?recExecuteBlock@@YAXXZ ENDP				; recExecuteBlock
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ?recExecute@@YAXXZ
_TEXT	SEGMENT
_count$872559 = -48					; size = 8
_sDeltaTime$872561 = -40				; size = 8
_count$872554 = -32					; size = 8
_result$872578 = -24					; size = 4
_change$872664 = -20					; size = 4
_tmp$872722 = -16					; size = 4
_tmp$872730 = -12					; size = 4
_i$872658 = -8						; size = 4
_retval$872657 = -1					; size = 1
_vsyncEvent$872313 = -1					; size = 1
?recExecute@@YAXXZ PROC					; recExecute, COMDAT

; 774  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	push	ebx
	push	esi
	push	edi
	npad	7
$LL3@recExecute@2:

; 775  : 	// Optimization note : Compared pushad against manually pushing the regs one-by-one.
; 776  : 	// Manually pushing is faster, especially on Core2's and such. :)
; 777  : 	do {
; 778  : 		g_EEFreezeRegs = true;

	mov	BYTE PTR ?g_EEFreezeRegs@@3_NA, 1	; g_EEFreezeRegs

; 779  : 		__asm
; 780  : 		{
; 781  : 			push ebx

	push	ebx

; 782  : 			push esi

	push	esi

; 783  : 			push edi

	push	edi

; 784  : 			push ebp

	push	ebp

; 785  : 
; 786  : 			call DispatcherReg

	call	?DispatcherReg@@YAXXZ			; DispatcherReg

; 787  : 			
; 788  : 			pop ebp

	pop	ebp

; 789  : 			pop edi

	pop	edi

; 790  : 			pop esi

	pop	esi

; 791  : 			pop ebx

	pop	ebx

; 792  : 		}
; 793  : 		g_EEFreezeRegs = false;
; 794  : 	}
; 795  : 	while( !recEventTest() );

	cmp	BYTE PTR ?g_globalXMMSaved@@3EA, 0	; g_globalXMMSaved
	mov	BYTE PTR ?g_EEFreezeRegs@@3_NA, 0	; g_EEFreezeRegs
	jne	SHORT $LN6@recExecute@2
	cmp	BYTE PTR ?g_globalMMXSaved@@3EA, 0	; g_globalMMXSaved
	je	$LN24@recExecute@2
$LN6@recExecute@2:
	mov	eax, DWORD PTR _hConsole
	mov	esi, DWORD PTR __imp__SetConsoleTextAttribute@8
	push	12					; 0000000cH
	push	eax
	call	esi
	mov	eax, DWORD PTR _hConsole
	test	eax, eax
	je	SHORT $LN19@recExecute@2
	push	0
	lea	ecx, DWORD PTR _tmp$872722[ebp]
	push	ecx
	push	52					; 00000034H
	push	OFFSET ??_C@_0DF@HHKJLMIF@Pcsx2?5Foopah?$CB?5?5Frozen?5regs?5have?5@
	push	eax
	call	DWORD PTR __imp__WriteConsoleA@20
$LN19@recExecute@2:
	mov	eax, DWORD PTR ?emuLog@@3PAU_iobuf@@A	; emuLog
	test	eax, eax
	je	SHORT $LN18@recExecute@2
	push	eax
	push	OFFSET ??_C@_0DF@HHKJLMIF@Pcsx2?5Foopah?$CB?5?5Frozen?5regs?5have?5@
	call	_fputs
	add	esp, 8
$LN18@recExecute@2:
	mov	edx, DWORD PTR _hConsole
	push	7
	push	edx
	call	esi
	mov	eax, DWORD PTR _hConsole
	test	eax, eax
	je	SHORT $LN25@recExecute@2
	push	0
	lea	ecx, DWORD PTR _tmp$872730[ebp]
	push	ecx
	push	2
	push	OFFSET ??_C@_02PCIJFNDE@?$AN?6?$AA@
	push	eax
	call	DWORD PTR __imp__WriteConsoleA@20
$LN25@recExecute@2:
	mov	eax, DWORD PTR ?emuLog@@3PAU_iobuf@@A	; emuLog
	test	eax, eax
	je	SHORT $LN24@recExecute@2
	push	eax
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	_fputs
	mov	edx, DWORD PTR ?emuLog@@3PAU_iobuf@@A	; emuLog
	push	edx
	call	_fflush
	add	esp, 12					; 0000000cH
$LN24@recExecute@2:
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	eax, DWORD PTR _eeWaitCycles
	add	eax, ebx
	mov	ecx, ebx
	sub	ecx, DWORD PTR ?EEoCycle@@3IA		; EEoCycle
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
	mov	eax, DWORD PTR ?EEsCycle@@3HA		; EEsCycle
	add	eax, ecx
	xor	esi, esi
	cmp	eax, esi
	mov	BYTE PTR ?eeEventTestIsActive@@3_NA, 1	; eeEventTestIsActive
	mov	DWORD PTR ?EEsCycle@@3HA, eax		; EEsCycle
	mov	DWORD PTR ?EEoCycle@@3IA, ebx		; EEoCycle
	jle	SHORT $LN35@recExecute@2
	mov	BYTE PTR ?iopBranchAction@@3_NA, 1	; iopBranchAction
$LN35@recExecute@2:
	mov	eax, DWORD PTR ?counters@@3PAUCounter@@A+188
	mov	edx, ebx
	sub	edx, eax
	cmp	edx, DWORD PTR ?counters@@3PAUCounter@@A+192
	mov	BYTE PTR _vsyncEvent$872313[ebp], 0
	jl	SHORT $LN503@recExecute@2
	test	BYTE PTR ?counters@@3PAUCounter@@A+164, 1
	je	$LN43@recExecute@2
	push	eax
	push	esi
	call	?rcntStartGate@@YIX_NI@Z		; rcntStartGate
	push	esi
	call	?psxCheckStartGate16@@YAXH@Z		; psxCheckStartGate16
	mov	eax, DWORD PTR _vSyncInfo+20
	mov	ecx, DWORD PTR _vSyncInfo+16
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	add	esp, 4
	add	DWORD PTR ?counters@@3PAUCounter@@A+188, eax
	mov	DWORD PTR ?counters@@3PAUCounter@@A+192, ecx
	mov	DWORD PTR ?counters@@3PAUCounter@@A+164, esi
$LN503@recExecute@2:
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
$LN42@recExecute@2:
	mov	eax, ebx
	sub	eax, DWORD PTR ?nextsCounter@@3IA	; nextsCounter
	cmp	eax, DWORD PTR ?nextCounter@@3HA	; nextCounter
	jl	$LN215@recExecute@2
	mov	ecx, DWORD PTR ?counters@@3PAUCounter@@A+228
	mov	eax, ebx
	sub	eax, ecx
	cmp	eax, DWORD PTR ?counters@@3PAUCounter@@A+232
	jl	$LN546@recExecute@2
	cmp	DWORD PTR ?counters@@3PAUCounter@@A+204, 3
	mov	ebx, ecx
	jne	$LN67@recExecute@2
	test	DWORD PTR ?varLog@@3IA, 1073741824	; varLog, 40000000H
	je	SHORT $LN76@recExecute@2
	mov	ecx, DWORD PTR _iFrame
	push	ecx
	push	OFFSET ??_C@_0DK@GPMLIACH@?1?1?1?1?1?1?1?1?1?5?5EE?5COUNTER?5VSYNC?5END?5@
	call	?SrcLog_EECNT@@YA_NPBDZZ		; SrcLog_EECNT
	add	esp, 8
$LN76@recExecute@2:
	inc	DWORD PTR _iFrame
	cmp	DWORD PTR ?g_vu1SkipCount@@3IA, esi	; g_vu1SkipCount
	jbe	$LN73@recExecute@2
	push	esi
	call	?gsPostVsyncEnd@@YAX_N@Z		; gsPostVsyncEnd
	add	esp, 4
	mov	ecx, OFFSET ?g_vu1SkipCount@@3IA	; g_vu1SkipCount
	mov	eax, -1
	lock	 xadd	 DWORD PTR [ecx], eax
	mov	DWORD PTR _result$872578[ebp], eax
	mov	DWORD PTR ?CpuVU1@@3UVUmicroCpu@@A+8, OFFSET ?DummyExecuteVU1Block@@YAXXZ ; DummyExecuteVU1Block
	jmp	$LN88@recExecute@2
$LN43@recExecute@2:
	test	BYTE PTR ?CSRw@@3IA, 4
	je	SHORT $LN41@recExecute@2
	mov	edx, DWORD PTR ?g_RealGSMem@@3PAEA+4100
	or	DWORD PTR ?g_RealGSMem@@3PAEA+4096, 4
	mov	DWORD PTR ?g_RealGSMem@@3PAEA+4100, edx
$LN41@recExecute@2:
	test	DWORD PTR ?g_RealGSMem@@3PAEA+4112, 1024 ; 00000400H
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	jne	SHORT $LN51@recExecute@2
	or	DWORD PTR [edi+61440], 1
	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
$LN51@recExecute@2:
	cmp	DWORD PTR ?gates@@3HA, esi		; gates
	je	SHORT $LN39@recExecute@2
	mov	eax, DWORD PTR ?counters@@3PAUCounter@@A+188
	push	eax
	push	esi
	call	?rcntEndGate@@YIX_NI@Z			; rcntEndGate
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
$LN39@recExecute@2:
	cmp	BYTE PTR ?psxhblankgate@@3EA, 0		; psxhblankgate
	je	SHORT $LN53@recExecute@2
	xor	eax, eax
	call	?_psxCheckEndGate@@YAXH@Z		; _psxCheckEndGate
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
$LN53@recExecute@2:
	mov	ecx, DWORD PTR _vSyncInfo+16
	mov	edx, DWORD PTR _vSyncInfo+20
	add	DWORD PTR ?counters@@3PAUCounter@@A+188, ecx
	mov	DWORD PTR ?counters@@3PAUCounter@@A+192, edx
	mov	DWORD PTR ?counters@@3PAUCounter@@A+164, 1
	jmp	$LN42@recExecute@2
$LN73@recExecute@2:
	push	1
	call	?gsPostVsyncEnd@@YAX_N@Z		; gsPostVsyncEnd
	add	esp, 4
	test	BYTE PTR ?g_Session@@3USessionOverrideFlags@@A, 4 ; g_Session
	jne	SHORT $LN87@recExecute@2
	test	BYTE PTR ?Config@@3UPcsxConfig@@A+3576, 64 ; 00000040H
	je	SHORT $LN87@recExecute@2
	mov	edx, DWORD PTR ?recVU1@@3UVUmicroCpu@@B+8
	mov	DWORD PTR ?CpuVU1@@3UVUmicroCpu@@A+8, edx
	jmp	SHORT $LN88@recExecute@2
$LN87@recExecute@2:
	mov	eax, DWORD PTR ?intVU1@@3UVUmicroCpu@@B+8
	mov	DWORD PTR ?CpuVU1@@3UVUmicroCpu@@A+8, eax
$LN88@recExecute@2:
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	or	DWORD PTR [edi+61440], 8
	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
	mov	eax, DWORD PTR ?psxH@@3PAEA		; psxH
	or	DWORD PTR [eax+4208], 2048		; 00000800H
	test	BYTE PTR ?psxvblankgate@@3EA, 2		; psxvblankgate
	je	SHORT $LN95@recExecute@2
	mov	eax, 1
	call	?_psxCheckEndGate@@YAXH@Z		; _psxCheckEndGate
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
$LN95@recExecute@2:
	test	BYTE PTR ?psxvblankgate@@3EA, 8		; psxvblankgate
	je	SHORT $LN97@recExecute@2
	mov	eax, 3
	call	?_psxCheckEndGate@@YAXH@Z		; _psxCheckEndGate
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
$LN97@recExecute@2:
	cmp	DWORD PTR ?gates@@3HA, esi		; gates
	je	SHORT $LN71@recExecute@2
	push	ebx
	push	1
	call	?rcntEndGate@@YIX_NI@Z			; rcntEndGate
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
$LN71@recExecute@2:
	test	DWORD PTR ?Config@@3UPcsxConfig@@A+3576, 3072 ; 00000c00H
	je	$LN498@recExecute@2
	cmp	DWORD PTR ?Config@@3UPcsxConfig@@A+3604, 999 ; 000003e7H
	jge	$LN498@recExecute@2
	mov	edi, DWORD PTR _m_iTicks
	add	edi, DWORD PTR _m_iStart
	mov	ebx, DWORD PTR _m_iTicks+4
	adc	ebx, DWORD PTR _m_iStart+4
	lea	ecx, DWORD PTR _count$872554[ebp]
	push	ecx
	call	DWORD PTR __imp__QueryPerformanceCounter@4
	mov	eax, DWORD PTR _count$872554[ebp]
	mov	edx, DWORD PTR _m_iTicks+4
	mov	esi, DWORD PTR _count$872554[ebp+4]
	push	0
	sub	eax, edi
	push	8
	mov	DWORD PTR _sDeltaTime$872561[ebp], eax
	mov	eax, DWORD PTR _m_iTicks
	push	edx
	push	eax
	sbb	esi, ebx
	call	__allmul
	cmp	esi, edx
	jl	SHORT $LN101@recExecute@2
	jg	SHORT $LN496@recExecute@2
	cmp	DWORD PTR _sDeltaTime$872561[ebp], eax
	jbe	SHORT $LN101@recExecute@2
$LN496@recExecute@2:
	mov	eax, DWORD PTR _count$872554[ebp]
	sub	eax, DWORD PTR _m_iTicks
	mov	ecx, DWORD PTR _count$872554[ebp+4]
	sbb	ecx, DWORD PTR _m_iTicks+4
	mov	DWORD PTR _m_iStart, eax
	sub	eax, edi
	mov	DWORD PTR _m_iStart+4, ecx
	call	?gsSyncLimiterLostTime@@YAXH@Z		; gsSyncLimiterLostTime
	jmp	SHORT $LN504@recExecute@2
$LN101@recExecute@2:
	mov	DWORD PTR _m_iStart, edi
	mov	DWORD PTR _m_iStart+4, ebx
	test	esi, esi
	jg	SHORT $LN504@recExecute@2
	jl	SHORT $LN499@recExecute@2
	cmp	DWORD PTR _sDeltaTime$872561[ebp], 0
	jae	SHORT $LN504@recExecute@2
$LN499@recExecute@2:
	mov	esi, DWORD PTR __imp__QueryPerformanceCounter@4
$LL100@recExecute@2:
	push	0
	call	DWORD PTR __imp__Sleep@4
	lea	ecx, DWORD PTR _count$872559[ebp]
	push	ecx
	call	esi
	mov	eax, DWORD PTR _count$872559[ebp]
	mov	edx, DWORD PTR _count$872559[ebp+4]
	sub	eax, edi
	sbb	edx, ebx
	mov	DWORD PTR _sDeltaTime$872561[ebp+4], edx
	js	SHORT $LL100@recExecute@2
	jg	SHORT $LN504@recExecute@2
	test	eax, eax
	jb	SHORT $LL100@recExecute@2
$LN504@recExecute@2:
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
$LN498@recExecute@2:
	mov	eax, DWORD PTR _vSyncInfo+8
	mov	ecx, DWORD PTR _vSyncInfo+4
	add	DWORD PTR ?counters@@3PAUCounter@@A+228, eax
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	DWORD PTR ?counters@@3PAUCounter@@A+232, ecx
	mov	DWORD PTR ?counters@@3PAUCounter@@A+204, 0
	mov	BYTE PTR _retval$872657[ebp], 1
	jmp	$LN69@recExecute@2
$LN67@recExecute@2:
	test	DWORD PTR ?varLog@@3IA, 1073741824	; varLog, 40000000H
	je	SHORT $LN118@recExecute@2
	mov	edx, DWORD PTR _iFrame
	push	edx
	push	OFFSET ??_C@_0DM@NMBMHAFB@?1?1?1?1?1?1?1?1?1?5?5EE?5COUNTER?5VSYNC?5STAR@
	call	?SrcLog_EECNT@@YA_NPBDZZ		; SrcLog_EECNT
	add	esp, 8
$LN118@recExecute@2:
	call	?vSyncDebugStuff@@YAXXZ			; vSyncDebugStuff
	test	BYTE PTR ?CSRw@@3IA, 8
	je	SHORT $LN115@recExecute@2
	mov	eax, DWORD PTR ?g_RealGSMem@@3PAEA+4100
	or	DWORD PTR ?g_RealGSMem@@3PAEA+4096, 8
	mov	DWORD PTR ?g_RealGSMem@@3PAEA+4100, eax
$LN115@recExecute@2:
	test	DWORD PTR ?g_RealGSMem@@3PAEA+4112, 2048 ; 00000800H
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	jne	SHORT $LN121@recExecute@2
	or	DWORD PTR [edi+61440], 1
	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
$LN121@recExecute@2:
	or	DWORD PTR [edi+61440], 4
	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
	call	?cdvdVsync@@YAXXZ			; cdvdVsync
	mov	eax, DWORD PTR ?psxH@@3PAEA		; psxH
	or	DWORD PTR [eax+4208], 1
	test	BYTE PTR ?psxvblankgate@@3EA, 2		; psxvblankgate
	je	SHORT $LN126@recExecute@2
	push	1
	call	?psxCheckStartGate16@@YAXH@Z		; psxCheckStartGate16
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	add	esp, 4
$LN126@recExecute@2:
	test	BYTE PTR ?psxvblankgate@@3EA, 8		; psxvblankgate
	je	SHORT $LN148@recExecute@2
	mov	eax, 3
	call	?_psxCheckStartGate@@YAXH@Z		; _psxCheckStartGate
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
$LN148@recExecute@2:
	cmp	DWORD PTR ?gates@@3HA, esi		; gates
	je	SHORT $LN113@recExecute@2
	push	ebx
	push	1
	call	?rcntStartGate@@YIX_NI@Z		; rcntStartGate
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
$LN113@recExecute@2:
	cmp	DWORD PTR ?Config@@3UPcsxConfig@@A+3596, esi
	je	SHORT $LN150@recExecute@2
	xor	ebx, ebx
	cmp	DWORD PTR ?patchnumber@@3HA, esi	; patchnumber
	jle	SHORT $LN150@recExecute@2
	mov	esi, OFFSET ?patch@@3PAUIniPatch@@A	; patch
$LL152@recExecute@2:
	cmp	DWORD PTR [esi+16], 1
	jne	SHORT $LN151@recExecute@2
	mov	eax, esi
	call	?_applypatch@@YAXHPAUIniPatch@@@Z	; _applypatch
$LN151@recExecute@2:
	inc	ebx
	add	esi, 32					; 00000020H
	cmp	ebx, DWORD PTR ?patchnumber@@3HA	; patchnumber
	jl	SHORT $LL152@recExecute@2
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
$LN150@recExecute@2:
	mov	ecx, DWORD PTR _vSyncInfo+4
	mov	edx, DWORD PTR _vSyncInfo+8
	mov	eax, DWORD PTR _vSyncInfo+12
	add	DWORD PTR ?counters@@3PAUCounter@@A+228, ecx
	add	DWORD PTR ?counters@@3PAUCounter@@A+188, eax
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	DWORD PTR ?counters@@3PAUCounter@@A+232, edx
	mov	DWORD PTR ?counters@@3PAUCounter@@A+204, 3
$LN546@recExecute@2:
	mov	BYTE PTR _retval$872657[ebp], 0
$LN69@recExecute@2:
	mov	DWORD PTR _i$872658[ebp], 0
	mov	esi, OFFSET ?counters@@3PAUCounter@@A+4
$LN63@recExecute@2:
	mov	eax, DWORD PTR [esi]
	test	al, al
	jns	$LN62@recExecute@2
	and	eax, 3
	cmp	al, 3
	je	$LN59@recExecute@2
	mov	eax, ebx
	sub	eax, DWORD PTR [esi+32]
	mov	DWORD PTR _change$872664[ebp], eax
	jns	SHORT $LN58@recExecute@2
	xor	eax, eax
	mov	DWORD PTR _change$872664[ebp], eax
$LN58@recExecute@2:
	mov	ecx, DWORD PTR [esi+12]
	xor	edx, edx
	div	ecx
	mov	edx, ebx
	add	DWORD PTR [esi-4], eax
	imul	eax, ecx
	mov	ecx, DWORD PTR _change$872664[ebp]
	sub	ecx, eax
	mov	eax, DWORD PTR [esi+4]
	sub	edx, ecx
	mov	ecx, DWORD PTR [esi-4]
	mov	DWORD PTR [esi+32], edx
	cmp	ecx, eax
	jb	SHORT $LN183@recExecute@2
	test	DWORD PTR [esi], 256			; 00000100H
	je	SHORT $LN186@recExecute@2
	test	DWORD PTR ?varLog@@3IA, 1073741824	; varLog, 40000000H
	je	SHORT $LN190@recExecute@2
	push	eax
	mov	eax, DWORD PTR [esi]
	push	ecx
	mov	ecx, DWORD PTR _i$872658[ebp]
	push	eax
	push	ecx
	push	OFFSET ??_C@_0DO@EGNLMAGK@EE?5Counter?$FL?$CFd?$FN?5TARGET?5reached?5?9?5@
	call	?SrcLog_EECNT@@YA_NPBDZZ		; SrcLog_EECNT
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	add	esp, 20					; 00000014H
$LN190@recExecute@2:
	mov	ecx, DWORD PTR [esi+16]
	or	DWORD PTR [esi], 1024			; 00000400H
	mov	edx, 1
	shl	edx, cl
	or	DWORD PTR [edi+61440], edx
	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
	test	BYTE PTR [esi], 64			; 00000040H
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	je	SHORT $LN185@recExecute@2
	mov	eax, DWORD PTR [esi+4]
	sub	DWORD PTR [esi-4], eax
	jmp	SHORT $LN183@recExecute@2
$LN185@recExecute@2:
	or	DWORD PTR [esi+4], 268435456		; 10000000H
	jmp	SHORT $LN183@recExecute@2
$LN186@recExecute@2:
	or	eax, 268435456				; 10000000H
	mov	DWORD PTR [esi+4], eax
$LN183@recExecute@2:
	mov	eax, DWORD PTR [esi-4]
	cmp	eax, 65535				; 0000ffffH
	jbe	SHORT $LN62@recExecute@2
	test	DWORD PTR [esi], 512			; 00000200H
	je	SHORT $LN198@recExecute@2
	test	DWORD PTR ?varLog@@3IA, 1073741824	; varLog, 40000000H
	je	SHORT $LN197@recExecute@2
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR _i$872658[ebp]
	push	eax
	push	ecx
	push	edx
	push	OFFSET ??_C@_0CN@DJCFHOEE@EE?5Counter?$FL?$CFd?$FN?5OVERFLOW?5?9?5mode?$DN?$CF@
	call	?SrcLog_EECNT@@YA_NPBDZZ		; SrcLog_EECNT
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	add	esp, 16					; 00000010H
$LN197@recExecute@2:
	mov	ecx, DWORD PTR [esi+16]
	or	DWORD PTR [esi], 2048			; 00000800H
	mov	eax, 1
	shl	eax, cl
	or	DWORD PTR [edi+61440], eax
	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
$LN198@recExecute@2:
	add	DWORD PTR [esi-4], -65536		; ffff0000H
	xor	ecx, ecx
	mov	WORD PTR [esi+6], cx
	jmp	SHORT $LN62@recExecute@2
$LN59@recExecute@2:
	mov	DWORD PTR [esi+32], ebx
$LN62@recExecute@2:
	inc	DWORD PTR _i$872658[ebp]
	add	esi, 40					; 00000028H
	cmp	esi, OFFSET ?counters@@3PAUCounter@@A+124
	jle	$LN63@recExecute@2
	mov	esi, DWORD PTR ?counters@@3PAUCounter@@A+232
	sub	esi, ebx
	add	esi, DWORD PTR ?counters@@3PAUCounter@@A+228
	mov	DWORD PTR ?nextsCounter@@3IA, ebx	; nextsCounter
	mov	DWORD PTR ?nextCounter@@3HA, esi	; nextCounter
	mov	edx, OFFSET ?counters@@3PAUCounter@@A+8
	npad	6
$LL203@recExecute@2:
	mov	eax, DWORD PTR [edx-4]
	test	al, al
	jns	SHORT $LN202@recExecute@2
	and	eax, 3
	cmp	al, 3
	je	SHORT $LN202@recExecute@2
	mov	esi, DWORD PTR [edx-8]
	cmp	esi, 65536				; 00010000H
	ja	SHORT $LN209@recExecute@2
	mov	ecx, DWORD PTR [edx]
	cmp	esi, ecx
	ja	SHORT $LN209@recExecute@2
	mov	eax, 65536				; 00010000H
	sub	eax, esi
	imul	eax, DWORD PTR [edx+8]
	mov	esi, DWORD PTR ?nextCounter@@3HA	; nextCounter
	sub	eax, ebx
	add	eax, DWORD PTR [edx+28]
	cmp	eax, esi
	jge	SHORT $LN208@recExecute@2
	mov	esi, eax
	mov	DWORD PTR ?nextCounter@@3HA, esi	; nextCounter
$LN208@recExecute@2:
	test	ecx, 268435456				; 10000000H
	jne	SHORT $LN202@recExecute@2
	sub	ecx, DWORD PTR [edx-8]
	imul	ecx, DWORD PTR [edx+8]
	sub	ecx, ebx
	add	ecx, DWORD PTR [edx+28]
	cmp	ecx, esi
	jge	SHORT $LN202@recExecute@2
	mov	esi, ecx
	jmp	SHORT $LN547@recExecute@2
$LN209@recExecute@2:
	mov	esi, 4
$LN547@recExecute@2:
	mov	DWORD PTR ?nextCounter@@3HA, esi	; nextCounter
$LN202@recExecute@2:
	add	edx, 40					; 00000028H
	cmp	edx, OFFSET ?counters@@3PAUCounter@@A+168
	jl	SHORT $LL203@recExecute@2
	test	esi, esi
	jge	SHORT $LN200@recExecute@2
	mov	DWORD PTR ?nextCounter@@3HA, 0		; nextCounter
$LN200@recExecute@2:
	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+688
	mov	dl, BYTE PTR _retval$872657[ebp]
	mov	ecx, eax
	and	ecx, -2147482656			; 800003e0H
	mov	BYTE PTR _vsyncEvent$872313[ebp], dl
	cmp	ecx, -2147483616			; 80000020H
	jne	SHORT $LN216@recExecute@2
	mov	edx, ebx
	sub	edx, DWORD PTR ?s_iLastPERFCycle@@3PAIA
	mov	DWORD PTR ?s_iLastPERFCycle@@3PAIA, ebx
	add	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+692, edx
$LN216@recExecute@2:
	and	eax, -2146467840			; 800f8000H
	cmp	eax, -2147450880			; 80008000H
	jne	SHORT $LN505@recExecute@2
	mov	eax, ebx
	sub	eax, DWORD PTR ?s_iLastPERFCycle@@3PAIA+4
	mov	DWORD PTR ?s_iLastPERFCycle@@3PAIA+4, ebx
	add	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+696, eax
$LN505@recExecute@2:
	xor	esi, esi
$LN215@recExecute@2:
	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+580
	mov	ecx, ebx
	sub	ecx, DWORD PTR ?s_iLastCOP0Cycle@@3IA	; s_iLastCOP0Cycle
	mov	DWORD PTR ?s_iLastCOP0Cycle@@3IA, ebx	; s_iLastCOP0Cycle
	add	eax, ecx
	test	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+592, 32768 ; 00008000H
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+580, eax
	je	SHORT $LN219@recExecute@2
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+588
	cmp	eax, ecx
	jb	SHORT $LN219@recExecute@2
	lea	edx, DWORD PTR [ecx+1000]
	cmp	eax, edx
	jae	SHORT $LN219@recExecute@2
	push	ecx
	push	eax
	push	esi
	push	OFFSET ??_C@_0BC@KKHOMMCD@timr?5intr?3?5?$CFx?0?5?$CFx?$AA@
	call	?Status@Console@@YA_NPBDPBU_VARG_PARAM@@ZZ ; Console::Status
	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+968
	push	eax
	push	8421376					; 00808000H
	call	?cpuException@@YAXII@Z			; cpuException
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	add	esp, 24					; 00000018H
$LN219@recExecute@2:
	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
	test	eax, 1073741823				; 3fffffffH
	je	$LN419@recExecute@2
	test	al, 2
	je	$LN268@recExecute@2
	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+836
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+708
	mov	edx, ebx
	sub	edx, eax
	cmp	edx, ecx
	jl	$LN226@recExecute@2
	and	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, -3 ; fffffffdH
	test	DWORD PTR ?varLog@@3IA, 1024		; varLog, 00000400H
	je	SHORT $LN249@recExecute@2
	push	ebx
	push	OFFSET ??_C@_0BG@OEMEHKAM@vif1Interrupt?3?5?$CF8?48x?6?$AA@
	call	?SrcLog_VIF@@YA_NPBDZZ			; SrcLog_VIF
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	add	esp, 8
$LN249@recExecute@2:
	mov	DWORD PTR ?g_vifCycles@@3HA, esi	; g_vifCycles
	cmp	DWORD PTR ?vif1@@3UvifStruct@@A+20, esi
	je	$LN244@recExecute@2
	cmp	DWORD PTR ?vif1@@3UvifStruct@@A+4, esi
	jne	$LN244@recExecute@2
	or	DWORD PTR [edi+15360], 2048		; 00000800H
	or	DWORD PTR [edi+61440], 32		; 00000020H
	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
	dec	DWORD PTR ?vif1@@3UvifStruct@@A+20
	mov	eax, DWORD PTR [edi+15360]
	test	eax, 1792				; 00000700H
	je	SHORT $LN245@recExecute@2
	and	eax, -520093697				; e0ffffffH
	and	DWORD PTR [edi+36864], -257		; fffffeffH
	mov	DWORD PTR [edi+15360], eax
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	jmp	SHORT $LN268@recExecute@2
$LN245@recExecute@2:
	cmp	WORD PTR [edi+36896], si
	ja	SHORT $LN243@recExecute@2
	cmp	BYTE PTR ?vif1@@3UvifStruct@@A+36, 0
	jbe	$LN244@recExecute@2
$LN243@recExecute@2:
	cmp	BYTE PTR ?vif1@@3UvifStruct@@A+35, 1
	jne	SHORT $LN242@recExecute@2
$LN238@recExecute@2:
	call	?_chainVIF1@@YAHXZ			; _chainVIF1
	jmp	SHORT $LN241@recExecute@2
$LN242@recExecute@2:
	call	?_VIF1chain@@YAHXZ			; _VIF1chain
$LN241@recExecute@2:
	mov	eax, DWORD PTR ?g_vifCycles@@3HA	; g_vifCycles
	or	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, 2
	cmp	eax, 28					; 0000001cH
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+836, ebx
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+708, eax
	jg	SHORT $LN260@recExecute@2
	mov	ecx, DWORD PTR ?psxCycleEE@@3HA		; psxCycleEE
	cmp	ecx, esi
	jle	SHORT $LN260@recExecute@2
	add	DWORD PTR ?psxBreak@@3HA, ecx		; psxBreak
	mov	DWORD PTR ?psxCycleEE@@3HA, esi		; psxCycleEE
$LN260@recExecute@2:
	mov	ecx, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	ecx, ebx
	cmp	ecx, eax
	jle	SHORT $LN507@recExecute@2
	add	eax, ebx
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
$LN507@recExecute@2:
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
$LN268@recExecute@2:
	test	BYTE PTR ?cpuRegs@@3UcpuRegisters@@A+964, 4
	je	$LN296@recExecute@2
	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+840
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+712
	mov	edx, ebx
	sub	edx, eax
	cmp	edx, ecx
	jl	$LN272@recExecute@2
	and	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, -5 ; fffffffbH
	test	DWORD PTR ?varLog@@3IA, 4096		; varLog, 00001000H
	je	SHORT $LN287@recExecute@2
	push	ebx
	push	OFFSET ??_C@_0BE@FPDFMCPK@gsInterrupt?3?5?$CF8?48x?6?$AA@
	call	?SrcLog_GIF@@YA_NPBDZZ			; SrcLog_GIF
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	add	esp, 8
$LN287@recExecute@2:
	test	DWORD PTR [edi+40960], 256		; 00000100H
	je	$LN296@recExecute@2
	cmp	WORD PTR [edi+40992], si
	ja	SHORT $LN282@recExecute@2
	cmp	DWORD PTR _gspath3done, esi
	jne	$LN280@recExecute@2
$LN282@recExecute@2:
	test	BYTE PTR [edi+57344], 1
	jne	$LN281@recExecute@2
	mov	esi, OFFSET ??_C@_0CA@OMBBMBNE@gs?5dma?5masked?0?5re?9scheduling?4?4?4?$AA@
	call	?Notice@Console@@YA_NPBD@Z		; Console::Notice
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	eax, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	or	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, 4
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	sub	eax, ebx
	xor	esi, esi
	cmp	eax, 64					; 00000040H
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+840, ebx
	mov	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+712, 64 ; 00000040H
	jle	$LN296@recExecute@2
	lea	ecx, DWORD PTR [ebx+64]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
	jmp	$LN296@recExecute@2
$LN244@recExecute@2:
	mov	eax, DWORD PTR [edi+36864]
	test	eax, 256				; 00000100H
	jne	SHORT $LN240@recExecute@2
	push	eax
	push	OFFSET ??_C@_0BO@KFAMBPHK@Vif1?5running?5when?5CHCR?5?$DN?$DN?5?$CFx?6?$AA@
	call	?SysPrintf@@YAXPBDZZ			; SysPrintf
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	add	esp, 8
$LN240@recExecute@2:
	mov	edx, DWORD PTR [edi+36864]
	and	edx, 260				; 00000104H
	cmp	edx, 260				; 00000104H
	jne	SHORT $LN239@recExecute@2
	cmp	BYTE PTR ?vif1@@3UvifStruct@@A+33, 0
	jne	SHORT $LN239@recExecute@2
	test	BYTE PTR [edi+57344], 1
	jne	$LN238@recExecute@2
	push	OFFSET ??_C@_0BB@EELLKNKM@vif1?5dma?5masked?6?$AA@
	call	?SysPrintf@@YAXPBDZZ			; SysPrintf
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	add	esp, 4
	jmp	$LN507@recExecute@2
$LN239@recExecute@2:
	cmp	WORD PTR [edi+36896], si
	jbe	SHORT $LN237@recExecute@2
	push	OFFSET ??_C@_0BO@OINNBNMI@VIF1?5Ending?5with?5?$CFx?5QWC?5left?6?$AA@
	call	?SysPrintf@@YAXPBDZZ			; SysPrintf
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	add	esp, 4
$LN237@recExecute@2:
	mov	eax, DWORD PTR ?vif1@@3UvifStruct@@A+16
	cmp	eax, esi
	je	SHORT $LN236@recExecute@2
	push	eax
	push	OFFSET ??_C@_0BH@OMPPLFGP@vif1?4cmd?5still?5set?5?$CFx?6?$AA@
	call	?SysPrintf@@YAXPBDZZ			; SysPrintf
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	add	esp, 8
$LN236@recExecute@2:
	and	DWORD PTR [edi+36864], -257		; fffffeffH
	mov	ecx, 1
	mov	DWORD PTR _prevviftag, esi
	mov	DWORD PTR _prevvifcycles, esi
	call	?hwDmacIrq@@YAXH@Z			; hwDmacIrq
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	cmp	DWORD PTR [edi+15600], esi
	je	SHORT $LN234@recExecute@2
	test	BYTE PTR [edi+36864], 1
	je	SHORT $LN506@recExecute@2
$LN234@recExecute@2:
	and	DWORD PTR [edi+15360], -520093697	; e0ffffffH
$LN506@recExecute@2:
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	jmp	$LN268@recExecute@2
$LN226@recExecute@2:
	mov	edx, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	edx, eax
	cmp	edx, ecx
	jle	$LN268@recExecute@2
	add	ecx, eax
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
	jmp	$LN268@recExecute@2
$LN281@recExecute@2:
	call	?GIFdma@@YAXXZ				; GIFdma
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	cmp	DWORD PTR _gspath3done, esi
	je	SHORT $LN509@recExecute@2
$LN280@recExecute@2:
	mov	DWORD PTR _gspath3done, esi
	mov	DWORD PTR _gscycles, esi
	and	DWORD PTR [edi+40960], -257		; fffffeffH
	mov	edx, DWORD PTR ?g_RealGSMem@@3PAEA+4096
	mov	eax, DWORD PTR ?g_RealGSMem@@3PAEA+4100
	and	edx, -32769				; ffff7fffH
	or	edx, 16384				; 00004000H
	mov	DWORD PTR ?g_RealGSMem@@3PAEA+4096, edx
	mov	DWORD PTR ?g_RealGSMem@@3PAEA+4100, eax
	and	DWORD PTR [edi+12320], -520097281	; e0fff1ffH
	mov	ecx, 2
	mov	DWORD PTR ?Path3transfer@@3HA, esi	; Path3transfer
	call	?hwDmacIrq@@YAXH@Z			; hwDmacIrq
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
$LN509@recExecute@2:
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
$LN296@recExecute@2:
	test	BYTE PTR ?cpuRegs@@3UcpuRegisters@@A+964, 32 ; 00000020H
	je	SHORT $LN310@recExecute@2
	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+852
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+724
	mov	edx, ebx
	sub	edx, eax
	cmp	edx, ecx
	jl	SHORT $LN300@recExecute@2
	and	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, -33 ; ffffffdfH
	and	DWORD PTR [edi+49152], -257		; fffffeffH
	mov	ecx, 5
	call	?hwDmacIrq@@YAXH@Z			; hwDmacIrq
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	jmp	SHORT $LN310@recExecute@2
$LN272@recExecute@2:
	mov	edx, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	edx, eax
	cmp	edx, ecx
	jle	SHORT $LN296@recExecute@2
	add	ecx, eax
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
	jmp	SHORT $LN296@recExecute@2
$LN300@recExecute@2:
	mov	edx, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	edx, eax
	cmp	edx, ecx
	jle	SHORT $LN310@recExecute@2
	add	ecx, eax
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
$LN310@recExecute@2:
	test	BYTE PTR ?cpuRegs@@3UcpuRegisters@@A+964, 64 ; 00000040H
	je	SHORT $LN324@recExecute@2
	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+856
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+728
	mov	edx, ebx
	sub	edx, eax
	cmp	edx, ecx
	jl	SHORT $LN314@recExecute@2
	and	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, -65 ; ffffffbfH
	mov	ecx, 6
	call	?hwDmacIrq@@YAXH@Z			; hwDmacIrq
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	and	DWORD PTR [edi+50176], -257		; fffffeffH
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	jmp	SHORT $LN324@recExecute@2
$LN314@recExecute@2:
	mov	edx, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	edx, eax
	cmp	edx, ecx
	jle	SHORT $LN324@recExecute@2
	add	ecx, eax
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
$LN324@recExecute@2:
	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964
	test	eax, 3865				; 00000f19H
	je	$LN419@recExecute@2
	test	al, 1
	je	SHORT $LN336@recExecute@2
	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+832
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+704
	mov	edx, ebx
	sub	edx, eax
	cmp	edx, ecx
	jl	SHORT $LN328@recExecute@2
	and	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, -2 ; fffffffeH
	call	?vif0Interrupt@@YAXXZ			; vif0Interrupt
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	jmp	SHORT $LN336@recExecute@2
$LN328@recExecute@2:
	mov	edx, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	edx, eax
	cmp	edx, ecx
	jle	SHORT $LN336@recExecute@2
	add	ecx, eax
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
$LN336@recExecute@2:
	test	BYTE PTR ?cpuRegs@@3UcpuRegisters@@A+964, 8
	je	SHORT $LN348@recExecute@2
	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+844
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+716
	mov	edx, ebx
	sub	edx, eax
	cmp	edx, ecx
	jl	SHORT $LN340@recExecute@2
	and	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, -9 ; fffffff7H
	call	?ipu0Interrupt@@YAXXZ			; ipu0Interrupt
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	jmp	SHORT $LN348@recExecute@2
$LN340@recExecute@2:
	mov	edx, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	edx, eax
	cmp	edx, ecx
	jle	SHORT $LN348@recExecute@2
	add	ecx, eax
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
$LN348@recExecute@2:
	test	BYTE PTR ?cpuRegs@@3UcpuRegisters@@A+964, 16 ; 00000010H
	je	$LN368@recExecute@2
	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+848
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+720
	mov	edx, ebx
	sub	edx, eax
	cmp	edx, ecx
	jl	SHORT $LN352@recExecute@2
	and	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, -17 ; ffffffefH
	test	DWORD PTR ?varLog@@3IA, 16384		; varLog, 00004000H
	je	SHORT $LN365@recExecute@2
	push	ebx
	push	OFFSET ??_C@_0BD@IOONBAFN@ipu1Interrupt?5?$CFx?3?6?$AA@
	call	?SrcLog_IPU@@YA_NPBDZZ			; SrcLog_IPU
	mov	edi, DWORD PTR ?psH@@3PAEA		; psH
	add	esp, 8
$LN365@recExecute@2:
	test	BYTE PTR _g_nDMATransfer, 64		; 00000040H
	je	SHORT $LN362@recExecute@2
	or	DWORD PTR [edi+61440], 256		; 00000100H
	call	?cpuTestINTCInts@@YAXXZ			; cpuTestINTCInts
	and	DWORD PTR _g_nDMATransfer, -65		; ffffffbfH
$LN362@recExecute@2:
	test	BYTE PTR _g_nDMATransfer, 4
	je	SHORT $LN361@recExecute@2
	and	DWORD PTR _g_nDMATransfer, -5		; fffffffbH
	jmp	SHORT $LN360@recExecute@2
$LN361@recExecute@2:
	and	DWORD PTR [edi+46080], -257		; fffffeffH
$LN360@recExecute@2:
	mov	ecx, 4
	call	?hwDmacIrq@@YAXH@Z			; hwDmacIrq
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	jmp	SHORT $LN368@recExecute@2
$LN352@recExecute@2:
	mov	edx, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	edx, eax
	cmp	edx, ecx
	jle	SHORT $LN368@recExecute@2
	add	ecx, eax
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
$LN368@recExecute@2:
	test	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, 256 ; 00000100H
	je	SHORT $LN380@recExecute@2
	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+864
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+736
	mov	edx, ebx
	sub	edx, eax
	cmp	edx, ecx
	jl	SHORT $LN372@recExecute@2
	and	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, -257 ; fffffeffH
	call	?SPRFROMinterrupt@@YAXXZ		; SPRFROMinterrupt
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	jmp	SHORT $LN380@recExecute@2
$LN372@recExecute@2:
	mov	edx, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	edx, eax
	cmp	edx, ecx
	jle	SHORT $LN380@recExecute@2
	add	ecx, eax
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
$LN380@recExecute@2:
	test	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, 512 ; 00000200H
	je	SHORT $LN395@recExecute@2
	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+868
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+740
	mov	edx, ebx
	sub	edx, eax
	cmp	edx, ecx
	jl	SHORT $LN384@recExecute@2
	and	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, -513 ; fffffdffH
	call	?_dmaSPR1@@YAXXZ			; _dmaSPR1
	cmp	DWORD PTR ?spr1finished@@3HA, esi	; spr1finished
	je	SHORT $LN511@recExecute@2
	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
	and	DWORD PTR [eax+54272], -257		; fffffeffH
	mov	ecx, 9
	call	?hwDmacIrq@@YAXH@Z			; hwDmacIrq
$LN511@recExecute@2:
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
$LN395@recExecute@2:
	test	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, 1024 ; 00000400H
	je	SHORT $LN407@recExecute@2
	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+872
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+744
	mov	edx, ebx
	sub	edx, eax
	cmp	edx, ecx
	jl	SHORT $LN399@recExecute@2
	and	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, -1025 ; fffffbffH
	call	?vifMFIFOInterrupt@@YAXXZ		; vifMFIFOInterrupt
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	jmp	SHORT $LN407@recExecute@2
$LN384@recExecute@2:
	mov	edx, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	edx, eax
	cmp	edx, ecx
	jle	SHORT $LN395@recExecute@2
	add	ecx, eax
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
	jmp	SHORT $LN395@recExecute@2
$LN399@recExecute@2:
	mov	edx, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	edx, eax
	cmp	edx, ecx
	jle	SHORT $LN407@recExecute@2
	add	ecx, eax
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
$LN407@recExecute@2:
	test	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, 2048 ; 00000800H
	je	SHORT $LN419@recExecute@2
	mov	eax, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+876
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+748
	sub	ebx, eax
	cmp	ebx, ecx
	jl	SHORT $LN411@recExecute@2
	and	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, -2049 ; fffff7ffH
	call	?gifMFIFOInterrupt@@YAXXZ		; gifMFIFOInterrupt
	jmp	SHORT $LN419@recExecute@2
$LN411@recExecute@2:
	mov	edx, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	sub	edx, eax
	cmp	edx, ecx
	jle	SHORT $LN419@recExecute@2
	add	ecx, eax
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, ecx	; g_nextBranchCycle
$LN419@recExecute@2:
	call	?psxBranchTest@@YAXXZ			; psxBranchTest
	cmp	BYTE PTR ?iopBranchAction@@3_NA, 0	; iopBranchAction
	je	SHORT $LN32@recExecute@2
	mov	eax, DWORD PTR ?EEsCycle@@3HA		; EEsCycle
	mov	ecx, DWORD PTR ?psxCpu@@3PAUR3000Acpu@@A ; psxCpu
	mov	edx, DWORD PTR [ecx+12]
	push	eax
	call	edx
	add	esp, 4
	mov	DWORD PTR ?EEsCycle@@3HA, eax		; EEsCycle
	mov	BYTE PTR ?iopBranchAction@@3_NA, 0	; iopBranchAction
$LN32@recExecute@2:
	test	BYTE PTR ?VU0@@3UVURegs@@A+976, 1
	je	SHORT $LN515@recExecute@2
	call	DWORD PTR ?CpuVU0@@3UVUmicroCpu@@A+8
	test	BYTE PTR ?VU0@@3UVURegs@@A+976, 1
	mov	eax, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	je	SHORT $LN424@recExecute@2
	mov	ecx, eax
	sub	ecx, ebx
	cmp	ecx, 768				; 00000300H
	jle	SHORT $LN424@recExecute@2
	lea	eax, DWORD PTR [ebx+768]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
	jmp	SHORT $LN424@recExecute@2
$LN515@recExecute@2:
	mov	eax, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
$LN424@recExecute@2:
	mov	edx, DWORD PTR ?EEsCycle@@3HA		; EEsCycle
	cmp	edx, 192				; 000000c0H
	jle	SHORT $LN429@recExecute@2
	mov	ecx, eax
	sub	ecx, ebx
	cmp	ecx, 48					; 00000030H
	jle	SHORT $LN429@recExecute@2
	lea	eax, DWORD PTR [ebx+48]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
$LN429@recExecute@2:
	mov	ecx, DWORD PTR ?g_psxNextBranchCycle@@3IA ; g_psxNextBranchCycle
	sub	ecx, DWORD PTR ?psxRegs@@3UpsxRegisters@@A+528
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	sub	ecx, edx
	mov	edx, eax
	sub	edx, ebx
	cmp	edx, ecx
	jle	SHORT $LN434@recExecute@2
	lea	eax, DWORD PTR [ebx+ecx]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
$LN434@recExecute@2:
	mov	ecx, DWORD PTR ?counters@@3PAUCounter@@A+188
	mov	edx, DWORD PTR ?counters@@3PAUCounter@@A+192
	mov	esi, eax
	sub	esi, ecx
	cmp	esi, edx
	jle	SHORT $LN437@recExecute@2
	lea	eax, DWORD PTR [ecx+edx]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
$LN437@recExecute@2:
	mov	ecx, DWORD PTR ?nextsCounter@@3IA	; nextsCounter
	mov	edx, DWORD PTR ?nextCounter@@3HA	; nextCounter
	mov	esi, eax
	sub	esi, ecx
	cmp	esi, edx
	jle	SHORT $LN440@recExecute@2
	lea	eax, DWORD PTR [ecx+edx]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
$LN440@recExecute@2:
	test	BYTE PTR ?cpuRegs@@3UcpuRegisters@@A+594, 1
	mov	BYTE PTR ?eeEventTestIsActive@@3_NA, 0	; eeEventTestIsActive
	je	$LN483@recExecute@2
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+592
	test	cl, 1
	je	$LN483@recExecute@2
	test	cl, 6
	jne	$LN483@recExecute@2
	test	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, 1073741824 ; 40000000H
	je	$LN463@recExecute@2
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+952
	mov	edi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+824
	mov	esi, ebx
	sub	esi, edx
	cmp	esi, edi
	jl	$LN448@recExecute@2
	and	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, -1073741825 ; bfffffffH
	test	ecx, 1024				; 00000400H
	je	$LN463@recExecute@2
	mov	esi, DWORD PTR ?psH@@3PAEA		; psH
	mov	edx, DWORD PTR [esi+61440]
	test	edx, edx
	jne	SHORT $LN458@recExecute@2
	mov	esi, OFFSET ??_C@_0CH@FCDDAIFJ@?$CKPCSX2?$CK?3?5intcInterrupt?5already?5c@
	call	?Notice@Console@@YA_NPBD@Z		; Console::Notice
	jmp	SHORT $LN549@recExecute@2
$LN458@recExecute@2:
	mov	esi, DWORD PTR [esi+61456]
	and	esi, edx
	je	SHORT $LN463@recExecute@2
	test	BYTE PTR ?varLog@@3IA, 4
	je	SHORT $LN462@recExecute@2
	push	esi
	push	OFFSET ??_C@_0BC@LCGONOKJ@intcInterrupt?5?$CFx?6?$AA@
	call	?SrcLog_HW@@YA_NPBDZZ			; SrcLog_HW
	add	esp, 8
$LN462@recExecute@2:
	mov	eax, DWORD PTR ?psH@@3PAEA		; psH
	test	BYTE PTR [eax+61440], 2
	je	SHORT $LN456@recExecute@2
	xor	ecx, ecx
	call	?rcntRcount@@YIIH@Z			; rcntRcount
	mov	ecx, 1
	mov	DWORD PTR ?counters@@3PAUCounter@@A+12, eax
	call	?rcntRcount@@YIIH@Z			; rcntRcount
	mov	DWORD PTR ?counters@@3PAUCounter@@A+52, eax
$LN456@recExecute@2:
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+968
	push	ecx
	push	1024					; 00000400H
	call	?cpuException@@YAXII@Z			; cpuException
	add	esp, 8
$LN549@recExecute@2:
	mov	eax, DWORD PTR ?g_nextBranchCycle@@3IA	; g_nextBranchCycle
	mov	ebx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+960
	mov	ecx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+592
	jmp	SHORT $LN463@recExecute@2
$LN448@recExecute@2:
	mov	esi, eax
	sub	esi, edx
	cmp	esi, edi
	jle	SHORT $LN463@recExecute@2
	lea	eax, DWORD PTR [edi+edx]
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, eax	; g_nextBranchCycle
$LN463@recExecute@2:
	test	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, -2147483648 ; 80000000H
	je	$LN483@recExecute@2
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+956
	mov	esi, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+828
	sub	ebx, edx
	cmp	ebx, esi
	jl	$LN467@recExecute@2
	and	DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+964, 2147483647 ; 7fffffffH
	and	ecx, 67591				; 00010807H
	cmp	ecx, 67585				; 00010801H
	jne	SHORT $LN483@recExecute@2
	mov	edx, DWORD PTR ?psH@@3PAEA		; psH
	movzx	eax, WORD PTR [edx+57360]
	mov	cx, WORD PTR [edx+57362]
	and	cx, ax
	jne	SHORT $LN476@recExecute@2
	test	eax, 32768				; 00008000H
	je	SHORT $LN483@recExecute@2
$LN476@recExecute@2:
	test	BYTE PTR [edx+57344], 1
	je	SHORT $LN483@recExecute@2
	test	BYTE PTR ?varLog@@3IA, 4
	je	SHORT $LN482@recExecute@2
	test	cx, cx
	jne	SHORT $LN480@recExecute@2
	test	eax, 32768				; 00008000H
	jne	SHORT $LN480@recExecute@2
	xor	eax, eax
	jmp	SHORT $LN481@recExecute@2
$LN480@recExecute@2:
	mov	eax, 1
$LN481@recExecute@2:
	push	eax
	push	OFFSET ??_C@_0BC@IOCBKJEO@dmacInterrupt?5?$CFx?6?$AA@
	call	?SrcLog_HW@@YA_NPBDZZ			; SrcLog_HW
	add	esp, 8
$LN482@recExecute@2:
	mov	edx, DWORD PTR ?cpuRegs@@3UcpuRegisters@@A+968
	push	edx
	push	2048					; 00000800H
	call	?cpuException@@YAXII@Z			; cpuException
	add	esp, 8
	jmp	SHORT $LN483@recExecute@2
$LN467@recExecute@2:
	sub	eax, edx
	cmp	eax, esi
	jle	SHORT $LN483@recExecute@2
	add	esi, edx
	mov	DWORD PTR ?g_nextBranchCycle@@3IA, esi	; g_nextBranchCycle
$LN483@recExecute@2:
	cmp	BYTE PTR _vsyncEvent$872313[ebp], 0
	je	$LL3@recExecute@2

; 796  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?recExecute@@YAXXZ ENDP					; recExecute
_TEXT	ENDS
END
